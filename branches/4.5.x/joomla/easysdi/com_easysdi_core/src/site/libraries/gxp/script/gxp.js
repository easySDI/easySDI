/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */


Ext.namespace("gxp");

gxp.util = {
    
    /** private: property[_uniqueNames]
     *  ``Object`` cache that keeps track of unique names
     */
    _uniqueNames: {},

    /** api: function[getOGCExceptionText]
     *  :arg report: ``Object`` The exception report object
     *  :return: ``String`` A single string representing the possible stack of
     *      exception messages.
     *
     *  Get a string message from an OGC exception report object.
     */ 
    getOGCExceptionText: function(report) {
        var msg;
        if (report && report.exceptions) {
            msg = [];
            Ext.each(report.exceptions, function(obj) {
                Ext.each(obj.texts, function(text) {
                    msg.push(text);
                });
            });
            msg = msg.join("\n");
        } else {
            msg = "Unknown error (no exception report).";
        }
        return msg;
    },

    /** api: function[dispatch]
     *  :arg functions: ``Array(Function)`` List of functions to be called.
     *      All functions will be called with two arguments - a callback to
     *      call when the sequence is done and a storage object.
     *  :arg complete:  ``Function`` A function that will be called when all
     *      other functions report that they are done.  The final callback
     *      will be called with the storage object passed to all other
     *      functions.
     *  :arg scope: ``Object`` Optional object to be set as the scope of all
     *      functions called.
     *      
     *  Allows multiple asynchronous sequences to be called in parallel.  A
     *  final callback is called when all other sequences report that they
     *  are done.
     */
    dispatch: function(functions, complete, scope) {
        complete = complete || Ext.emptyFn;
        scope = scope || this;
        var requests = functions.length;
        var responses = 0;
        var storage = {};
        function respond() {
            ++responses;
            if(responses === requests) {
                complete.call(scope, storage);
            }
        }
        function trigger(index) {
            window.setTimeout(function() {
                functions[index].apply(scope, [respond, storage]);
            });
        }
        for(var i=0; i<requests; ++i) {
            trigger(i);
        }
    },
    
    /** api: function[uniqueName]
     *  :arg name: ``String`` The name to make unique across this session.
     *  :arg delimiter: ``Char`` Optional. Delimiter for appending the
     *      number that makes the new name unique. Defaults to " " (blank).
     *  :return: ``String`` a unique name based on ``name``
     *  
     *  Appends a delimiter and a number to make the passed ``name`` unique
     *  in the current session.
     */
    uniqueName: function(name, delimiter) {
        delimiter = delimiter || " ";
        var regEx = new RegExp(delimiter + "[0-9]*$");
        var key = name.replace(regEx, "");
        var regExResult = regEx.exec(name);
        var count = this._uniqueNames[key] !== undefined ?
            this._uniqueNames[key] :
            (regExResult instanceof Array ? Number(regExResult[0]) : undefined);
        var newName = key;
        if(count !== undefined) {
            count++;
            newName += delimiter + count;
        }
        this._uniqueNames[key] = count || 0;
        return newName;
    },

    /** api: function[getAbsoluteUrl]
     *  :arg url: ``String``
     *  :return: ``String``
     *  
     *  Converts the provided url to an absolute url.
     */
    getAbsoluteUrl: function(url) {
        var a;
        if(Ext.isIE6 || Ext.isIE7 || Ext.isIE8) {
            a = document.createElement("<a href='" + url + "'/>");
            a.style.display = "none";
            document.body.appendChild(a);
            a.href = a.href;
            document.body.removeChild(a);
        } else {
            a = document.createElement("a");
            a.href = url;
        }
        return a.href;
    },

    /** api: function[throttle]
     *  :arg func: ``Function``
     *  :arg interval: ``Integer``
     *  :arg scope: ``Object``
     *  :return: ``Function``
     *
     *  Returns a function, that, when invoked, will only be triggered at 
     *  most once during a given window of time.
     */
    throttle: (function() {
        // taken from ExtJS 4.1
        // TODO remove when we upgrade to ExtJS 4.1 or higher.
        /**
         * Creates a throttled version of the passed function which, when called repeatedly and
         * rapidly, invokes the passed function only after a certain interval has elapsed since the
         * previous invocation.
         *
         * This is useful for wrapping functions which may be called repeatedly, such as
         * a handler of a mouse move event when the processing is expensive.
         *
         * @param {Function} fn The function to execute at a regular time interval.
         * @param {Number} interval The interval **in milliseconds** on which the passed function is executed.
         * @param {Object} scope (optional) The scope (`this` reference) in which
         * the passed function is executed. If omitted, defaults to the scope specified by the caller.
         * @returns {Function} A function which invokes the passed function at the specified interval.
         */
        var createThrottled = function(fn, interval, scope) {
            var lastCallTime, elapsed, lastArgs, timer, execute = function() {
                fn.apply(scope || this, lastArgs);
                lastCallTime = new Date().getTime();
            };

            return function() {
                elapsed = new Date().getTime() - lastCallTime;
                lastArgs = arguments;

                clearTimeout(timer);
                if (!lastCallTime || (elapsed >= interval)) {
                    execute();
                } else {
                    timer = setTimeout(execute, interval - elapsed);
                }
            };
        };
        return function(func, interval, scope) {
            return createThrottled(func, interval, scope);
        };
    })(),

    /** api: function[md5]
     *  :arg data: ``String``
     *  :returns: ``String`` md5 hash
     *
     *  Encrypts the specified string using MD5.
     */
    md5: (function() {

        /* md5.js - MD5 Message-Digest
         * Copyright (C) 1999,2002 Masanao Izumo <iz@onicos.co.jp>
         * Version: 2.0.0
         * LastModified: May 13 2002
         *
         * This program is free software.  You can redistribute it and/or modify
         * it without any warranty.  This library calculates the MD5 based on RFC1321.
         * See RFC1321 for more information and algorism.
         */

        /* Interface:
         * md5_128bits = MD5_hash(data);
         * md5_hexstr = MD5_hexhash(data);
         */

        /* ChangeLog
         * 2002/05/13: Version 2.0.0 released
         * NOTICE: API is changed.
         * 2002/04/15: Bug fix about MD5 length.
         */


        //    md5_T[i] = parseInt(Math.abs(Math.sin(i)) * 4294967296.0);
        var MD5_T = [
            0x00000000, 0xd76aa478, 0xe8c7b756, 0x242070db,
            0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613,
            0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1,
            0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e,
            0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51,
            0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681,
            0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87,
            0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9,
            0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122,
            0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60,
            0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085,
            0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8,
            0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7,
            0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d,
            0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314,
            0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb,
            0xeb86d391
        ];

        var MD5_round1 = [
            [ 0, 7, 1], [ 1,12, 2],
            [ 2,17, 3], [ 3,22, 4],
            [ 4, 7, 5], [ 5,12, 6],
            [ 6,17, 7], [ 7,22, 8],
            [ 8, 7, 9], [ 9,12,10],
            [10,17,11], [11,22,12],
            [12, 7,13], [13,12,14],
            [14,17,15], [15,22,16]
        ];

        var MD5_round2 = [
            [ 1, 5,17], [ 6, 9,18],
            [11,14,19], [ 0,20,20],
            [ 5, 5,21], [10, 9,22],
            [15,14,23], [ 4,20,24],
            [ 9, 5,25], [14, 9,26],
            [ 3,14,27], [ 8,20,28],
            [13, 5,29], [ 2, 9,30],
            [ 7,14,31], [12,20,32]
        ];

        var MD5_round3 = [
            [ 5, 4,33], [ 8,11,34],
            [11,16,35], [14,23,36],
            [ 1, 4,37], [ 4,11,38],
            [ 7,16,39], [10,23,40],
            [13, 4,41], [ 0,11,42],
            [ 3,16,43], [ 6,23,44],
            [ 9, 4,45], [12,11,46],
            [15,16,47], [ 2,23,48]
        ];

        var MD5_round4 = [
            [ 0, 6,49], [ 7,10,50],
            [14,15,51], [ 5,21,52],
            [12, 6,53], [ 3,10,54],
            [10,15,55], [ 1,21,56],
            [ 8, 6,57], [15,10,58],
            [ 6,15,59], [13,21,60],
            [ 4, 6,61], [11,10,62],
            [ 2,15,63], [ 9,21,64]
        ];

        function MD5_F(x, y, z) { return (x & y) | (~x & z); }
        function MD5_G(x, y, z) { return (x & z) | (y & ~z); }
        function MD5_H(x, y, z) { return x ^ y ^ z;          }
        function MD5_I(x, y, z) { return y ^ (x | ~z);       }

        var MD5_round = [
            [MD5_F, MD5_round1],
            [MD5_G, MD5_round2],
            [MD5_H, MD5_round3],
            [MD5_I, MD5_round4]
        ];

        function MD5_pack(n32) {
            return String.fromCharCode(n32 & 0xff) +
                String.fromCharCode((n32 >>> 8) & 0xff) +
                String.fromCharCode((n32 >>> 16) & 0xff) +
                String.fromCharCode((n32 >>> 24) & 0xff);
        }

        function MD5_unpack(s4) {
            return s4.charCodeAt(0) |
                (s4.charCodeAt(1) <<  8) |
                (s4.charCodeAt(2) << 16) |
                (s4.charCodeAt(3) << 24);
        }

        function MD5_number(n) {
            while (n < 0) {
                n += 4294967296;
            }
            while (n > 4294967295) {
                n -= 4294967296;
            }
            return n;
        }

        function MD5_apply_round(x, s, f, abcd, r) {
            var a, b, c, d;
            var kk, ss, ii;
            var t, u;

            a = abcd[0];
            b = abcd[1];
            c = abcd[2];
            d = abcd[3];
            kk = r[0];
            ss = r[1];
            ii = r[2];

            u = f(s[b], s[c], s[d]);
            t = s[a] + u + x[kk] + MD5_T[ii];
            t = MD5_number(t);
            t = ((t<<ss) | (t>>>(32-ss)));
            t += s[b];
            s[a] = MD5_number(t);
        }

        function MD5_hash(data) {
            var abcd, x, state, s;
            var len, index, padLen, f, r;
            var i, j, k;
            var tmp;

            state = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476];
            len = data.length;
            index = len & 0x3f;
            padLen = (index < 56) ? (56 - index) : (120 - index);
            if(padLen > 0) {
                data += "\x80";
                for(i = 0; i < padLen - 1; i++) {
                    data += "\x00";
                }
            }
            data += MD5_pack(len * 8);
            data += MD5_pack(0);
            len  += padLen + 8;
            abcd = [0, 1, 2, 3];
            x    = [16];
            s    = [4];

            for(k = 0; k < len; k += 64) {
                for(i = 0, j = k; i < 16; i++, j += 4) {
                    x[i] = data.charCodeAt(j) |
                        (data.charCodeAt(j + 1) <<  8) |
                        (data.charCodeAt(j + 2) << 16) |
                        (data.charCodeAt(j + 3) << 24);
                }
                for(i = 0; i < 4; i++) {
                    s[i] = state[i];
                }
                for(i = 0; i < 4; i++) {
                    f = MD5_round[i][0];
                    r = MD5_round[i][1];
                    for(j = 0; j < 16; j++) {
                        MD5_apply_round(x, s, f, abcd, r[j]);
                        tmp = abcd[0];
                        abcd[0] = abcd[3];
                        abcd[3] = abcd[2];
                        abcd[2] = abcd[1];
                        abcd[1] = tmp;
                    }
                }

                for(i = 0; i < 4; i++) {
                   state[i] += s[i];
                   state[i] = MD5_number(state[i]);
                }
            }

            return MD5_pack(state[0]) +
                MD5_pack(state[1]) +
                MD5_pack(state[2]) +
                MD5_pack(state[3]);
        }

        function MD5_hexhash(data) {
            var i, out, c;
            var bit128;

            bit128 = MD5_hash(data);
            out = "";
            for(i = 0; i < 16; i++) {
                c = bit128.charCodeAt(i);
                out += "0123456789abcdef".charAt((c>>4) & 0xf);
                out += "0123456789abcdef".charAt(c & 0xf);
            }
            return out;
        }

        return function(data) {
            return MD5_hexhash(data);
        };
    })()

};

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

Ext.ns("gxp.util");

/**
 * Based on functions from https://github.com/tschaub/geoscript-js
 */
gxp.util.color = (function() {
    
    var exports = {};
    
    /**
     * Lookup for CSS color names supported by major browsers.
     * http://www.w3schools.com/css/css_colornames.asp
     */
    var cssColors = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavender: "#e6e6fa",
        lavenderblush: "#fff0f5",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgrey: "#d3d3d3",
        lightgreen: "#90ee90",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370d8",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#d87093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
    };
    
    /** private: function[getHexColor]
     *  :arg color: ``String`` A CSS color name or hexidecimal color.
     *  :returns: ``String`` The hexideicmal color representation of the given 
     *      color.  Returns undefined if no hex representation can be derived.
     *
     *  Converts a color name or hex color to a hex color.
     */
    var getHexColor = function(color) {
        color = color.toLowerCase();
        var hex;
        if (color[0] === "#") {
            hex = color;
        } else if (color in cssColors) {
            hex = cssColors[color];
        } else if (color.match(/^[0-9a-f]{6}$/)) {
            hex = "#" + color;
        }
        return hex;
    };
    
    /** api: function[rgb]
     *  :arg hex: ``String`` A hex css color or a css color name
     *  :returns: ``Array`` Decimal r, g, and b values for the color
     *
     *  Converts a hex color or color name to rgb values.
     */
    rgb = exports.rgb = function(hex) {
        hex = getHexColor(hex);
        var rgb;
        if (hex) {
            rgb = [
                parseInt(hex.substr(1, 2), 16),
                parseInt(hex.substr(3, 2), 16),
                parseInt(hex.substr(5, 2), 16)
            ];
        }
        return rgb;
    };
    
    /** api: function[hex]
     *  :arg rgb: ``Array`` Decimal r, g and b values of a color
     *  :returns: ``String`` hex value for the color
     *
     *  Converts rgb color values to a hex color.
     */
    hex = exports.hex = function(rgb) {
        return [
            "#",
            Number(rgb[0]).toString(16),
            Number(rgb[1]).toString(16),
            Number(rgb[2]).toString(16)
        ].join("");
    };
    
    /** api: function[rgb2hsl]
     *  :arg rgb: ``Array`` Decimal r, g and b values of a color
     *  :returns: ``Array`` h, s and l color values
     *
     *  Converts rgb values to hsl values.
     */
    var rgb2hsl = exports.rgb2hsl = function(rgb) {
        var r = rgb[0] / 255,
            g = rgb[1] / 255,
            b = rgb[2] / 255;
        var max = Math.max(r, g, b), 
            min = Math.min(r, g, b);
        var h, s, l = (max + min) / 2;

        if (max == min) {
            h = s = 0; // achromatic
        } else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return [h, s, l];
    };

    // helper function for hsl2rgb operation
    function hue2rgb(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }

    /** api: function[hsl2rgb]
     *  :arg hsl: ``Array`` h, s and l color values
     *  :returns: ``Array`` Decimal r, g and b values of a color
     *
     *  Converts hsl values to rgb values.
     */
    var hsl2rgb = exports.hsl2rgb = function(hsl) {
        var r, g, b;
        var h = hsl[0],
            s = hsl[1],
            l = hsl[2];

        if (s == 0) {
            r = g = b = l; // achromatic
        } else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    };

    return exports;
})();
/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @require util/color.js
 */

Ext.ns("gxp.util");

/**
 * Based on functions from https://github.com/tschaub/geoscript-js
 */
gxp.util.style = (function() {
    
    var exports = {},
        hsl2rgb = gxp.util.color.hsl2rgb,
        rgb2hsl = gxp.util.color.rgb2hsl,
        rgb = gxp.util.color.rgb,
        hex = gxp.util.color.hex,
        colorRegEx = /Color$/,
        literalRegEx = /(Width|Height|[rR]otation|Opacity|Size)$/;
    
    /** api: function[interpolateSymbolizers]
     *  :arg start: ``Array`` Array of ``OpenLayers.Symbolizer`` instances
     *  :arg end: ``Array`` Array of ``OpenLayers.Symbolizer`` instances
     *  :arg fraction: ``Float`` Number between 0 and 1, which is the distance
     *      between ``start`` and ``end``
     *  :returns: ``Array`` Array of ``OpenLayers.Symbolizer instances
     *
     *  Interpolates an array of symbolizers between start and end values.
     */
    exports.interpolateSymbolizers = function(start, end, fraction) {
        var startSymbolizer, endSymbolizer;
        var parts = [];
        for (var i=0, ii=start.length; i<ii; ++i) {
            startSymbolizer = start[i];
            endSymbolizer = end[i];
            if (!endSymbolizer) {
                throw new Error("Start style and end style must have equal number of parts.");
            }
            parts[i] = interpolateSymbolizer(startSymbolizer, endSymbolizer, fraction);
        }
        return parts;
    };

    function interpolateSymbolizer(startSymbolizer, endSymbolizer, fraction) {
        var symbolizer = Ext.apply({}, startSymbolizer);
        Ext.iterate(startSymbolizer, function(key) {
            if (colorRegEx.test(key)) {
                var startHSL = rgb2hsl(rgb(startSymbolizer[key])),
                    endHSL = rgb2hsl(rgb(endSymbolizer[key]));
                if (startHSL && endHSL) {
                    var hsl = [];
                    for (var i=startHSL.length-1; i>=0; --i) {
                        hsl[i] = startHSL[i] + (fraction * (endHSL[i] - startHSL[i]));
                    }
                    symbolizer[key] = hex(hsl2rgb(hsl));
                }
            } else if (literalRegEx.test(key)) {
                var literal = interpolateLiteral(key, startSymbolizer, endSymbolizer, fraction);
                if (literal !== null) {
                    symbolizer[key] = literal;
                }
            }
        });
        return symbolizer;
    }

    function interpolateLiteral(property, startSymbolizer, endSymbolizer, fraction) {
        var literal = null;
        if ((property in startSymbolizer) && (property in endSymbolizer)) {
            var startValue = startSymbolizer[property];
            var endValue = endSymbolizer[property];
            if (startValue.literal && endValue.literal) {
                startValue = parseFloat(startValue.text);
                endValue = parseFloat(endValue.text);
                literal = startValue + (fraction * (endValue - startValue));
            }
        }
        return literal;
    }
    
    return exports;
})();
/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

Ext.ns("gxp.data");

/** api: (define)
 *  module = gxp.data
 *  class = AutoCompleteProxy
 *  extends = GeoExt.data.ProtocolProxy
 */

/** api: constructor
 *  .. class:: AutoCompleteProxy(config)
 *
 *    A protocol proxy that will add the filter before doing the request.
 *    params.query contains the text entered by the user, when he enters more
 *    than minChars characters.
 */
gxp.data.AutoCompleteProxy = Ext.extend(GeoExt.data.ProtocolProxy, {

    /** private: method[doRequest]
     *  :param action: ``String`` The crud action type (create, read, update, 
     *      destroy)
     *  :param records: ``Ext.data.Record`` or ``Array(Ext.data.Record)``
     *  :param params: ``Object`` An object containing properties which are to
     *       be used as HTTP parameters
     *  :param reader: ``Ext.data.DataReader`` The Reader object which 
     *      converts the data object into a block of Ext.data.Records.
     *  :param callback: ``Function`` A function to be called after the request.
     *  :param scope: ``Object`` The scope in which the callback function is 
     *      executed.
     *  :param arg: ``Object`` An optional argument which is passed to the 
     *      callback as its second parameter.
     */
    doRequest: function(action, records, params, reader, callback, scope, arg) {
        if (params.query) {
            params.filter = new OpenLayers.Filter.Comparison({
                type: OpenLayers.Filter.Comparison.LIKE,
                matchCase: false,
                property: this.protocol.propertyNames[0],
                value: '*' + params.query + '*'
            });
            delete params.query;
        }
        gxp.data.AutoCompleteProxy.superclass.doRequest.apply(this, arguments);
    }

});

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

Ext.ns("gxp.data");

/** api: (define)
 *  module = gxp.data
 *  class = AutoCompleteReader
 *  extends = GeoExt.data.FeatureReader
 */

/** api: constructor
 *  .. class:: AutoCompleteReader(config)
 *
 *    A feature reader which filters out duplicates. Used for autocomplete
 *    search fields.
 */
gxp.data.AutoCompleteReader = Ext.extend(GeoExt.data.FeatureReader, {

    /** private: method[read]
     *  :param response: ``OpenLayers.Protocol.Response``
     *  :return: ``Object`` An object with two properties. The value of the
     *      ``records`` property is the array of records corresponding to
     *      the features. The value of the ``totalRecords" property is the
     *      number of records in the array.
     *      
     *  This method is only used by a DataProxy which has retrieved data.
     */
    read: function(response) {
        // since we cannot do a distinct query on a WFS, filter out duplicates here
        var field = this.meta.uniqueField;
        this.features = [];
        for (var i=0,ii=response.features.length;i<ii;++i) {
            var feature = response.features[i];
            var value = feature.attributes[field];
            if (this.isDuplicate(field, value) === false) {
                this.features.push(feature);
            } else {
                feature.destroy();
            }
        }
        response.features = this.features;
        return gxp.data.AutoCompleteReader.superclass.read.apply(this, arguments);
    },

    /** private: method[isDuplicate]
     *  :param field: ``String`` The name of the field for which to check duplicates.
     *  :param value: ``String`` The value for which to check if it is already in the
     *      list of features.
     *  :return: ``Boolean`` True if the value was already present.
     *      
     *  Check if the value of a certain value is a duplicate.
     */
    isDuplicate: function(field, value) {
        for (var i=0,ii=this.features.length;i<ii;++i) {
            if (this.features[i].attributes[field] === value) {
                return true;
            }
        }
        return false;
    }

});

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @require GeoExt/data/StyleReader.js
 */

Ext.ns("gxp.data");

/** api: (define)
 *  module = gxp.data
 *  class = GroupStyleReader
 *  extends = GeoExt.data.StyleReader
 */

/** api: constructor
 *  .. class:: GroupStyleReader(config)
 *
 *    A subclass of ``GeoExt.data.StyleReader`` that adds rule group specific
 *    features:
 *
 *    * For classified groups, the filters of neighboring classes will be
 *      updated, to make sure that classes always align with each other.
 */
gxp.data.GroupStyleReader = Ext.extend(GeoExt.data.StyleReader, {

    /** private: method[onMetaChange]
     *  Override to intercept the set method of the record prototype used
     *  by the reader, so it makes sure that filters are always stored as
     *  ``OpenLayers.Filter`` instances, and neighboring classes are aligned
     *  to each other by making them share class boundaries.
     */
    onMetaChange: function() {
        gxp.data.GroupStyleReader.superclass.onMetaChange.apply(this, arguments);
        var recordType = this.recordType,
            aligning = false;
        recordType.prototype.set = Ext.createInterceptor(this.recordType.prototype.set, function(name, value) {
            if (!aligning && name === "filter") {
                aligning = true;
                var store = this.store,
                    modified = this.get("filter");
                    BETWEEN = OpenLayers.Filter.Comparison.BETWEEN;
                if (modified instanceof OpenLayers.Filter && typeof value === "string") {
                    value = OpenLayers.Format.CQL.prototype.read(value);
                }
                var prop, index = store.indexOf(this);
                if (index < store.getCount() - 1) {
                    prop = value.type === BETWEEN ? "upperBoundary" : "value";
                    if (value[prop] !== modified[prop]) {
                        var nextRec = store.getAt(index + 1),
                            nextFilter = nextRec.get("filter").clone(),
                            nextProp = nextFilter.type === BETWEEN ? "lowerBoundary" : "value";
                        nextFilter[nextProp] = value[prop];
                        nextRec.set("filter", nextFilter);
                    }
                }
                if (index > 0) {
                    prop = value.type === BETWEEN ? "lowerBoundary" : "value";
                    if (value[prop] !== modified[prop]) {
                        var prevRec = store.getAt(index - 1),
                            prevFilter = prevRec.get("filter").clone(),
                            prevProp = prevFilter.type === BETWEEN ? "upperBoundary" : "value";
                        prevFilter[prevProp] = value[prop];
                        prevRec.set("filter", prevFilter);
                    }
                }
                recordType.prototype.set.apply(this, [name, value]);
                aligning = false;
                return false;
            }
        });
    }

});

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @require GeoExt/data/StyleReader.js
 */

/** api: (define)
 *  module = gxp.data
 *  class = RuleGroupReader
 *  base_link = `GeoExt.data.StyleReader <http://dev.geoext.org/docs/lib/GeoExt/data/StyleReader.html>`_
 */
Ext.ns("gxp.data");

/** api: constructor
 *  .. class:: RuleGroupReader(config)
 *
 *  A ``StyleReader`` for reading rule groups of vector styles.
 */   
gxp.data.RuleGroupReader = Ext.extend(GeoExt.data.StyleReader, {
    
    /** private: method[constructor]
     *  :arg meta: ``Object``
     *  :arg recordType: ``Ext.data.Record``
     */
    constructor: function(meta, recordType) {
        meta = meta || {
            fields: [
                "symbolizers", "filter",
                {name: "label", mapping: "title"},
                {name: "name", convert: function(v, re) {
                    var obj;
                    try {
                        obj = Ext.util.JSON.decode(v);
                    } catch(e) {
                        obj = {group: "Custom", name: v};
                    }
                    re.group = obj.group;
                    return obj;
                }},
                "group", "description", "elseFilter",
                "minScaleDenominator", "maxScaleDenominator"
            ],
            storeToData: function(store) {
                var rules = GeoExt.data.StyleReader.metaData.rules.storeToData(store),
                    rule, i;
                for (i=rules.length-1; i>=0; --i) {
                    rule = rules[i];
                    if (typeof rule.name === "object") {
                        if (rule.group === "Custom") {
                            rule.name = rule.name.name;
                        } else {
                            rule.name = Ext.util.JSON.encode(rule.name);
                        }
                        delete rule.group;
                    }
                }
                return rules;
            }
        };
        gxp.data.RuleGroupReader.superclass.constructor.apply(this, [meta, recordType]);
    }
    
});

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @require OpenLayers/Format/WPSExecute.js
 * @require util/style.js
 */

/** api: (define)
 *  module = gxp.data
 *  class = FeatureTypeClassifier
 *  base_link = `Ext.util.Observable <http://extjs.com/deploy/dev/docs/?class=Ext.util.Observable>`_
 */

Ext.ns("gxp.data");

/** api: constructor
 *  .. class:: FeatureTypeClassifier(config)
 *
 *  Utility class for creating classifications of vector styles
 */   
gxp.data.FeatureTypeClassifier = Ext.extend(Ext.util.Observable, {
    
    /** api: config[store]
     *  ``Ext.data.Store`` Store of style rules, read from GetStyles response
     *  using GeoExt.data.StyleReader. Classification operations will be
     *  performed on the layer denoted as ``layerName`` in the ``namedLayer``
     *  object of the raw SLD.
     */
    store: null,
    
    /** private: method[constructor]
     */
    constructor: function(config) {
        gxp.data.FeatureTypeClassifier.superclass.constructor.apply(this, arguments);
        Ext.apply(this, config);
    },
    
    /** api: method[classify]
     *  :arg group: ``String`` Name of the group to classify
     *  :method: ``String`` Name of one of the classification methods from
     *      :obj:`methods`
     *  :args: ``Array`` Arguments to pass to the classification method
     *
     *  Creates a classification for a :obj:`group`. If there are already rules
     *  for the selected group, the class breaks will be replaced with the new
     *  classification and linear stretching will be applied to the existing
     *  symbolizers to match the number of new classes.
     */
    classify: function(group, method, args, callback, scope) {
        this.store.filter("group", group);
        var start, end, count = this.store.getCount();
        if (count > 0) {
            start = this.store.getAt(0).get("symbolizers");
            end = this.store.getAt(count - 1).get("symbolizers");
        }
        var targetArgs = [function(store) {
            var fraction, i = 0, count = store.getCount(), data;
            store.each(function(rec) {
                fraction = i / count;
                var targetRec = this.store.getAt(i);
                if (!targetRec) {
                    // add rule if new classification has more classes
                    targetRec = new this.store.recordType(Ext.apply({}, data));
                    this.store.add([targetRec]);
                }
                data = targetRec.data;
                var filter = rec.get("filter");
                if (start && end) {
                    targetRec.set("symbolizers", gxp.util.style.interpolateSymbolizers(start, end, fraction));
                }
                targetRec.set("filter", filter);
                //TODO Use a template for this
                targetRec.set("label", filter.lowerBoundary + "-" + filter.upperBoundary);
                targetRec.set("group", group);
                targetRec.set("name", Ext.applyIf({
                    group: group,
                    method: method,
                    args: args
                }, targetRec.get("name")));
                i++;
            }, this);
            // remove rules if new classification has less classes
            var rec;
            while(rec = this.store.getAt(i)) {
                this.store.remove(rec);
                i++;
            }
            this.store.clearFilter();
            if (callback) {
                callback.call(scope);
            }
        }];
        targetArgs.unshift.apply(targetArgs, args);
        this.methods[method].apply(this, targetArgs);
    },
    
    /** api: property[methods]
     *  ``Object`` Classification methods for use with ``classify``:
     *
     *  * ``graduated(attribute, classes, method)`` Uses GeoServer's
     *    ``gs:getFeatureClassStats`` WPS process. ``attribute`` is the
     *    field of the layer to create the classification from; ``classes``
     *    is the number of classes to create, and ``method`` is one of
     *    "EQUAL_INTERVL", "NATURAL_BREAKS", "QUANTILE".
     */
    methods: {
        graduated: function(attribute, classes, method, callback) {
            var process = {
                identifier: "gs:FeatureClassStats", 
                dataInputs: [{
                    identifier: "features",
                    reference: {
                        mimeType: "text/xml; subtype=wfs-collection/1.0", 
                        href: "http://geoserver/wfs", 
                        method: "POST",
                        body: {
                            wfs: {
                                version: "1.0.0",
                                outputFormat: "GML2",
                                featureType: this.store.reader.raw.layerName
                            }
                        }
                    }
                }, {
                    identifier: "attribute",
                    data: {
                        literalData: {
                            value: attribute
                        }
                    }
                }, {
                    identifier: "classes",
                    data: {
                        literalData: {
                            value: classes
                        }
                    }
                }, {
                    identifier: "method",
                    data: {
                        literalData: {
                            value: method
                        }
                    }
                }],
                responseForm: {
                    rawDataOutput: {
                        mimeType: "text/xml",
                        identifier: "results"
                    }
                }
            };
            var store = new Ext.data.XmlStore({
                record: "Class",
                fields: [
                    {name: "count", mapping: "@count"},
                    {name: "filter", convert: function(v, re) {
                        return new OpenLayers.Filter.Comparison({
                            type: OpenLayers.Filter.Comparison.BETWEEN,
                            property: attribute,
                            lowerBoundary: parseFloat(re.getAttribute("lowerBound")),
                            upperBoundary: parseFloat(re.getAttribute("upperBound"))
                        });
                    }}
                ],
                proxy: new Ext.data.HttpProxy({
                    url: "/geoserver/wps",
                    method: "POST",
                    xmlData: new OpenLayers.Format.WPSExecute().write(process)
                }),
                autoLoad: true,
                listeners: {
                    load: callback,
                    scope: this
                }
            });
            return store;
        }
    }
    
});

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires data/WFSProtocolProxy.js
 * @requires GeoExt/data/FeatureStore.js
 */

/** api: (define)
 *  module = gxp.data
 *  class = WFSFeatureStore
 *  base_link = `Ext.data.Store <http://extjs.com/deploy/dev/docs/?class=Ext.data.Store>`_
 */
Ext.namespace("gxp.data");

gxp.data.WFSFeatureStore = Ext.extend(GeoExt.data.FeatureStore, {
    
    /** api: config[maxFeatures]
     *  ``Number``
     *  Optional limit for number of features requested in a read.  No limit
     *  set by default.
     */
    
    /** api: config[ogcFilter]
     *  ``OpenLayers.Filter``
     *  Optional filter to set on the WFSProtocolProxy.
     */
    
    /** api: config[multi]
     *  ``Boolean`` If set to true, geometries will be casted to Multi
     *  geometries before writing. No casting will be done for reading.
     */

    /** api: method[setOgcFilter]
     *  :arg ogcFilter: ``OpenLayers.Filter`` Update the filter used by the
     *      protocol proxy.  You must manually call load or reload to trigger
     *      loading.
     */
    setOgcFilter: function(ogcFilter) {
        this.proxy.setFilter(ogcFilter);
    },
    
    /** private */
    constructor: function(config) {
        if(!(config.proxy && config.proxy instanceof GeoExt.data.ProtocolProxy)) {
            config.proxy = new gxp.data.WFSProtocolProxy(Ext.apply({
                srsName: config.srsName,
                url: config.url,
                featureType: config.featureType,
                featureNS:  config.featureNS,
                geometryName: config.geometryName,
                schema: config.schema,
                filter: config.ogcFilter,
                maxFeatures: config.maxFeatures,
                multi: config.multi
            }, config.proxy));
        }
        if(!config.writer) {
            // a writer is not used, but is required by store.save
            config.writer = new Ext.data.DataWriter({
                write: Ext.emptyFn
            });
        }
        gxp.data.WFSFeatureStore.superclass.constructor.apply(this, arguments);
        
        /**
         * TODO: Determine what needs to be done to the feature reader to
         * properly fit the 3.0 DataReader inteface.
         *
         * This method gets called with the data that goes to the reader.realize
         * method.  This method requires that the data has a property with the
         * same name as reader.meta.idProperty.  The WFSProtocolProxy prepares
         * a data object for each feature, with a fid and feature property.  The
         * return from this method will be applied to record.data.  So it makes
         * sense that it looks very much like what reader.readRecords does.
         */
        this.reader.extractValues = (function(data, items, length) {
            var obj = this.readRecords([data.feature]);
            return obj.records[0].data;
        }).createDelegate(this.reader);
        
        /**
         * TODO: Determine the appropriate meta.idProperty value.
         * If this is set to fid, then we can't use store.getById given a feature
         * until after the feature has been saved.  If this is set to id, then
         * we better never have to create a new feature that represents the
         * same record.
         */
        this.reader.meta.idProperty = "id";
        
        /**
         * TODO: Same as above, but it seems that the getId method is responsible
         * for determining the id in Ext > 3.0. This is crucial after changes
         * are committed (see WFSProtocolProxy::onProtocolCommit), because the
         * callback there does an isData check, which involves an attempt to get
         * the id through this method.
         */
        this.reader.getId = function(data) {
            return data.id;
        };
        
        
        
    }
    
});

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires GeoExt/data/ProtocolProxy.js
 */

/** api: (define)
 *  module = gxp.data
 *  class = WFSProtocolProxy
 *  base_link = `Ext.data.DataProxy <http://extjs.com/deploy/dev/docs/?class=Ext.data.DataProxy>`_
 */
Ext.namespace("gxp.data");

gxp.data.WFSProtocolProxy = Ext.extend(GeoExt.data.ProtocolProxy, {
    
    /** api: method[setFilter]
     *  :arg filter: ``OpenLayers.Filter`` Filter to be set on the WFS protocol.
     *
     *  Does not trigger anything on the protocol (for now).
     */
    setFilter: function(filter) {
        this.protocol.filter = filter;
        // TODO: The protocol could use a setFilter method.
        this.protocol.options.filter = filter;
    },
    
    /** api: constructor
     *  .. class:: WFSProtocolProxy
     *
     *      A data proxy for use with ``OpenLayers.Protocol.WFS`` objects.
     *      
     *      This is mainly to extend Ext 3.0 functionality to the
     *      GeoExt.data.ProtocolProxy.  This could be simplified by having
     *      the ProtocolProxy support writers (implement doRequest).
     */
    constructor: function(config) {

        Ext.applyIf(config, {

            /** api: config[version]
             *  ``String``
             *  WFS version.  Default is "1.1.0".
             */
            version: "1.1.0"

            /** api: config[maxFeatures]
             *  ``Number``
             *  Optional limit for number of features requested in a read.  No
             *  limit set by default.
             */

            /** api: config[multi]
             *  ``Boolean`` If set to true, geometries will be casted to Multi
             *  geometries before writing. No casting will be done for reading.
             */

        });
        
        // create the protocol if none provided
        if(!(this.protocol && this.protocol instanceof OpenLayers.Protocol)) {
            config.protocol = new OpenLayers.Protocol.WFS(Ext.apply({
                version: config.version,
                srsName: config.srsName,
                url: config.url,
                featureType: config.featureType,
                featureNS :  config.featureNS,
                geometryName: config.geometryName,
                schema: config.schema,
                filter: config.filter,
                maxFeatures: config.maxFeatures,
                multi: config.multi
            }, config.protocol));
        }

        gxp.data.WFSProtocolProxy.superclass.constructor.apply(this, arguments);
    },


    /** private: method[doRequest]
     *  :arg action: ``String`` The crud action type (create, read, update,
     *      destroy)
     *  :arg records: ``Array(Ext.data.Record)`` If action is load, records will
     *      be null
     *  :arg params: ``Object`` An object containing properties which are to be
     *      used as request parameters.
     *  :arg reader: ``Ext.data.DataReader`` The Reader object which converts
     *      the data object into a block of ``Ext.data.Record`` objects.
     *  :arg callback: ``Function``  A function to be called after the request.
     *      The callback is passed the following arguments: records, options,
     *      success.
     *  :arg scope: ``Object`` The scope in which to call the callback.
     *  :arg arg: ``Object`` An optional argument which is passed to the
     *      callback as its second parameter.
     */
    doRequest: function(action, records, params, reader, callback, scope, arg) {
        
        // remove the xaction param tagged on because we're using a single url
        // for all actions
        delete params.xaction;
        
        if (action === Ext.data.Api.actions.read) {
            this.load(params, reader, callback, scope, arg);
        } else {
            if(!(records instanceof Array)) {
                records = [records];
            }
            // get features from records
            var features = new Array(records.length), feature;
            Ext.each(records, function(r, i) {
                features[i] = r.getFeature();
                feature = features[i];
                feature.modified = Ext.apply(feature.modified || {}, {
                    attributes: Ext.apply(
                        (feature.modified && feature.modified.attributes) || {},
                        r.modified
                    )
                });
            }, this);

            
            var o = {
                action: action,
                records: records,
                callback: callback,
                scope: scope
            };

            var options = {
                callback: function(response) {
                    this.onProtocolCommit(response, o);
                },
                scope: this
            };

            Ext.applyIf(options, params);

            this.protocol.commit(features, options);
        }
        
    },
    
    
    /** private: method[onProtocolCommit]
     *  Callback for the protocol.commit method.  Called with an additional
     *  object containing references to arguments to the doRequest method.
     */
    onProtocolCommit: function(response, o) {        
        if(response.success()) {
            var features = response.reqFeatures;
            // deal with inserts, updates, and deletes
            var state, feature;
            var destroys = [];
            var insertIds = response.insertIds || [];
            var i, len, j = 0;
            for(i=0, len=features.length; i<len; ++i) {
                feature = features[i];
                state = feature.state;
                if(state) {
                    if(state == OpenLayers.State.DELETE) {
                        destroys.push(feature);
                    } else if(state == OpenLayers.State.INSERT) {
                        feature.fid = insertIds[j];
                        ++j;
                    } else if (feature.modified) {
                        feature.modified = {};
                    }
                    feature.state = null;
                }
            }
            
            for(i=0, len=destroys.length; i<len; ++i) {
                feature = destroys[i];
                feature.layer && feature.layer.destroyFeatures([feature]);
            }
            
            /**
             * TODO: Update the FeatureStore and FeatureReader to work with
             * callbacks from 3.0.
             * 
             * The callback here is the result of store.createCallback.  The
             * signature should be what is expected by the anonymous function
             * created in store.createCallback: (data, response, success).  The
             * callback is a wrapped version of store.onCreateRecords etc.
             *
             * The onCreateRecords method calls reader.realize, which expects a
             * primary key in the data.  Though it *feels* like the job of the
             * reader, we need to create valid record data here (eventually to
             * be passed to reader.realize).  The reader.realize method calls
             * reader.extractValues - which seems like a nice place to grab the
             * fids from the features.  However, we need the fid in the data
             * object *before* extractValues is called.  So, we create a basic
             * data object with just the id (mapping determined by
             * reader.meta.idProperty or, for Ext > 3.0, reader.getId) and the
             * state property, which is always reset to null after a commit.
             *
             * After the reader.realize method determines that the data is valid
             * (determined by reader.isValid(data)), then extractValues gets
             * called - where it will create values objects (to be set as
             * record.data) from data.features.
             *
             * An important thing to note here is that though we may have "batch"
             * set to true, the store.save sequence issues one request per action.
             * So, we should *never* be here with a mix of features (deleted,
             * updated, created).
             *
             * Bottom line (based on my current understanding): we need to
             * implement extractValues for the FeatureReader.
             */
            len = features.length;
            var data = new Array(len);
            var f;
            for (i=0; i<len; ++i) {
                f = features[i];
                // TODO - check if setting the state to null here is appropriate,
                // or if feature state handling should rather be done in
                // GeoExt.data.FeatureStore
                data[i] = {id: f.id, feature: f, state: null};
                var fields = o.records[i].fields;
                for (var a in f.attributes) {
                    if (fields.containsKey(a)) {
                        data[i][a] = f.attributes[a];
                    }
                }
            }

            o.callback.call(o.scope, data, response.priv, true);
        } else {
            // TODO: determine from response if exception was "response" or "remote"
            var request = response.priv;
            if (request.status >= 200 && request.status < 300) {
                // service exception with 200
                this.fireEvent("exception", this, "remote", o.action, o, response.error, o.records);
            } else {
                // non 200 status
                this.fireEvent("exception", this, "response", o.action, o, request);
            }
            o.callback.call(o.scope, [], request, false);
        }
        
    }

});

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp.menu
 *  class = LayerMenu
 *  base_link = `Ext.menu.Menu <http://extjs.com/deploy/dev/docs/?class=Ext.menu.Menu>`_
 */
Ext.namespace("gxp.menu");

/** api: constructor
 *  .. class:: LayerMenu(config)
 *
 *    A menu to control layer visibility.
 */   
gxp.menu.LayerMenu = Ext.extend(Ext.menu.Menu, {
    
    /** api: config[layerText]
     *  ``String``
     *  Text for added layer (i18n).
     */
    layerText: "Layer",
    
    /** api: config[layers]
     *  ``GeoExt.data.LayerStore``
     *  The store containing layer records to be viewed in this menu.
     */
    layers: null,
    
    /** private: method[initComponent]
     *  Private method called to initialize the component.
     */
    initComponent: function() {
        gxp.menu.LayerMenu.superclass.initComponent.apply(this, arguments);
        this.layers.on("add", this.onLayerAdd, this);
        this.onLayerAdd();
    },

    /** private: method[onRender]
     *  Private method called during the render sequence.
     */
    onRender : function(ct, position) {
        gxp.menu.LayerMenu.superclass.onRender.apply(this, arguments);
    },

    /** private: method[beforeDestroy]
     *  Private method called during the destroy sequence.
     */
    beforeDestroy: function() {
        if (this.layers && this.layers.on) {
            this.layers.un("add", this.onLayerAdd, this);
        }
        delete this.layers;
        gxp.menu.LayerMenu.superclass.beforeDestroy.apply(this, arguments);
    },
    
    /** private: method[onLayerAdd]
     *  Listener called when records are added to the layer store.
     */
    onLayerAdd: function() {
        this.removeAll();
        // this.getEl().addClass("gxp-layer-menu");
        // this.getEl().applyStyles({
        //     width: '',
        //     height: ''
        // });
        this.add(
            {
                iconCls: "gxp-layer-visibility",
                text: this.layerText,
                canActivate: false
            },
            "-"
        );
        this.layers.each(function(record) {
            var layer = record.getLayer();
            if(layer.displayInLayerSwitcher) {
                var item = new Ext.menu.CheckItem({
                    text: record.get("title"),
                    checked: record.getLayer().getVisibility(),
                    group: record.get("group"),
                    listeners: {
                        checkchange: function(item, checked) {
                            record.getLayer().setVisibility(checked);
                        }
                    }
                });
                if (this.items.getCount() > 2) {
                    this.insert(2, item);
                } else {
                    this.add(item);
                }
            }
        }, this);
        
    }
    
});

Ext.reg('gxp_layermenu', gxp.menu.LayerMenu);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

Ext.namespace("gxp");

/** api: (define)
 *  module = gxp
 *  class = CrumbPanel
 *  base_link = `Ext.TabPanel <http://extjs.com/deploy/dev/docs/?class=Ext.TabPanel>`_
 */

/** api: constructor
 *  .. class:: CrumbPanel(config)
 *
 *    Panel that accommodates modal dialogs and displays their hierarchy as
 *    crumbs in tabs, from left to right. Clicking on a crumb left of the
 *    rightmost one will close all dialogs that are hosted in tabs on its
 *    right.
 *
 *    If a component has a ``shortTitle`` configured, it will be used instead
 *    of the ``title`` in the crumb path.
 *
 *    Components intended to be reused after being removed from this panel need
 *    the closeAction option set to "hide", like an ``Ext.Window``. 
 */   
gxp.CrumbPanel = Ext.extend(Ext.TabPanel, {
    
    /** private: property[widths]
     *  {Object} widths of the panel's items, keyed by item id, so they can be
     *  restored after closing an item that required a wider container. 
     */
    widths: null,
    
    enableTabScroll: true,
    
    /** private: method[initComponent]
     */
    initComponent: function() {
        gxp.CrumbPanel.superclass.initComponent.apply(this, arguments);
        this.widths = {};
    },
    
    /** private: method[onBeforeAdd]
     *  :arg cmp: ``Ext.Component``
     */
    onBeforeAdd: function(cmp) {
        gxp.CrumbPanel.superclass.onBeforeAdd.apply(this, arguments);
        if (cmp.shortTitle) {
            cmp.title = cmp.shortTitle;
        }
    },
    
    /** private: method[onAdd]
     *  :arg cmp: ``Ext.Component``
     */
    onAdd: function(cmp) {
        gxp.CrumbPanel.superclass.onAdd.apply(this, arguments);
        this.setActiveTab(this.items.getCount() - 1);
        cmp.on("hide", this.onCmpHide, this);
        //TODO investigate why hidden components are displayed again when
        // another crumb is activated - this just works around the issue
        cmp.getEl().dom.style.display = "";
    },
    
    /** private: method[onRemove]
     *  :arg cmp: ``Ext.Component``
     */
    onRemove: function(cmp) {
        gxp.CrumbPanel.superclass.onRemove.apply(this, arguments);
        cmp.un("hide", this.onCmpHide, this);
        var previousWidth = this.widths[this.get(this.items.getCount()-1).id];
        if (previousWidth && previousWidth < this.getWidth()) {
            this.setWidth(previousWidth);
            if (this.ownerCt) {
                this.ownerCt.syncSize();
            }
        }
        //TODO investigate why hidden components are displayed again when
        // another crumb is activated - this just works around the issue
        cmp.getEl().dom.style.display = "none";
        this.activeTab.doLayout();
    },
    
    /** private: method[onRender]
     *  :arg cmp: ``Ext.Component``
     */
    onRender: function(cmp) {
        if (!this.initialConfig.itemTpl) {
            this.itemTpl = new Ext.Template(
                 '<li class="{cls} gxp-crumb" id="{id}"><div class="gxp-crumb-separator">\u00BB</div>',
                 '<a class="x-tab-right" href="#"><em class="x-tab-left">',
                 '<span class="x-tab-strip-inner"><span class="x-tab-strip-text {iconCls}">{text}</span></span>',
                 '</em></a></li>'
            );
        }
        gxp.CrumbPanel.superclass.onRender.apply(this, arguments);
        this.getEl().down("div").addClass("gxp-crumbpanel-header");
    },
    
    /** private: method[onCmpHide]
     *  :arg cmp: ``Ext.Component`` The component that was hidden.
     *
     *  Listener for the "hide" event of components that were added to the
     *  CrumbPanel.
     */
    onCmpHide: function(cmp) {
        var lastIndex = this.items.getCount() - 1;
        if (this.items.indexOf(cmp) === lastIndex) {
            this.setActiveTab(this.get(--lastIndex));
        }
    },
    
    /** private: method[setActiveTab]
     *  :arg item: ``Number|Ext.Component``
     */
    setActiveTab: function(item) {
        var index;
        if (Ext.isNumber(item)) {
            index = item;
            item = this.get(index);
        } else {
            index = this.items.indexOf(item);
        }
        if (~index) {
            var cmp, i;
            for (i=this.items.getCount()-1; i>index; --i) {
                cmp = this.get(i);
                // remove, but don't destroy if component was configured with
                // {closeAction: "hide"}
                this.remove(cmp, cmp.closeAction !== "hide");
            }
        }
        var width = item.initialConfig.minWidth || item.initialConfig.width,
            previousWidth = this.getWidth();
        if (width > previousWidth) {
            this.widths[this.get(index - 1).id] = previousWidth;
            this.setWidth(width);
            if (this.ownerCt) {
                this.ownerCt.syncSize();
            }
        }
        gxp.CrumbPanel.superclass.setActiveTab.apply(this, arguments);
    }

});

/** api: xtype = gxp_crumbpanel */
Ext.reg('gxp_crumbpanel', gxp.CrumbPanel);
/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires util.js
 */

Ext.namespace("gxp");

/** api: (define)
 *  module = gxp
 *  class = EmbedMapDialog
 *  base_link = `Ext.Container <http://extjs.com/deploy/dev/docs/?class=Ext.Container>`_
 */

/** api: example
 *  Show a :class:`gxp.EmbedMapDialog` in a window, using "viewer.html" in the
 *  current path as url:
 * 
 *  .. code-block:: javascript
 *
 *      new Ext.Window({
 *           title: "Export Map",
 *           layout: "fit",
 *           width: 380,
 *           autoHeight: true,
 *           items: [{
 *               xtype: "gxp_embedmapdialog",
 *               url: "viewer.html" 
 *           }]
 *       }).show();
 */
 
/** api: constructor
 *  .. class:: EmbedMapDialog(config)
 *   
 *  A dialog for configuring a map iframe to embed on external web pages.
 */
gxp.EmbedMapDialog = Ext.extend(Ext.Container, {
    
    /** api: config[url]
     *  ``String`` the url to use as the iframe's src of the embed snippet. Can
     *  be a url relative to the current href and will be converted to an
     *  absolute one.
     */
    url: null,

    /** api: property[url]
     *  ``String`` the url to use as the iframe's src of the embed snippet. Can
     *  be a url relative to the current href and will be converted to an
     *  absolute one.
     */
    url: null,

    /* begin i18n */
    /** api: config[publishMessage] ``String`` i18n */
    publishMessage: "Your map is ready to be published to the web! Simply copy the following HTML to embed the map in your website:",
    /** api: config[heightLabel] ``String`` i18n */
    heightLabel: 'Height',
    /** api: config[widthLabel] ``String`` i18n */
    widthLabel: 'Width',
    /** api: config[mapSizeLabel] ``String`` i18n */
    mapSizeLabel: 'Map Size',
    /** api: config[miniSizeLabel] ``String`` i18n */
    miniSizeLabel: 'Mini',
    /** api: config[smallSizeLabel] ``String`` i18n */
    smallSizeLabel: 'Small',
    /** api: config[premiumSizeLabel] ``String`` i18n */
    premiumSizeLabel: 'Premium',
    /** api: config[largeSizeLabel] ``String`` i18n */
    largeSizeLabel: 'Large',
    /* end i18n */
    
    /** private: property[snippetArea]
     */
    snippetArea: null,
    
    /** private: property[heightField]
     */
    heightField: null,
    
    /** private: property[widthField]
     */
    widthField: null,
    
    /** private: method[initComponent]
     */
    initComponent: function() {
        Ext.apply(this, this.getConfig());
        gxp.EmbedMapDialog.superclass.initComponent.call(this);
    },

    /** api: method[getIframeHTML]
     *  :returns: ``String`` the HTML needed to create the iframe
     *
     *  Get the HTML needed to create the iframe.
     */
    getIframeHTML: function() {
        return this.snippetArea.getValue();
    },
    
    /** private: method[updateSnippet]
     */
    updateSnippet: function() {
        this.snippetArea.setValue(
            '<iframe style="border: none;" height="' + this.heightField.getValue() +
            '" width="' + this.widthField.getValue() +'" src="' + 
            gxp.util.getAbsoluteUrl(this.url) + '"></iframe>');
        if (this.snippetArea.isVisible() === true) {
            this.snippetArea.focus(true, 100);
        }
    },
    
    /** private: method[getConfig]
     */
    getConfig: function() {
        this.snippetArea = new Ext.form.TextArea({
            height: 70,
            selectOnFocus: true,
            readOnly: true
        });
        
        var numFieldListeners = {
            "change": this.updateSnippet,
            "specialkey": function(f, e) {
                e.getKey() == e.ENTER && this.updateSnippet();
            },
            scope: this
        };

        this.heightField = new Ext.form.NumberField({
            width: 50,
            value: 400,
            listeners: numFieldListeners
        });
        this.widthField = new Ext.form.NumberField({
            width: 50,
            value: 600,
            listeners: numFieldListeners
        });        

        var adjustments = new Ext.Container({
            layout: "column",
            defaults: {
                border: false,
                xtype: "box"
            },
            items: [
                {autoEl: {cls: "gxp-field-label", html: this.mapSizeLabel}},
                new Ext.form.ComboBox({
                    editable: false,
                    width: 75,
                    store: new Ext.data.SimpleStore({
                        fields: ["name", "height", "width"],
                        data: [
                            [this.miniSizeLabel, 100, 100],
                            [this.smallSizeLabel, 200, 300],
                            [this.largeSizeLabel, 400, 600],
                            [this.premiumSizeLabel, 600, 800]
                        ]
                    }),
                    triggerAction: 'all',
                    displayField: 'name',
                    value: this.largeSizeLabel,
                    mode: 'local',
                    listeners: {
                        "select": function(combo, record, index) {
                            this.widthField.setValue(record.get("width"));
                            this.heightField.setValue(record.get("height"));
                            this.updateSnippet();
                        },
                        scope: this
                    }
                }),
                {autoEl: {cls: "gxp-field-label", html: this.heightLabel}},
                this.heightField,
                {autoEl: {cls: "gxp-field-label", html: this.widthLabel}},
                this.widthField
            ]
        });

        return {
            border: false,
            defaults: {
                border: false,
                cls: "gxp-export-section",
                xtype: "container",
                layout: "fit"
            },
            items: [{
                items: [adjustments]
            }, {
                xtype: "box",
                autoEl: {
                    tag: "p",
                    html: this.publishMessage
                }
            }, {
                items: [this.snippetArea]
            }],
            listeners: {
                "afterrender": this.updateSnippet,
                scope: this
            }
        };
    }
});

/** api: xtype = gxp_embedmapdialog */
Ext.reg('gxp_embedmapdialog', gxp.EmbedMapDialog);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/FeatureEditorGrid.js
 * @requires GeoExt/widgets/Popup.js
 * @requires OpenLayers/Control/ModifyFeature.js
 */

/** api: (define)
 *  module = gxp
 *  class = FeatureEditPopup
 *  extends = GeoExt.Popup
 */

/** api: constructor
 *  .. class:: FeatureEditPopup(config)
 *
 *      Create a new popup which displays the attributes of a feature and
 *      makes the feature editable,
 *      using an ``OpenLayers.Control.ModifyFeature``.
 */
Ext.namespace("gxp");
gxp.FeatureEditPopup = Ext.extend(GeoExt.Popup, {
    
    /** i18n **/
    closeMsgTitle: 'Save Changes?',
    closeMsg: 'This feature has unsaved changes. Would you like to save your changes?',
    deleteMsgTitle: 'Delete Feature?',
    deleteMsg: 'Are you sure you want to delete this feature?',
    editButtonText: 'Edit',
    editButtonTooltip: 'Make this feature editable',
    deleteButtonText: 'Delete',
    deleteButtonTooltip: 'Delete this feature',
    cancelButtonText: 'Cancel',
    cancelButtonTooltip: 'Stop editing, discard changes',
    saveButtonText: 'Save',
    saveButtonTooltip: 'Save changes',
    
    /** private config overrides **/
    layout: "fit",
    
    /** api: config[feature]
     *  ``OpenLayers.Feature.Vector``|``GeoExt.data.FeatureRecord`` The feature
     *  to edit and display.
     */
    
    /** api: config[vertexRenderIntent]
     *  ``String`` renderIntent for feature vertices when modifying. Undefined
     *  by default.
     */
    
    /** api: property[feature]
     *  ``OpenLayers.Feature.Vector`` The feature being edited/displayed.
     */
    feature: null,
    
    /** api: config[schema]
     *  ``GeoExt.data.AttributeStore`` Optional. If provided, available
     *  feature attributes will be determined from the schema instead of using
     *  the attributes that the feature has currently set.
     */
    schema: null,
    
    /** api: config[fields]
     *  ``Array``
     *  List of field config names corresponding to feature attributes.  If
     *  not provided, fields will be derived from attributes. If provided,
     *  the field order from this list will be used, and fields missing in the
     *  list will be excluded.
     */

    /** api: config[excludeFields]
     *  ``Array`` Optional list of field names (case sensitive) that are to be
     *  excluded from the editor plugin.
     */
    
    /** private: property[excludeFields]
     */
    
    /** api: config[propertyNames]
     *  ``Object`` Property name/display name pairs. If specified, the display
     *  name will be shown in the name column instead of the property name.
     */

    /** api: config[readOnly]
     *  ``Boolean`` Set to true to disable editing. Default is false.
     */
    readOnly: false,
    
    /** api: config[allowDelete]
     *  ``Boolean`` Set to true to provide a Delete button for deleting the
     *  feature. Default is false.
     */
    allowDelete: false,
    
    /** api: config[editing]
     *  ``Boolean`` Set to true to open the popup in editing mode.
     *  Default is false.
     */
    
    /** api: config[dateFormat]
     *  ``String`` Date format. Default is the value of
     *  ``Ext.form.DateField.prototype.format``.
     */
        
    /** api: config[timeFormat]
     *  ``String`` Time format. Default is the value of
     *  ``Ext.form.TimeField.prototype.format``.
     */

    /** private: property[editing]
     *  ``Boolean`` If we are in editing mode, this will be true.
     */
    editing: false,

    /** api: editorPluginConfig
     *  ``Object`` The config for the plugin to use as the editor, its ptype
     *  property can be one of "gxp_editorgrid" (default) or "gxp_editorform" 
     *  for form-based editing.
     */
    editorPluginConfig: {
        ptype: "gxp_editorgrid"
    },

    /** private: property[modifyControl]
     *  ``OpenLayers.Control.ModifyFeature`` If in editing mode, we will have
     *  this control for editing the geometry.
     */
    modifyControl: null,
    
    /** private: property[geometry]
     *  ``OpenLayers.Geometry`` The original geometry of the feature we are
     *  editing.
     */
    geometry: null,
    
    /** private: property[attributes]
     *  ``Object`` The original attributes of the feature we are editing.
     */
    attributes: null,
    
    /** private: property[cancelButton]
     *  ``Ext.Button``
     */
    cancelButton: null,
    
    /** private: property[saveButton]
     *  ``Ext.Button``
     */
    saveButton: null,
    
    /** private: property[editButton]
     *  ``Ext.Button``
     */
    editButton: null,
    
    /** private: property[deleteButton]
     *  ``Ext.Button``
     */
    deleteButton: null,
    
    /** private: method[initComponent]
     */
    initComponent: function() {
        this.addEvents(

            /** api: events[startedit]
             *  Fires when editing starts.
             *
             *  Listener arguments:
             *  * panel - :class:`gxp.FeatureEditPopup` This popup.
             */
            "startedit",

            /** api: events[stopedit]
             *  Fires when editing stops.
             *
             *  Listener arguments:
             *  * panel - :class:`gxp.FeatureEditPopup` This popup.
             */
            "stopedit",

            /** api: events[beforefeaturemodified]
             *  Fires before the feature associated with this popup has been
             *  modified (i.e. when the user clicks "Save" on the popup).
             *
             *  Listener arguments:
             *  * panel - :class:`gxp.FeatureEditPopup` This popup.
             *  * feature - ``OpenLayers.Feature`` The modified feature.
             */
            "beforefeaturemodified",

            /** api: events[featuremodified]
             *  Fires when the feature associated with this popup has been
             *  modified (i.e. when the user clicks "Save" on the popup) or
             *  deleted (i.e. when the user clicks "Delete" on the popup).
             *
             *  Listener arguments:
             *  * panel - :class:`gxp.FeatureEditPopup` This popup.
             *  * feature - ``OpenLayers.Feature`` The modified feature.
             */
            "featuremodified",
            
            /** api: events[canceledit]
             *  Fires when the user exits the editing mode by pressing the
             *  "Cancel" button or selecting "No" in the popup's close dialog.
             *  
             *  Listener arguments:
             *  * panel - :class:`gxp.FeatureEditPopup` This popup.
             *  * feature - ``OpenLayers.Feature`` The feature. Will be null
             *    if editing of a feature that was just inserted was cancelled.
             */
            "canceledit",
            
            /** api: events[cancelclose]
             *  Fires when the user answers "Cancel" to the dialog that
             *  appears when a popup with unsaved changes is closed.
             *  
             *  Listener arguments:
             *  * panel - :class:`gxp.FeatureEditPopup` This popup.
             */
            "cancelclose"
        );
        
        var feature = this.feature;
        if (feature instanceof GeoExt.data.FeatureRecord) {
            feature = this.feature = feature.getFeature();
        }
        if (!this.location) {
            this.location = feature;
        }
        
        this.anchored = !this.editing;
        
        if(!this.title && feature.fid) {
            this.title = feature.fid;
        }
        
        this.editButton = new Ext.Button({
            text: this.editButtonText,
            tooltip: this.editButtonTooltip,
            iconCls: "edit",
            handler: this.startEditing,
            scope: this
        });
        
        this.deleteButton = new Ext.Button({
            text: this.deleteButtonText,
            tooltip: this.deleteButtonTooltip,
            iconCls: "delete",
            hidden: !this.allowDelete,
            handler: this.deleteFeature,
            scope: this
        });
        
        this.cancelButton = new Ext.Button({
            text: this.cancelButtonText,
            tooltip: this.cancelButtonTooltip,
            iconCls: "cancel",
            hidden: true,
            handler: function() {
                this.stopEditing(false);
            },
            scope: this
        });
        
        this.saveButton = new Ext.Button({
            text: this.saveButtonText,
            tooltip: this.saveButtonTooltip,
            iconCls: "save",
            hidden: true,
            handler: function() {
                this.stopEditing(true);
            },
            scope: this
        });
        
        this.plugins = [Ext.apply({
            feature: feature,
            schema: this.schema,
            fields: this.fields,
            excludeFields: this.excludeFields,
            propertyNames: this.propertyNames,
            readOnly: this.readOnly
        }, this.editorPluginConfig)];

        this.bbar = new Ext.Toolbar({
            hidden: this.readOnly,
            items: [
                this.editButton,
                this.deleteButton,
                this.saveButton,
                this.cancelButton
            ]
        });
        
        gxp.FeatureEditPopup.superclass.initComponent.call(this);
        
        this.on({
            "show": function() {
                if(this.editing) {
                    this.editing = null;
                    this.startEditing();
                }
            },
            "beforeclose": function() {
                if(!this.editing) {
                    return;
                }
                if(this.feature.state === this.getDirtyState()) {
                    Ext.Msg.show({
                        title: this.closeMsgTitle,
                        msg: this.closeMsg,
                        buttons: Ext.Msg.YESNOCANCEL,
                        fn: function(button) {
                            if(button && button !== "cancel") {
                                this.stopEditing(button === "yes");
                                this.close();
                            } else {
                                this.fireEvent("cancelclose", this);
                            }
                        },
                        scope: this,
                        icon: Ext.MessageBox.QUESTION,
                        animEl: this.getEl()
                    });
                    return false;
                } else {
                    this.stopEditing(false);
                }
            },
            scope: this
        });
    },

    /** private: method[getDirtyState]
     *  Get the appropriate OpenLayers.State value to indicate a dirty feature.
     *  We don't cache this value because the popup may remain open through
     *  several state changes.
     */
    getDirtyState: function() {
        return this.feature.state === OpenLayers.State.INSERT ?
            this.feature.state : OpenLayers.State.UPDATE;
    },
    
    /** private: method[startEditing]
     */
    startEditing: function() {
        if(!this.editing) {
            this.fireEvent("startedit", this);
            this.editing = true;
            this.anc && this.unanchorPopup();

            this.editButton.hide();
            this.deleteButton.hide();
            this.saveButton.show();
            this.cancelButton.show();
            
            this.geometry = this.feature.geometry && this.feature.geometry.clone();
            this.attributes = Ext.apply({}, this.feature.attributes);

            this.modifyControl = new OpenLayers.Control.ModifyFeature(
                this.feature.layer,
                {standalone: true, vertexRenderIntent: this.vertexRenderIntent}
            );
            this.feature.layer.map.addControl(this.modifyControl);
            this.modifyControl.activate();
            if (this.feature.geometry) {
                this.modifyControl.selectFeature(this.feature);
            }
        }
    },
    
    /** private: method[stopEditing]
     *  :arg save: ``Boolean`` If set to true, changes will be saved and the
     *      ``featuremodified`` event will be fired.
     */
    stopEditing: function(save) {
        if(this.editing) {
            this.fireEvent("stopedit", this);
            //TODO remove the line below when
            // http://trac.openlayers.org/ticket/2210 is fixed.
            this.modifyControl.deactivate();
            this.modifyControl.destroy();
            
            var feature = this.feature;
            if (feature.state === this.getDirtyState()) {
                if (save === true) {
                    this.fireEvent("beforefeaturemodified", this, feature);
                    //TODO When http://trac.osgeo.org/openlayers/ticket/3131
                    // is resolved, remove the if clause below
                    if (this.schema) {
                        var attribute, rec;
                        for (var i in feature.attributes) {
                            rec = this.schema.getAt(this.schema.findExact("name", i));
                            attribute = feature.attributes[i];
                            if (attribute instanceof Date) {
                                var type = rec.get("type").split(":").pop();
                                feature.attributes[i] = attribute.format(
                                    type == "date" ? "Y-m-d" : "c"
                                );
                            }
                        }
                    }
                    this.fireEvent("featuremodified", this, feature);
                } else if(feature.state === OpenLayers.State.INSERT) {
                    this.editing = false;
                    feature.layer && feature.layer.destroyFeatures([feature]);
                    this.fireEvent("canceledit", this, null);
                    this.close();
                } else {
                    var layer = feature.layer;
                    layer.drawFeature(feature, {display: "none"});
                    feature.geometry = this.geometry;
                    feature.attributes = this.attributes;
                    this.setFeatureState(null);
                    layer.drawFeature(feature);
                    this.fireEvent("canceledit", this, feature);
                }
            }

            if (!this.isDestroyed) {
                this.cancelButton.hide();
                this.saveButton.hide();
                this.editButton.show();
                this.allowDelete && this.deleteButton.show();
            }
            
            this.editing = false;
        }
    },
    
    deleteFeature: function() {
        Ext.Msg.show({
            title: this.deleteMsgTitle,
            msg: this.deleteMsg,
            buttons: Ext.Msg.YESNO,
            fn: function(button) {
                if(button === "yes") {
                    this.setFeatureState(OpenLayers.State.DELETE);
                    this.fireEvent("featuremodified", this, this.feature);
                    this.close();
                }
            },
            scope: this,
            icon: Ext.MessageBox.QUESTION,
            animEl: this.getEl()
        });
    },
    
    /** private: method[setFeatureState]
     *  Set the state of this popup's feature and trigger a featuremodified
     *  event on the feature's layer.
     */
    setFeatureState: function(state) {
        this.feature.state = state;
        var layer = this.feature.layer;
        layer && layer.events.triggerEvent("featuremodified", {
            feature: this.feature
        });
    }
});

/** api: xtype = gxp_featureeditpopup */
Ext.reg('gxp_featureeditpopup', gxp.FeatureEditPopup);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @include widgets/form/FilterField.js
 */

/** api: (define)
 *  module = gxp
 *  class = FilterBuilder
 *  base_link = `Ext.Panel <http://extjs.com/deploy/dev/docs/?class=Ext.Panel>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: FilterBuilder(config)
 *   
 *      Create a panel for assembling a filter.
 */
gxp.FilterBuilder = Ext.extend(Ext.Container, {

    /** api: config[builderTypeNames]
     *  ``Array``
     *  A list of labels that correspond to builder type constants.
     *  These will be the option names available in the builder type combo.
     *  Default is ``["any", "all", "none", "not all"]``.
     */
    builderTypeNames: ["any", "all", "none", "not all"],
    
    /** api: config[allowedBuilderTypes]
     *  ``Array``
     *  List of builder type constants.  Default is
     *  ``[ANY_OF, ALL_OF, NONE_OF]``.
     */
    allowedBuilderTypes: null,
    
    /** api: config[allowBlank]
     *  ``Boolean`` Do we allow blank FilterFields? It is safe to say true
     *  here, but for compatibility reasons with old applications, the default
     *  is false.
     */
    allowBlank: false,
    
    /** api: config[caseInsensitiveMatch]
     *  ``Boolean``
     *  Should Comparison Filters for Strings do case insensitive matching?  Default is ``"false"``.
     */
    caseInsensitiveMatch: false,

    /** api: config[preComboText]
     *  ``String``
     *  String to display before filter type combo.  Default is ``"Match"``.
     */
    preComboText: "Match",

    /** api: config[postComboText]
     *  ``String``
     *  String to display after filter type combo.  Default is
     *  ``"of the following:"``.
     */
    postComboText: "of the following:",

    /** api: config[cls]
     *  ``String``
     *  The CSS class to be added to this panel's element (defaults to
     *  ``"gxp-filterbuilder"``).
     */
    cls: "gxp-filterbuilder",
    
    /** api: config[filter]
     *  ``OpenLayers.Filter``
     *  Filter to initialize the component with
     */

    /** private: property[builderType]
     */
    builderType: null,

    /** private: property[childFilterContainer]
     */
    childFilterContainer: null,
    
    /** private: property[customizeFilterOnInit]
     */
    customizeFilterOnInit: true,
    
    /** i18n */
    addConditionText: "add condition",
    addGroupText: "add group",
    removeConditionText: "remove condition",

    /** api: config[allowGroups]
     *  ``Boolean``
     *  Allow groups of conditions to be added.  Default is ``true``.
     *  If ``false``, only individual conditions (non-logical filters) can
     *  be added.
     */
    allowGroups: true,

    initComponent: function() {
        var defConfig = {
            defaultBuilderType: gxp.FilterBuilder.ANY_OF
        };
        Ext.applyIf(this, defConfig);
        
        if(this.customizeFilterOnInit) {
            this.filter = this.customizeFilter(this.filter);
        }
        
        this.builderType = this.getBuilderType();
        
        this.items = [{
            xtype: "container",
            layout: "form",
            ref: "form",
            defaults: {anchor: "100%"},
            hideLabels: true,
            items: [{
                xtype: "compositefield",
                style: "padding-left: 2px",
                items: [{
                    xtype: "label",
                    style: "padding-top: 0.3em",
                    text: this.preComboText
                }, this.createBuilderTypeCombo(), {
                    xtype: "label",
                    style: "padding-top: 0.3em",
                    text: this.postComboText
                }]
            }, this.createChildFiltersPanel(), {
                xtype: "toolbar",
                items: this.createToolBar()
            }]
        
        }];
        
        this.addEvents(
            /**
             * Event: change
             * Fires when the filter changes.
             *
             * Listener arguments:
             * builder - {gxp.FilterBuilder} This filter builder.  Call
             *     ``getFilter`` to get the updated filter.
             */
            "change"
        ); 

        gxp.FilterBuilder.superclass.initComponent.call(this);
    },

    /** private: method[createToolBar]
     */
    createToolBar: function() {
        var bar = [{
            text: this.addConditionText,
            iconCls: "add",
            handler: function() {
                this.addCondition();
            },
            scope: this
        }];
        if(this.allowGroups) {
            bar.push({
                text: this.addGroupText,
                iconCls: "add",
                handler: function() {
                    this.addCondition(true);
                },
                scope: this
            });
        }
        return bar;
    },
    
    /** api: method[getFilter]
     *  :return: ``OpenLayers.Filter``
     *  
     *  Returns a filter that fits the model in the Filter Encoding
     *  specification.  Use this method instead of directly accessing
     *  the ``filter`` property.  Return will be ``false`` if any child
     *  filter does not have a type, property, or value.
     */
    getFilter: function() {
        var filter;
        if(this.filter) {
            filter = this.filter.clone();
            if(filter instanceof OpenLayers.Filter.Logical) {
                filter = this.cleanFilter(filter);
            }
        }
        return filter;
    },
    
    /** private: method[cleanFilter]
     *  :arg filter: ``OpenLayers.Filter.Logical``
     *  :return: ``OpenLayers.Filter`` An equivalent filter to the input, where
     *      all binary logical filters have more than one child filter.  Returns
     *      false if a filter doesn't have non-null type, property, or value.
     *  
     *  Ensures that binary logical filters have more than one child.
     */
    cleanFilter: function(filter) {
        if(filter instanceof OpenLayers.Filter.Logical) {
            if(filter.type !== OpenLayers.Filter.Logical.NOT &&
               filter.filters.length === 1) {
                filter = this.cleanFilter(filter.filters[0]);
            } else {
                var child;
                for(var i=0, len=filter.filters.length; i<len; ++i) {
                    child = filter.filters[i];
                    if(child instanceof OpenLayers.Filter.Logical) {
                        child = this.cleanFilter(child);
                        if(child) {
                            filter.filters[i] = child;
                        } else {
                            filter = child;
                            break;
                        }
                    } else if(!child || child.type === null ||
                              child.property === null || child[filter.type === OpenLayers.Filter.Comparison.BETWEEN ? "lowerBoundary" : "value"] === null) {
                        filter = false;
                        break;
                    }
                }
            }
        } else {
            if(!filter || filter.type === null || filter.property === null ||
               filter[filter.type === OpenLayers.Filter.Comparison.BETWEEN ? "lowerBoundary" : "value"] === null) {
                filter = false;
            }
        }
        return filter;
    },
    
    /** private: method[customizeFilter]
     *  :arg filter: ``OpenLayers.Filter``  This filter will not
     *      be modified.  Register for events to receive an updated filter, or
     *      call ``getFilter``.
     *  :return: ``OpenLayers.Filter``  A filter that fits the model used by
     *      this builder.
     *  
     *  Create a filter that fits the model for this filter builder.  This filter
     *  will not necessarily meet the Filter Encoding specification.  In
     *  particular, filters representing binary logical operators may not
     *  have two child filters.  Use the <getFilter> method to return a
     *  filter that meets the encoding spec.
     */
    customizeFilter: function(filter) {
        if(!filter) {
            filter = this.wrapFilter(this.createDefaultFilter());
        } else {
            filter = this.cleanFilter(filter);
            var child, i, len;
            switch(filter.type) {
                case OpenLayers.Filter.Logical.AND:
                case OpenLayers.Filter.Logical.OR:
                    if(!filter.filters || filter.filters.length === 0) {
                        // give the filter children if it has none
                        filter.filters = [this.createDefaultFilter()];
                    } else {
                        for(i=0, len=filter.filters.length; i<len; ++i) {
                            child = filter.filters[i];
                            if(child instanceof OpenLayers.Filter.Logical) {
                                filter.filters[i] = this.customizeFilter(child);
                            }
                        }
                    }
                    // wrap in a logical OR
                    filter = new OpenLayers.Filter.Logical({
                        type: OpenLayers.Filter.Logical.OR,
                        filters: [filter]
                    });
                    break;
                case OpenLayers.Filter.Logical.NOT:
                    if(!filter.filters || filter.filters.length === 0) {
                        filter.filters = [
                            new OpenLayers.Filter.Logical({
                                type: OpenLayers.Filter.Logical.OR,
                                filters: [this.createDefaultFilter()]
                            })
                        ];
                    } else {
                        // NOT filters should have one child only
                        child = filter.filters[0];
                        if(child instanceof OpenLayers.Filter.Logical) {
                            if(child.type !== OpenLayers.Filter.Logical.NOT) {
                                // check children of AND and OR
                                var grandchild;
                                for(i=0, len=child.filters.length; i<len; ++i) {
                                    grandchild = child.filters[i];
                                    if(grandchild instanceof OpenLayers.Filter.Logical) {
                                        child.filters[i] = this.customizeFilter(grandchild);
                                    }
                                }
                            } else {
                                // silly double negative
                                if(child.filters && child.filters.length > 0) {
                                    filter = this.customizeFilter(child.filters[0]);
                                } else {
                                    filter = this.wrapFilter(this.createDefaultFilter());
                                }
                            }
                        } else {
                            // non-logical child of NOT should be wrapped
                            var type;
                            if(this.defaultBuilderType === gxp.FilterBuilder.NOT_ALL_OF) {
                                type = OpenLayers.Filter.Logical.AND;
                            } else {
                                type = OpenLayers.Filter.Logical.OR;
                            }
                            filter.filters = [
                                new OpenLayers.Filter.Logical({
                                    type: type,
                                    filters: [child]
                                })
                            ];
                        }
                    }
                    break;
                default:
                    // non-logical filters get wrapped
                    filter = this.wrapFilter(filter);
                    break;
            }
        }
        return filter;
    },

    createDefaultFilter: function() {
        return new OpenLayers.Filter.Comparison({
                            matchCase: !this.caseInsensitiveMatch});
    },
    
    /** private: method[wrapFilter]
     *  :arg filter: ``OpenLayers.Filter`` A non-logical filter.
     *  :return: ``OpenLayers.Filter`` A wrapped version of the input filter.
     *  
     *  Given a non-logical filter, this creates parent filters depending on
     *  the ``defaultBuilderType``.
     */
    wrapFilter: function(filter) {
        var type;
        if(this.defaultBuilderType === gxp.FilterBuilder.ALL_OF) {
            type = OpenLayers.Filter.Logical.AND;
        } else {
            type = OpenLayers.Filter.Logical.OR;
        }
        return new OpenLayers.Filter.Logical({
            type: OpenLayers.Filter.Logical.OR,
            filters: [
                new OpenLayers.Filter.Logical({
                    type: type, filters: [filter]
                })
            ]
        });
    },
    
    /** private: method[addCondition]
     *  Add a new condition or group of conditions to the builder.  This
     *  modifies the filter and adds a panel representing the new condition
     *  or group of conditions.
     */
    addCondition: function(group) {
        var filter, type;
        if(group) {
            type = "gxp_filterbuilder";
            filter = this.wrapFilter(this.createDefaultFilter());
        } else {
            type = "gxp_filterfield";
            filter = this.createDefaultFilter();
        }
        var newChild = this.newRow({
            xtype: type,
            filter: filter,
            columnWidth: 1,
            attributes: this.attributes,
            allowBlank: group ? undefined : this.allowBlank,
            customizeFilterOnInit: group && false,
            caseInsensitiveMatch: this.caseInsensitiveMatch,
            listeners: {
                change: function() {
                    this.fireEvent("change", this);
                },
                scope: this
            }
        });
        this.childFilterContainer.add(newChild);
        this.filter.filters[0].filters.push(filter);
        this.childFilterContainer.doLayout();
    },
    
    /** private: method[removeCondition]
     *  Remove a condition or group of conditions from the builder.  This
     *  modifies the filter and removes the panel representing the condition
     *  or group of conditions.
     */
    removeCondition: function(item, filter) {
        var parent = this.filter.filters[0].filters;
        if(parent.length > 0) {
            parent.remove(filter);
            this.childFilterContainer.remove(item, true);
        }
        if(parent.length === 0) {
            this.addCondition();
        }
        this.fireEvent("change", this);
    },
    
    createBuilderTypeCombo: function() {
        var types = this.allowedBuilderTypes || [
            gxp.FilterBuilder.ANY_OF, gxp.FilterBuilder.ALL_OF,
            gxp.FilterBuilder.NONE_OF
        ];
        var numTypes = types.length;
        var data = new Array(numTypes);
        var type;
        for(var i=0; i<numTypes; ++i) {
            type = types[i];
            data[i] = [type, this.builderTypeNames[type]];
        }
        return {
            xtype: "combo",
            store: new Ext.data.SimpleStore({
                data: data,
                fields: ["value", "name"]
            }),
            value: this.builderType,
            ref: "../../builderTypeCombo",
            displayField: "name",
            valueField: "value",
            triggerAction: "all",
            mode: "local",
            listeners: {
                select: function(combo, record) {
                    this.changeBuilderType(record.get("value"));
                    this.fireEvent("change", this);
                },
                scope: this
            },
            width: 60 // TODO: move to css
        };
    },
    
    /** private: method[changeBuilderType]
     *  :arg type: ``Integer`` One of the filter type constants.
     *  
     *  Alter the filter types when the filter type combo changes.
     */
    changeBuilderType: function(type) {
        if(type !== this.builderType) {
            this.builderType = type;
            var child = this.filter.filters[0];
            switch(type) {
                case gxp.FilterBuilder.ANY_OF:
                    this.filter.type = OpenLayers.Filter.Logical.OR;
                    child.type = OpenLayers.Filter.Logical.OR;
                    break;
                case gxp.FilterBuilder.ALL_OF:
                    this.filter.type = OpenLayers.Filter.Logical.OR;
                    child.type = OpenLayers.Filter.Logical.AND;
                    break;
                case gxp.FilterBuilder.NONE_OF:
                    this.filter.type = OpenLayers.Filter.Logical.NOT;
                    child.type = OpenLayers.Filter.Logical.OR;
                    break;
                case gxp.FilterBuilder.NOT_ALL_OF:
                    this.filter.type = OpenLayers.Filter.Logical.NOT;
                    child.type = OpenLayers.Filter.Logical.AND;
                    break;
            }
        }
    },

    /** private: method[createChildFiltersPanel]
     *  :return: ``Ext.Container``
     *  
     *  Create the panel that holds all conditions and condition groups.  Since
     *  this is called after this filter has been customized, we always
     *  have a logical filter with one child filter - that child is also
     *  a logical filter.
     */
    createChildFiltersPanel: function() {
        this.childFilterContainer = new Ext.Container();
        var grandchildren = this.filter.filters[0].filters;
        var grandchild;
        for(var i=0, len=grandchildren.length; i<len; ++i) {
            grandchild = grandchildren[i];
            var fieldCfg = {
                xtype: "gxp_filterfield",
                allowBlank: this.allowBlank,
                columnWidth: 1,
                filter: grandchild,
                attributes: this.attributes,
                listeners: {
                    change: function() {
                        this.fireEvent("change", this);
                    },
                    scope: this
                }
            };
            var containerCfg = Ext.applyIf(
                grandchild instanceof OpenLayers.Filter.Logical ?
                    {
                        xtype: "gxp_filterbuilder"
                    } : {
                        xtype: "container",
                        layout: "form",
                        hideLabels: true,
                        items: fieldCfg
                    }, fieldCfg);
                
            this.childFilterContainer.add(this.newRow(containerCfg));
        }
        return this.childFilterContainer;
    },

    /** private: method[newRow]
     *  :return: ``Ext.Container`` A container that serves as a row in a child
     *  filters panel.
     *  
     *  Generate a "row" for the child filters panel.  This couples another
     *  filter panel or filter builder with a component that allows for
     *  condition removal.
     */
    newRow: function(filterContainer) {
        var ct = new Ext.Container({
            layout: "column",
            items: [{
                xtype: "container",
                width: 28,
                height: 26,
                style: "padding-left: 2px",
                items: {
                    xtype: "button",
                    tooltip: this.removeConditionText,
                    iconCls: "delete",
                    handler: function(btn){
                        this.removeCondition(ct, filterContainer.filter);
                    },
                    scope: this
                }
            }, filterContainer]
        });
        return ct;
    },

    /** private: method[getBuilderType]
     *
     *  :return: ``Integer``  One of the builder type constants.
     *  Determine the builder type based on this filter.
     */
    getBuilderType: function() {
        var type = this.defaultBuilderType;
        if(this.filter) {
            var child = this.filter.filters[0];
            if(this.filter.type === OpenLayers.Filter.Logical.NOT) {
                switch(child.type) {
                    case OpenLayers.Filter.Logical.OR:
                        type = gxp.FilterBuilder.NONE_OF;
                        break;
                    case OpenLayers.Filter.Logical.AND:
                        type = gxp.FilterBuilder.NOT_ALL_OF;
                        break;
                }
            } else {
                switch(child.type) {
                    case OpenLayers.Filter.Logical.OR:
                        type = gxp.FilterBuilder.ANY_OF;
                        break;
                    case OpenLayers.Filter.Logical.AND:
                        type = gxp.FilterBuilder.ALL_OF;
                        break;
                }
            }
        }
        return type;
    },

    /** api: method[setFilter]
     *
     *  :param filter: ``OpenLayers.Filter``
     *
     *  Change the filter associated with this instance.
     */
    setFilter: function(filter) {
        this.filter = this.customizeFilter(filter);
        this.changeBuilderType(this.getBuilderType());
        this.builderTypeCombo.setValue(this.builderType);
        this.form.remove(this.childFilterContainer);
        this.form.insert(1, this.createChildFiltersPanel());
        this.form.doLayout();
        this.fireEvent("change", this);
    }

});

/**
 * Builder Types
 */
gxp.FilterBuilder.ANY_OF = 0;
gxp.FilterBuilder.ALL_OF = 1;
gxp.FilterBuilder.NONE_OF = 2;
gxp.FilterBuilder.NOT_ALL_OF = 3;

/** api: xtype = gxp_filterbuilder */
Ext.reg('gxp_filterbuilder', gxp.FilterBuilder); 

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @include widgets/FilterBuilder.js
 * @include data/WFSFeatureStore.js
 */

/** api: (define)
 *  module = gxp
 *  class = QueryPanel
 *  base_link = `Ext.Panel <http://extjs.com/deploy/dev/docs/?class=Ext.Panel>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: QueryPanel(config)
 *   
 *      Create a panel for assembling and issuing feature requests.
 */
gxp.QueryPanel = Ext.extend(Ext.Panel, {

    /** api: config[layerStore]
     *  ``Ext.data.Store``
     *  A store with records representing each WFS layer to be queried. Records
     *  must have ``title``, ``name`` (feature type), ``namespace`` (namespace
     *  URI), ``url`` (wfs url), and ``schema`` (schema url) fields.
     */
    
    /** api: config[map]
     *  ``OpenLayers.MapPanel`` The map to take the spatial extent for the
     *  spatialQuery from. Required.
     */

    /** api: config[maxFeatures]
     *  ``Number``
     *  Optional limit for number of features requested in a query.  No limit
     *  set by default.
     */
    
    /** api: config[layout]
     *  ``String``
     *  Defaults to "form."
     */
    layout: "form",
    
    /** api: config[spatialQuery]
     *  ``Boolean``
     *  Initial state of "query by location" checkbox.  Default is true.
     */
    
    /** api: property[spatialQuery]
     *  ``Boolean``
     *  Query by extent.
     */
    spatialQuery: true,
    
    /** api: config[attributeQuery]
     *  ``Boolean``
     *  Initial state of "query by attribute" checkbox.  Default is false.
     */
    
    /** api: property[attributeQuery]
     *  ``Boolean``
     *  Query by attributes.
     */
    attributeQuery: true,

    /** api: config[caseInsensitiveMatch]
     *  ``Boolean``
     *  Should Comparison Filters for Strings do case insensitive matching?  Default is ``"false"``.
     */
    caseInsensitiveMatch: false,

    /** api: config[likeSubstring]
     *  ``Boolean``
     *  Allow substrings to be entered with LIKE comparisons? These strings will be wrapped in wildcards.
     *  Default is ``"false"``.
     */
    likeSubstring: false,

    /** api: config[wildCardString]
     *  ``String``
     *  String to be pre- and postfixed for substrings in LIKE Comparison Filters.
     */
    wildCardString: '.*',

    /** private: property[selectedLayer]
     *  ``Ext.data.Record``
     *  The currently selected record in the layers combo.
     */
    selectedLayer: null,
    
    /** private: property[featureStore]
     *  ``GeoExt.data.FeatureStore``
     *  After a query has been issued, this will be a store with records based
     *  on the return from the query.
     */
    featureStore: null,
    
    /** api: property[attributeStore]
     *  ``GeoExt.data.AttributeStore``
     *  The attributes associated with the currently selected layer.
     */
    attributeStore: null,
    
    /** api: property[geometryType]
     *  ``String`` (Multi)?(Point|Line|Polygon|Curve|Surface|Geometry) The
     *  geometry type of features of the selected layer. If the layer has
     *  multiple geometry fields, the type of the first geometry field will
     *  be returned.
     */
    geometryType: null,

    /** private: property[geometryName]
     *  ``String``
     *  Name of the first geometry attribute found when the attributes store
     *  loads.
     */
    geometryName: null,

    /** i18n */
    queryByLocationText: "Query by location",
    currentTextText: "Current extent",
    queryByAttributesText: "Query by attributes",
    layerText: "Layer",

    /** private: method[initComponent]
     */
    initComponent: function() {
        
        this.addEvents(
            
            /** api: events[ready]
             *  Fires when the panel is ready to issue queries (after the
             *  internal attribute store has loaded).
             *
             *  Listener arguments:
             *  * panel - :class:`gxp.QueryPanel` This query panel.
             *  * store - ``GeoExt.data.FeatureStore`` The feature store.
             */
            "ready",

            /** api: events[beforelayerchange]
             *  Fires before a new layer is selected.  Return false to stop the
             *  layer selection from changing.
             *
             *  Listener arguments:
             *  * panel - :class:`gxp.QueryPanel` This query panel.
             *  * record - ``Ext.data.Record`` Record representing the newly
             *      selected layer.
             */
            "beforelayerchange",

            /** api: events[layerchange]
             *  Fires when a new layer is selected, as soon as this panel's
             *  ``attributesStore`` and ``geometryType`` attributes are set.
             *
             *  Listener arguments:
             *  * panel - :class:`gxp.QueryPanel` This query panel.
             *  * record - ``Ext.data.Record`` Record representing the selected
             *      layer.
             */
            "layerchange",

            /** api: events[beforequery]
             *  Fires before a query for features is issued.  If any listener
             *  returns false, the query will not be issued.
             *
             *  Listener arguments:
             *  * panel - :class:`gxp.QueryPanel` This query panel.
             */
            "beforequery",

            /** api: events[query]
             *  Fires when a query for features is issued.
             *
             *  Listener arguments:
             *  * panel - :class:`gxp.QueryPanel` This query panel.
             *  * store - ``GeoExt.data.FeatureStore`` The feature store.
             */
            "query",

            /** api: events[storeload]
             *  Fires when the feature store loads.
             *
             *  Listener arguments:
             *  * panel - :class:`gxp.QueryPanel` This query panel.
             *  * store - ``GeoExt.data.FeatureStore`` The feature store.
             *  * records - ``Array(Ext.data.Record)`` The records that were
             *      loaded.
             *  * options - ``Object`` The loading options that were specified.
             */
            "storeload"

        );        
        
        this.mapExtentField = new Ext.form.TextField({
            fieldLabel: this.currentTextText,
            readOnly: true,
            anchor: "100%",
            value: this.getFormattedMapExtent()
        });
        this.map.events.on({
            moveend: this.updateMapExtent,
            scope: this
        });
        
        this.createFilterBuilder(this.layerStore.getAt(0));
        
        this.items = [{
            xtype: "combo",
            name: "layer",
            fieldLabel: this.layerText,
            store: this.layerStore,
            value: this.layerStore.getAt(0).get("name"),
            displayField: "title",
            valueField: "name",
            mode: "local",
            allowBlank: true,
            editable: false,
            triggerAction: "all",
            listeners: {
                beforeselect: function(combo, record, index) {
                    return this.fireEvent("beforelayerchange", this, record);
                },
                select: function(combo, record, index) {
                    this.createFilterBuilder(record);
                },
                scope: this
            }
        }, {
            xtype: "fieldset",
            title: this.queryByLocationText,
            checkboxToggle: true,
            collapsed: !this.spatialQuery,
            anchor: "95%",
            items: [this.mapExtentField],
            listeners: {
                collapse: function() {
                    this.spatialQuery = false;
                },
                expand: function() {
                    this.spatialQuery = true;
                },
                scope: this
            }
        }, {
            xtype: "fieldset",
            title: this.queryByAttributesText,
            checkboxToggle: true,
            collapsed: !this.attributeQuery,
            anchor: "95%",
            items: [this.filterBuilder],
            listeners: {
                collapse: function() {
                    this.attributeQuery = false;
                },
                expand: function() {
                    this.attributeQuery = true;
                },
                scope: this
            }            
        }];
        
        gxp.QueryPanel.superclass.initComponent.apply(this, arguments);

    },
    
    /** private: method[createFilterBuilder]
     *  :arg record: ``Ext.data.Record``  A record representing the feature
     *      type.
     *  
     *  Remove any existing filter builder and create a new one.  This method
     *  also sets the currently selected layer and stores the name for the
     *  first geometry attribute found when the attribute store loads.
     */
    createFilterBuilder: function(record) {
        this.selectedLayer = record;
        var owner = this.filterBuilder && this.filterBuilder.ownerCt;
        if (owner) {
            owner.remove(this.filterBuilder, true);
        }

        this.attributeStore = new GeoExt.data.AttributeStore({
            url: record.get("schema"),
            listeners: {
                load: function(store) {
                    this.geometryName = null;
                    store.filterBy(function(r) {
                        var match = /gml:((Multi)?(Point|Line|Polygon|Curve|Surface|Geometry)).*/.exec(r.get("type"));
                        if (match && !this.geometryName) {
                            this.geometryName = r.get("name");
                            this.geometryType = match[1];
                            this.fireEvent("layerchange", this, record);
                        }
                        return !match;
                    }, this);
                    this.createFeatureStore();
                },
                scope: this
            },
            autoLoad: true
        });

        this.filterBuilder = new gxp.FilterBuilder({
            //anchor: "-8px",
            attributes: this.attributeStore,
            allowGroups: false,
            caseInsensitiveMatch: this.caseInsensitiveMatch
        });
        
        if(owner) {
            owner.add(this.filterBuilder);
            owner.doLayout();
        }
        
    },
    
    getFormattedMapExtent: function() {
        return this.map &&
            this.map.getExtent() &&
            this.map.getExtent().toBBOX().replace(/\.(\d)\d*/g, ".$1").replace(/,/g, ", ");
    },
    
    updateMapExtent: function() {
        this.mapExtentField.setValue(this.getFormattedMapExtent());
    },
    
    /** api: method[getFilter]
     *  Get the filter representing the conditions in the panel.  Returns false
     *  if neither spatial nor attribute query is checked.
     */
    getFilter: function() {
        var attributeFilter = this.attributeQuery && this.filterBuilder.getFilter();

        // If LIKE comparison substrings are enabled, wrap their string literals in wildcards
        if (attributeFilter && this.likeSubstring) {
            attributeFilter = this.wrapWildCards(attributeFilter);
        }

        var spatialFilter = this.spatialQuery && new OpenLayers.Filter.Spatial({
            type: OpenLayers.Filter.Spatial.BBOX,
            value: this.map.getExtent()
        });
        var filter;
        if (attributeFilter && spatialFilter) {
            filter = new OpenLayers.Filter.Logical({
                type: OpenLayers.Filter.Logical.AND,
                filters: [spatialFilter, attributeFilter]
            });
        } else {
            filter = attributeFilter || spatialFilter;
        }
        return filter;
    },
    
    /** private: method[wrapWildCards]
     *  :return: ``OpenLayers.Filter``
     *
     *  Returns the same (Composite) Filter with string literals wrapped with wildcard symbols
     *  for all Comparison LIKE Filters.
     */
    wrapWildCards: function (filter) {

        if (filter instanceof OpenLayers.Filter.Logical) {
            // Go recursively through composite filter
            for (var i = 0, len = filter.filters.length; i < len; ++i) {
                filter = this.wrapWildCards(filter.filters[i]);
            }
        } else if (filter.type === OpenLayers.Filter.Comparison.LIKE) {
            // Wrap the value in Wildcard strings.
            filter.value = this.wildCardString + filter.value + this.wildCardString;
        }

        return filter;
    },

    /** private: method[getFieldType]
     *  :arg attrType: ``String`` Attribute type.
     *  :returns: ``String`` Field type
     *
     *  Given a feature attribute type, return an Ext field type if possible.
     *  Note that there are many unhandled xsd types here.
     *  
     *  TODO: this should go elsewhere (AttributeReader)
     */
    getFieldType: function(attrType) {
        return ({
            "xsd:boolean": "boolean",
            "xsd:int": "int",
            "xsd:integer": "int",
            "xsd:short": "int",
            "xsd:long": "int",
            "xsd:date": "date",
            "xsd:string": "string",
            "xsd:float": "float",
            "xsd:double": "float"
        })[attrType];
    },
    
    /** private: method[createFeatureStore]
     *  Create the feature store for the selected layer.  Queries cannot be
     *  issued until this store has been created.  This method is called
     *  when the required attribute store loads.
     */
    createFeatureStore: function() {
        var fields = [];
        this.attributeStore.each(function(record) {
            fields.push({
                name: record.get("name"),
                type: this.getFieldType(record.get("type"))
            });
        }, this);
        
        var layer = this.selectedLayer;
        
        this.featureStore = new gxp.data.WFSFeatureStore({
            fields: fields,
            srsName: this.map.getProjection(),
            url: layer.get("url"),
            featureType: layer.get("name"),
            featureNS:  layer.get("namespace"),
            geometryName: this.geometryName,
            schema: layer.get("schema"),
            maxFeatures: this.maxFeatures,
            autoLoad: false,
            autoSave: false,
            listeners: {
                load: function(store, records, options) {
                    this.fireEvent("storeload", this, store, records, options);
                },
                scope: this
            }
        });
        this.fireEvent("ready", this, this.featureStore);
    },
    
    /** api: method[query]
     *  Issue a request for features.  Should not be called until the "ready"
     *  event has fired.  If called before ready, no query will be issued.
     */
    query: function() {
        if (this.featureStore) {
            if (this.fireEvent("beforequery", this) !== false) {
                this.featureStore.setOgcFilter(this.getFilter());
                this.featureStore.load();
                this.fireEvent("query", this, this.featureStore);
            }
        }
    },

    /** private: method[beforeDestroy]
     *  Private method called during the destroy sequence.
     */
    beforeDestroy: function() {
        if (this.map && this.map.events) {
            this.map.events.un({
                moveend: this.updateMapExtent,
                scope: this
            });
        }
        gxp.QueryPanel.superclass.beforeDestroy.apply(this, arguments);
    }

});

/** api: xtype = gxp_querypanel */
Ext.reg('gxp_querypanel', gxp.QueryPanel); 

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp
 *  class = StylePropertiesDialog
 *  base_link = `Ext.Container <http://extjs.com/deploy/dev/docs/?class=Ext.Container>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: StylePropertiesDialog(config)
 *   
 *      Create a dialog for editing properties of a UserStyle.
 */
gxp.StylePropertiesDialog = Ext.extend(Ext.Container, {
    
    /* i18n */
    titleText: "General",
    nameFieldText: "Name",
    titleFieldText: "Title",
    abstractFieldText: "Abstract",
    /* ~i18n */
    
    /** api: config[userStyle]
     *  ``OpenLayers.Style``
     */
    
    /** api: property[userStyle]
     *  ``OpenLayers.Style``
     */
    userStyle: null,
    
    /** api: config[nameEditable]
     *  ``Boolean`` Set to false if the name of the style should not be
     *  editable.
     */
    
    /** private: method[initComponent]
     */
    initComponent: function() {
        var listeners = {
            "change": function(field, value) {
                this.userStyle[field.name] = value;
                this.fireEvent("change", this, this.userStyle);
            },
            scope: this
        };
        var defConfig = {
            layout: "form",
            items: [{
                xtype: "fieldset",
                title: this.titleText,
                labelWidth: 75,
                defaults: {
                    xtype: "textfield",
                    anchor: "100%",
                    listeners: listeners
                },
                items: [{
                    xtype: this.initialConfig.nameEditable ? "textfield" : "displayfield",
                    fieldLabel: this.nameFieldText,
                    name: "name",
                    value: this.userStyle.name,
                    maskRe: /[A-Za-z0-9_]/
                }, {
                    fieldLabel: this.titleFieldText,
                    name: "title",
                    value: this.userStyle.title
                }, {
                    xtype: "textarea",
                    fieldLabel: this.abstractFieldText,
                    name: "description",
                    value: this.userStyle.description
                }]
            }]
        };
        Ext.applyIf(this, defConfig);
        
        this.addEvents(
            /** api: events[change]
             *  Fires when any style property changes.
             *
             *  Listener arguments:
             *  * component - ``gxp.StylePropertiesDialog`` This dialog.
             *  * userStyle - ``OpenLayers.Style`` The updated style.
             */
            "change"
        ); 

        gxp.StylePropertiesDialog.superclass.initComponent.apply(this, arguments);
    }
});

/** api: xtype = gxp_styleproperties */
Ext.reg('gxp_stylepropertiesdialog', gxp.StylePropertiesDialog);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

//TODO remove the WMSStylesDialog and GeoServerStyleWriter includes
/**
 * @include widgets/WMSStylesDialog.js
 * @include plugins/GeoServerStyleWriter.js
 * @include GeoExt/widgets/LayerOpacitySlider.js
 * @require OpenLayers/Format/CQL.js
 * @require widgets/FilterBuilder.js
 */

/** api: (define)
 *  module = gxp
 *  class = WMSLayerPanel
 *  base_link = `Ext.TabPanel <http://extjs.com/deploy/dev/docs/?class=Ext.TabPanel>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: WMSLayerPanel(config)
 *   
 *      Create a dialog for setting WMS layer properties like title, abstract,
 *      opacity, transparency and image format.
 */
gxp.WMSLayerPanel = Ext.extend(Ext.TabPanel, {
    
    /** api: config[layerRecord]
     *  ``GeoExt.data.LayerRecord``
     *  Show properties for this layer record.
     */
    layerRecord: null,

    /** api: config[source]
     *  ``gxp.plugins.LayerSource``
     *  Source for the layer. Optional. If not provided, ``sameOriginStyling``
     *  will be ignored.
     */
    source: null,
    
    /** api: config[styling]
     *  ``Boolean``
     *  Show a "Styles" tab. Default is true.
     */
    styling: true,
    
    /** api: config[sameOriginStyling]
     *  ``Boolean``
     *  Only allow editing of styles for layers whose sources have a URL that
     *  matches the origin of this application.  It is strongly discouraged to 
     *  do styling through the proxy as all authorization headers and cookies 
     *  are shared with all remotesources.  Default is ``true``.
     */
    sameOriginStyling: true,

    /** api: config[rasterStyling]
     *  ``Boolean`` If set to true, single-band raster styling will be
     *  supported.  Default is ``false``.
     */
    rasterStyling: false,

    /** private: property[transparent]
     *  ``Boolean``
     *  Used to store the previous state of the transparent checkbox before
     *  changing the image format to jpeg (and automagically changing
     *  the checkbox to disabled and unchecked).
     */
    transparent: null,
    
    /** private: property[editableStyles]
     *  ``Boolean``
     */
    editableStyles: false,
    
    /** api: config[activeTab]
     *  ``String or Number``
     *  A string id or the numeric index of the tab that should be initially
     *  activated on render.  Defaults to ``0``.
     */
    activeTab: 0,
    
    /** api: config[border]
     *  ``Boolean``
     *  Display a border around the panel.  Defaults to ``false``.
     */
    border: false,
    
    /** api: config[imageFormats]
     *  ``RegEx`` Regular expression used to test browser friendly formats for
     *  GetMap requests.  The formats displayed will those from the record that
     *  match this expression.  Default is ``/png|gif|jpe?g/i``.
     */
    imageFormats: /png|gif|jpe?g/i,
    
    /** i18n */
    aboutText: "About",
    titleText: "Title",
    attributionText: "Attribution",
    nameText: "Name",
    descriptionText: "Description",
    displayText: "Display",
    opacityText: "Opacity",
    formatText: "Tile format",
    infoFormatText: "Info format",
    infoFormatEmptyText: "Select a format",
    transparentText: "Transparent",
    cacheText: "Caching",
    cacheFieldText: "Use cached tiles",
    stylesText: "Available Styles",
    displayOptionsText: "Display options",
    queryText: "Limit with filters",
    scaleText: "Limit by scale",
    minScaleText: "Min scale",
    maxScaleText: "Max scale",
    switchToFilterBuilderText: "Switch back to filter builder",
    cqlPrefixText: "or ",
    cqlText: "use CQL filter instead",
    singleTileText: "Single tile",
    singleTileFieldText: "Use a single tile",

    initComponent: function() {
        this.cqlFormat = new OpenLayers.Format.CQL();
        if (this.source) {
            this.source.getSchema(this.layerRecord, function(attributeStore) {
                if (attributeStore !== false) {
                    var filter = this.layerRecord.getLayer().params.CQL_FILTER;
                    this.filterBuilder = new gxp.FilterBuilder({
                        filter: filter && this.cqlFormat.read(filter),
                        allowGroups: false,
                        listeners: {
                            afterrender: function() {
                                this.filterBuilder.cascade(function(item) {
                                    if (item.getXType() === "toolbar") {
                                        item.addText(this.cqlPrefixText);
                                        item.addButton({
                                            text: this.cqlText,
                                            handler: this.switchToCQL,
                                            scope: this
                                        });
                                    }
                                }, this);
                            },
                            change: function(builder) {
                                var filter = builder.getFilter();
                                var cql = null;
                                if (filter !== false) {
                                    cql = this.cqlFormat.write(filter);
                                }
                                this.layerRecord.getLayer().mergeNewParams({
                                    CQL_FILTER: cql
                                });
                            },
                            scope: this
                        },
                        attributes: attributeStore
                    });
                    this.filterFieldset.add(this.filterBuilder);
                    this.filterFieldset.doLayout();
                }
            }, this);
        }
        this.addEvents(
            /** api: event[change]
             *  Fires when the ``layerRecord`` is changed using this dialog.
             */
            "change"
        );
        this.items = [
            this.createAboutPanel(),
            this.createDisplayPanel()
        ];

        // only add the Styles panel if we know for sure that we have styles
        if (this.styling && gxp.WMSStylesDialog && this.layerRecord.get("styles")) {
            // TODO: revisit this
            var url = this.layerRecord.get("restUrl");
            if (!url) {
                url = (this.source || this.layerRecord.get("layer")).url.split(
                    "?").shift().replace(/\/(wms|ows)\/?$/, "/rest");
            }
            if (this.sameOriginStyling) {
                // this could be made more robust
                // for now, only style for sources with relative url
                this.editableStyles = url.charAt(0) === "/";
            } else {
                this.editableStyles = true;
            }
            this.items.push(this.createStylesPanel(url));
        }

        gxp.WMSLayerPanel.superclass.initComponent.call(this);
    },

    /** private: method[switchToCQL]
     *  Switch from filter builder to CQL.
     */
    switchToCQL: function() {
        var filter = this.filterBuilder.getFilter();
        var CQL = "";
        if (filter !== false) {
            CQL = this.cqlFormat.write(filter);
        }
        this.filterBuilder.hide();
        this.cqlField.setValue(CQL);
        this.cqlField.show();
        this.cqlToolbar.show();
    },

    /** private: method[switchToFilterBuilder]
     *  Switch from CQL field to filter builder.
     */
    switchToFilterBuilder: function() {
        var filter = null;
        // when parsing fails, we keep the previous filter in the filter builder
        try {
            filter = this.cqlFormat.read(this.cqlField.getValue());
        } catch(e) {
        }
        this.cqlField.hide();
        this.cqlToolbar.hide();
        this.filterBuilder.show();
        if (filter !== null) {
            this.filterBuilder.setFilter(filter);
        }
    },

    /** private: method[createStylesPanel]
     *  :arg url: ``String`` url to save styles to
     *
     *  Creates the Styles panel.
     */
    createStylesPanel: function(url) {
        var config = gxp.WMSStylesDialog.createGeoServerStylerConfig(
            this.layerRecord, url
        );
        if (this.rasterStyling === true) {
            config.plugins.push({
                ptype: "gxp_wmsrasterstylesdialog"
            });
        }
        var ownerCt = this.ownerCt;
        if (!(ownerCt.ownerCt instanceof Ext.Window)) {
            config.dialogCls = Ext.Panel;
            config.showDlg = function(dlg) {
                dlg.layout = "fit";
                dlg.autoHeight = false;
                ownerCt.add(dlg);
            };
        }
        return Ext.apply(config, {
            title: this.stylesText,
            style: "padding: 10px",
            editable: false
        });
    },
    
    /** private: method[createAboutPanel]
     *  Creates the about panel.
     */
    createAboutPanel: function() {
        return {
            title: this.aboutText,
            bodyStyle: {"padding": "10px"},
            defaults: {
                border: false
            },
            items: [{
                layout: "form",
                labelWidth: 70,
                items: [{
                    xtype: "textfield",
                    fieldLabel: this.titleText,
                    anchor: "99%",
                    value: this.layerRecord.get("title"),
                    listeners: {
                        change: function(field) {
                            this.layerRecord.set("title", field.getValue());
                            //TODO revisit when discussion on
                            // http://trac.geoext.org/ticket/110 is complete
                            this.layerRecord.commit();
                            this.fireEvent("change");
                        },
                        scope: this
                    }
                }, {
                    xtype: "textfield",
                    fieldLabel: this.nameText,
                    anchor: "99%",
                    value: this.layerRecord.get("name"),
                    readOnly: true
                }, {
                    xtype: "textfield",
                    fieldLabel: this.attributionText,
                    anchor: "99%",
                    listeners: {
                        change: function(field) {
                            var layer = this.layerRecord.getLayer();
                            layer.attribution = field.getValue();
                            layer.map.events.triggerEvent("changelayer", {
                                layer: layer, property: "attribution"
                            });
                            this.fireEvent("change");
                        },
                        scope: this
                    },
                    value: this.layerRecord.getLayer().attribution
                }]
            }, {
                layout: "form",
                labelAlign: "top",
                items: [{
                    xtype: "textarea",
                    fieldLabel: this.descriptionText,
                    grow: true,
                    growMax: 150,
                    anchor: "99%",
                    value: this.layerRecord.get("abstract"),
                    readOnly: true
                }]
            }]
        };
    },

    /** private: method[onFormatChange]
     *  Handler for when the image format is changed.
     */
    onFormatChange: function(combo) {
        var layer = this.layerRecord.getLayer();
        var format = combo.getValue();
        layer.mergeNewParams({
            format: format
        });
        var cb = this.transparentCb;
        if (format == "image/jpeg") {
            this.transparent = cb.getValue();
            cb.setValue(false);
        } else if (this.transparent !== null) {
            cb.setValue(this.transparent);
            this.transparent = null;
        }
        cb.setDisabled(format == "image/jpeg");
        this.fireEvent("change");
    },

    /** private: method[addScaleOptions]
     *  :arg layer: ``OpenLayers.Layer.WMS``
     *  :arg options: ``Object``
     *
     *  Apply the scale options to the layer and redraw.
     */
    addScaleOptions: function(layer, options) {
        // work around for https://github.com/openlayers/openlayers/issues/407
        layer.alwaysInRange = null;
        layer.addOptions(options);
        layer.display();
        layer.redraw();
    },
    
    /** private: method[createDisplayPanel]
     *  Creates the display panel.
     */
    createDisplayPanel: function() {
        var record = this.layerRecord;
        var layer = record.getLayer();
        var opacity = layer.opacity;
        if(opacity == null) {
            opacity = 1;
        }
        var formats = [];
        var currentFormat = layer.params["FORMAT"].toLowerCase();
        Ext.each(record.get("formats"), function(format) {
            if(this.imageFormats.test(format)) {
                formats.push(format.toLowerCase());
            }
        }, this);
        if(formats.indexOf(currentFormat) === -1) {
            formats.push(currentFormat);
        }
        var transparent = layer.params["TRANSPARENT"];
        transparent = (transparent === "true" || transparent === true);

        return {
            title: this.displayText,
            layout: 'form',
            bodyStyle: {"padding": "10px"},
            defaults: {
                labelWidth: 70
            },
            items: [{
                xtype: "fieldset",
                title: this.displayOptionsText,
                items: [{
                    xtype: "gx_opacityslider",
                    name: "opacity",
                    anchor: "99%",
                    isFormField: true,
                    fieldLabel: this.opacityText,
                    listeners: {
                        change: function() {
                            this.fireEvent("change");
                        },
                        scope: this
                    },
                    layer: this.layerRecord
                }, {
                    xtype: "compositefield",
                    fieldLabel: this.formatText,
                    anchor: "99%",
                    items: [{
                        xtype: "combo",
                        width: 90,
                        listWidth: 150,
                        store: formats,
                        value: currentFormat,
                        mode: "local",
                        triggerAction: "all",
                        editable: false,
                        listeners: {
                            select: this.onFormatChange,
                            scope: this
                        }
                    }, {
                        xtype: "checkbox",
                        ref: '../../../transparentCb',
                        checked: transparent,
                        listeners: {
                            check: function(checkbox, checked) {
                                layer.mergeNewParams({
                                    transparent: checked ? "true" : "false"
                                });
                                this.fireEvent("change");
                            },
                            scope: this
                        }
                    }, {
                        xtype: "label",
                        cls: "gxp-layerproperties-label",
                        text: this.transparentText
                    }]
                }, {
                    xtype: "compositefield",
                    fieldLabel: this.singleTileText,
                    anchor: "99%",
                    items: [{
                        xtype: "checkbox",
                        checked: this.layerRecord.get("layer").singleTile,
                        listeners: {
                            check: function(checkbox, checked) {
                                layer.addOptions({singleTile: checked});
                                this.fireEvent("change");
                            },
                            scope: this
                        }
                    }, {
                        xtype: "label",
                        cls: "gxp-layerproperties-label",
                        text: this.singleTileFieldText
                    }]
                }, {
                    xtype: "compositefield",
                    anchor: "99%",
                    hidden: this.layerRecord.get("layer").params.TILED == null,
                    fieldLabel: this.cacheText,
                    items: [{
                        xtype: "checkbox",
                        checked: (this.layerRecord.get("layer").params.TILED === true),
                        listeners: {
                            check: function(checkbox, checked) {
                                var layer = this.layerRecord.get("layer");
                                layer.mergeNewParams({
                                    TILED: checked
                                });
                                this.fireEvent("change");
                            },
                            scope: this
                        }
                    }, {
                        xtype: "label",
                        cls: "gxp-layerproperties-label",
                        text: this.cacheFieldText
                    }]
                }, {
                    xtype: "combo",
                    fieldLabel: this.infoFormatText,
                    emptyText: this.infoFormatEmptyText,
                    store: record.get("infoFormats"),
                    value: record.get("infoFormat"),
                    hidden: (record.get("infoFormats") === undefined),
                    mode: 'local',
                    listWidth: 150,
                    triggerAction: "all",
                    editable: false,
                    anchor: "99%", 
                    listeners: {
                        select: function(combo) {
                            var infoFormat = combo.getValue();
                            record.set("infoFormat", infoFormat);
                            this.fireEvent("change");
                        }
                    }, 
                    scope: this
                }]
            }, {
                xtype: "fieldset",
                title: this.queryText,
                hideLabels: true,
                ref: "../filterFieldset",
                listeners: {
                    expand: function() {
                        this.layerRecord.getLayer().mergeNewParams({CQL_FILTER: this.cqlFilter});
                    },
                    collapse: function() {
                        this.cqlFilter = this.layerRecord.getLayer().params.CQL_FILTER;
                        this.layerRecord.getLayer().mergeNewParams({CQL_FILTER: null});
                    },
                    scope: this
                },
                hidden: this.source === null,
                checkboxToggle: true,
                collapsed: !this.layerRecord.getLayer().params.CQL_FILTER,
                items: [{
                    xtype: "textarea",
                    value: this.layerRecord.getLayer().params.CQL_FILTER,
                    grow: true,
                    anchor: '99%',
                    width: '100%',
                    growMax: 100,
                    ref: "../../cqlField",
                    hidden: true
                }],
                buttons: [{
                    ref: "../../../cqlToolbar",
                    hidden: true,
                    text: this.switchToFilterBuilderText,
                    handler: this.switchToFilterBuilder,
                    scope: this
                }]
            }, {
                xtype: "fieldset",
                title: this.scaleText,
                listeners: {
                    expand: function() {
                        var layer = this.layerRecord.getLayer();
                        if (this.minScale !== undefined || this.maxScale !== undefined) {
                            this.addScaleOptions(layer, {minScale: this.maxScale, maxScale: this.minScale});
                        }
                    },
                    collapse: function() {
                        var layer = this.layerRecord.getLayer();
                        this.minScale = layer.options.maxScale;
                        this.maxScale = layer.options.minScale;
                        this.addScaleOptions(layer, {minScale: null, maxScale: null});
                    },
                    scope: this
                },
                checkboxToggle: true,
                collapsed: this.layerRecord.getLayer().options.maxScale == null &&
                    this.layerRecord.getLayer().options.minScale == null,
                items: [{
                    xtype: "compositefield",
                    fieldLabel: this.minScaleText,
                    items: [{
                        xtype: "label",
                        text: "1:",
                        cls: "gxp-layerproperties-label"
                    }, {
                        xtype: "numberfield",
                        anchor: '99%',
                        width: '85%',
                        listeners: {
                            'change': function(field) {
                                var options = {
                                    maxScale: parseInt(field.getValue())
                                };
                                var layer = this.layerRecord.getLayer();
                                this.addScaleOptions(layer, options);
                            },
                            scope: this
                        },
                        value: this.layerRecord.getLayer().options.maxScale
                    }]
                }, {
                    xtype: "compositefield",
                    fieldLabel: this.maxScaleText,
                    items: [{
                        xtype: "label",
                        text: "1:",
                        cls: "gxp-layerproperties-label"
                    }, {
                        xtype: "numberfield",
                        anchor: '99%',
                        width: '85%',
                        listeners: {
                            'change': function(field) {
                                var options = {
                                    minScale: parseInt(field.getValue())
                                };
                                var layer = this.layerRecord.getLayer();
                                this.addScaleOptions(layer, options);
                            },
                            scope: this
                        },
                        value: this.layerRecord.getLayer().options.minScale
                    }]
                }]
            }]
        };
    }    

});

Ext.reg('gxp_wmslayerpanel', gxp.WMSLayerPanel); 

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @require util.js
 * @require widgets/RulePanel.js
 * @require widgets/StylePropertiesDialog.js
 * @requires OpenLayers/Renderer/SVG.js
 * @requires OpenLayers/Renderer/VML.js
 * @requires OpenLayers/Renderer/Canvas.js
 * @require OpenLayers/Style2.js
 * @require OpenLayers/Format/SLD/v1_0_0_GeoServer.js
 * @require GeoExt/data/AttributeStore.js
 * @require GeoExt/widgets/WMSLegend.js
 * @require GeoExt/widgets/VectorLegend.js
 */

/** api: (define)
 *  module = gxp
 *  class = WMSStylesDialog
 *  base_link = `Ext.Container <http://extjs.com/deploy/dev/docs/?class=Ext.Container>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: WMSStylesDialog(config)
 *   
 *      Create a dialog for selecting and layer styles. If the WMS supports
 *      GetStyles, styles can also be edited. The dialog does not provide any
 *      means of writing modified styles back to the server. To save styles,
 *      configure the dialog with a :class:`gxp.plugins.StyleWriter` plugin
 *      and call the ``saveStyles`` method.
 *
 *      Note: when this component is included in a build,
 *      ``OpenLayers.Renderer.defaultSymbolizer`` will be set to the SLD
 *      defaults.  In addition, the OpenLayers SLD v1 parser will be patched
 *      to support vendor specific extensions added to SLD by GeoTools.
 */
gxp.WMSStylesDialog = Ext.extend(Ext.Container, {
    
    /** api: config[addStyleText] (i18n) */
     addStyleText: "Add",
    /** api: config[addStyleTip] (i18n) */
     addStyleTip: "Add a new style",
    /** api: config[chooseStyleText] (i18n) */    
    chooseStyleText: "Choose style",
    /** api: config[addStyleText] (i18n) */
     deleteStyleText: "Remove",
    /** api: config[addStyleTip] (i18n) */
     deleteStyleTip: "Delete the selected style",
    /** api: config[addStyleText] (i18n) */
     editStyleText: "Edit",
    /** api: config[addStyleTip] (i18n) */
     editStyleTip: "Edit the selected style",
    /** api: config[addStyleText] (i18n) */
     duplicateStyleText: "Duplicate",
    /** api: config[addStyleTip] (i18n) */
     duplicateStyleTip: "Duplicate the selected style",
    /** api: config[addStyleText] (i18n) */
     addRuleText: "Add",
    /** api: config[addStyleTip] (i18n) */
     addRuleTip: "Add a new rule",
    /** api: config[newRuleText] (i18n) */
     newRuleText: "New Rule",
    /** api: config[addStyleText] (i18n) */
     deleteRuleText: "Remove",
    /** api: config[addStyleTip] (i18n) */
     deleteRuleTip: "Delete the selected rule",
    /** api: config[addStyleText] (i18n) */
     editRuleText: "Edit",
    /** api: config[addStyleTip] (i18n) */
     editRuleTip: "Edit the selected rule",
    /** api: config[addStyleText] (i18n) */
     duplicateRuleText: "Duplicate",
    /** api: config[addStyleTip] (i18n) */
     duplicateRuleTip: "Duplicate the selected rule",
    /** api: config[cancelText] (i18n) */
     cancelText: "Cancel",
    /** api: config[saveText] (i18n) */
     saveText: "Save",
    /** api: config[stylePropertiesWindowTitle] (i18n) */
     styleWindowTitle: "User Style: {0}",
    /** api: config[ruleWindowTitle] (i18n) */
     ruleWindowTitle: "Style Rule: {0}",
    /** api: config[stylesFieldsetTitle] (i18n) */
     stylesFieldsetTitle: "Styles",
    /** api: config[rulesFieldsetTitle] (i18n) */
     rulesFieldsetTitle: "Rules",
    /** api: config[errorTitle] (i18n) */
     errorTitle: "Error saving style",
    /** api: config[errorMsg] (i18n) */
     errorMsg: "There was an error saving the style back to the server.",

    //TODO create a StylesStore which can read styles using GetStyles. Create
    // subclasses for that store with writing capabilities, e.g.
    // for GeoServer's RESTconfig API. This should replace the current
    // StyleWriter plugins.
    
    /** api: config[layerRecord]
     *  ``GeoExt.data.LayerRecord`` The layer to edit/select styles for.
     */
    
    /** private: property[layerRecord]
     *  ``GeoExt.data.LayerRecord`` The layer to edit/select styles for.
     */
    layerRecord: null,
    
    /** api: config[styleName]
     *  ``String`` A style's name to select in the styles combo box. Optional.
     *  If not provided, the layer's current style will be selected.
     */
     
    /** api: config[stylesComboOptions]
     *  ``Object`` configuration options to pass to the styles combo of this
     *  dialog. Optional.
     */
    
    /** api: config[layerDescription]
     *  ``Object`` Array entry of a DescribeLayer response as read by
     *      ``OpenLayers.Format.WMSDescribeLayer``. Optional. If not provided,
     *      a DescribeLayer request will be issued to the WMS.
     */
    
    /** private: property[layerDescription]
     *  ``Object`` Array entry of a DescribeLayer response as read by
     *      ``OpenLayers.Format.WMSDescribeLayer``.
     */
    layerDescription: null,
    
    /** private: property[symbolType]
     *  ``Point`` or ``Line`` or ``Polygon`` - the primary symbol type for the
     *  layer. This is the symbolizer type of the first symbolizer of the
     *  first rule of the current layer style. Only available if the WMS
     *  supports GetStyles.
     */
    symbolType: null,
    
    /** api: property[stylesStore]
     *  ``Ext.data.Store`` A store representing the styles returned from
     *  GetCapabilities and GetStyles. It has "name", "title", "abstract",
     *  "legend" and "userStyle" fields. If the WMS supports GetStyles, the
     *  "legend" field will not be available. If it does not, the "userStyle"
     *  field will not be available.
     */
    stylesStore: null,
    
    /** api: property[selectedStyle]
     *  ``Ext.data.Record`` The currently selected style from the
     *  ``stylesStore``.
     */
    selectedStyle: null,
    
    /** private: property[selectedRule]
     *  ``OpenLayers.Rule`` The currently selected rule, or null if none
     *  selected.
     */
    selectedRule: null,
    
    /** api: config[editable]
     *  ``Boolean`` Set to false if styles should not be editable. Default is
     *  true.
     */
    
    /** api: property[editable]
     *  ``Boolean`` Read-only once the dialog is rendered. True if this
     *  component could gather enough information to allow styles being edited,
     *  false otherwise. This is not supposed to be read before the
     *  ``ready`` event is fired.
     */
    editable: true,
    
    /** private: property[modified]
     *  ``Boolean`` Will be true if styles were modified. Initial state is
     *  false.
     */
    modified: false,
    
    /** private: config[dialogCls]
     *  ``Ext.Component`` The dialogue class to use. Default is ``Ext.Window``.
     *  If using e.g. ``Ext.Container``, override the ``showDlg`` method to
     *  add the dialogue to a container.
     */
    dialogCls: Ext.Window,

    /** private: method[initComponent]
     */
    initComponent: function() {
        this.addEvents(
            /** api: event[ready]
             *  Fires when this component is ready for user interaction.
             */
            "ready",
            
            /** api: event[modified]
             *  Fires on every style modification.
             *
             *  Listener arguments:
             *
             *  * :class:`gxp.WMSStylesDialog` this component
             *  * ``String`` the name of the modified style
             */
            "modified",
            
            /** api: event[styleselected]
             *  Fires whenever an existing style is selected from this dialog's
             *  Style combo box.
             *  
             *  Listener arguments:
             *
             *  * :class:`gxp.WMSStylesDialog` this component
             *  * ``String`` the name of the selected style
             */
            "styleselected",
            
            /** api: event[beforesaved]
             *  Fires before the styles are saved (using a
             *  :class:`gxp.plugins.StyleWriter` plugin)
             *
             *  Listener arguments:
             *
             *  * :class:`gxp.WMSStylesDialog` this component
             *  * ``Object`` options for the ``write`` method of the
             *    :class:`gxp.plugins.StyleWriter`
             */
            "beforesaved",
            
            /** api: event[saved]
             *  Fires when a style was successfully saved. Applications should
             *  listen for this event and redraw layers with the currently
             *  selected style.
             *
             *  Listener arguments:
             *
             *  * :class:`gxp.WMSStylesDialog` this component
             *  * ``String`` the name of the currently selected style
             */
            "saved"            
        );

        var defConfig = {
            layout: "form",
            disabled: true,
            items: [{
                xtype: "fieldset",
                title: this.stylesFieldsetTitle,
                labelWidth: 85,
                style: "margin-bottom: 0;"
            }, {
                xtype: "toolbar",
                style: "border-width: 0 1px 1px 1px; margin-bottom: 10px;",
                items: [
                    {
                        xtype: "button",
                        iconCls: "add",
                        text: this.addStyleText,
                        tooltip: this.addStyleTip,
                        handler: this.addStyle,
                        scope: this
                    }, {
                        xtype: "button",
                        iconCls: "delete",
                        text: this.deleteStyleText,
                        tooltip: this.deleteStyleTip,
                        handler: function() {
                            this.stylesStore.remove(this.selectedStyle);
                        },
                        scope: this
                    }, {
                        xtype: "button",
                        iconCls: "edit",
                        text: this.editStyleText,
                        tooltip: this.editStyleTip,
                        handler: function() {
                            this.editStyle();
                        },
                        scope: this
                    }, {
                        xtype: "button",
                        iconCls: "duplicate",
                        text: this.duplicateStyleText,
                        tooltip: this.duplicateStyleTip,
                        handler: function() {
                            var prevStyle = this.selectedStyle;
                            var newStyle = prevStyle.get(
                                "userStyle").clone();
                            newStyle.isDefault = false;
                            newStyle.name = this.newStyleName();
                            var store = this.stylesStore;
                            store.add(new store.recordType({
                                "name": newStyle.name,
                                "title": newStyle.title,
                                "abstract": newStyle.description,
                                "userStyle": newStyle
                            }));
                            this.editStyle(prevStyle);
                        },
                        scope: this
                    }
                ]
            }]
        };
        Ext.applyIf(this, defConfig);
        
        this.createStylesStore();
                        
        this.on({
            "beforesaved": function() { this._saving = true; },
            "saved": function() { delete this._saving; },
            "savefailed": function() { 
                Ext.Msg.show({
                    title: this.errorTitle,
                    msg: this.errorMsg,
                    icon: Ext.MessageBox.ERROR,
                    buttons: {ok: true}
                });
                delete this._saving; 
            },
            "render": function() {
                gxp.util.dispatch([this.getStyles], function() {
                    this.enable();
                }, this);
            },
            scope: this
        });

        gxp.WMSStylesDialog.superclass.initComponent.apply(this, arguments);
    },
    
    /** api: method[addStyle]
     *  Creates a new style and selects it in the styles combo.
     */
    addStyle: function() {
        if(!this._ready) {
            this.on("ready", this.addStyle, this);
            return;
        }
        var prevStyle = this.selectedStyle;
        var store = this.stylesStore;
        var newStyle = new OpenLayers.Style(null, {
            name: this.newStyleName(),
            rules: [this.createRule()]
        });
        store.add(new store.recordType({
            "name": newStyle.name,
            "userStyle": newStyle
        }));
        this.editStyle(prevStyle);
    },
    
    /** api: method[editStyle]
     *  :arg prevStyle: ``Ext.data.Record``
     *
     *  Edit the currently selected style.
     */
    editStyle: function(prevStyle) {
        var userStyle = this.selectedStyle.get("userStyle");
        var buttonCfg = {
            bbar: ["->", {
                text: this.cancelText,
                iconCls: "cancel",
                handler: function() {
                    styleProperties.propertiesDialog.userStyle = userStyle;
                    styleProperties.destroy();
                    if (prevStyle) {
                        this._cancelling = true;
                        this.stylesStore.remove(this.selectedStyle);
                        this.changeStyle(prevStyle, {
                            updateCombo: true,
                            markModified: true
                        });
                        delete this._cancelling;
                    }
                },
                scope: this
            }, {
                text: this.saveText,
                iconCls: "save",
                handler: function() {
                    styleProperties.destroy();
                }
            }]
        };
        var styleProperties = new this.dialogCls(Ext.apply(buttonCfg, {
            title: String.format(this.styleWindowTitle,
                userStyle.title || userStyle.name),
            shortTitle: userStyle.title || userStyle.name,
            bodyBorder: false,
            autoHeight: true,
            width: 300,
            modal: true,
            items: {
                border: false,
                items: {
                    xtype: "gxp_stylepropertiesdialog",
                    ref: "../propertiesDialog",
                    userStyle: userStyle.clone(),
                    nameEditable: false,
                    style: "padding: 10px;"
                }
            },
            listeners: {
                "beforedestroy": function() {
                    this.selectedStyle.set(
                        "userStyle",
                        styleProperties.propertiesDialog.userStyle);
                },
                scope: this
            }
        }));
        this.showDlg(styleProperties);
    },
    
    /** api: method[createSLD]
     *  :arg options: ``Object``
     *  :return: ``String`` The current SLD for the NamedLayer.
     *  
     *  Supported ``options``:
     *
     *  * userStyles - ``Array(String)`` list of userStyles (by name) that are
     *    to be included in the SLD. By default, all will be included.
     */
    createSLD: function(options) {
        options = options || {};
        var sld = {
            version: "1.0.0",
            namedLayers: {}
        };
        var layerName = this.layerRecord.get("name");
        sld.namedLayers[layerName] = {
            name: layerName,
            userStyles: []
        };
        this.stylesStore.each(function(r) {
            if(!options.userStyles ||
                    options.userStyles.indexOf(r.get("name")) !== -1) {
                sld.namedLayers[layerName].userStyles.push(r.get("userStyle"));
            }
        });
        return new OpenLayers.Format.SLD({
            multipleSymbolizers: true,
            profile: "GeoServer"
        }).write(sld);
    },
    
    /** api: method[saveStyles]
     *  :arg options: ``Object`` Options to pass to the
     *      :class:`gxp.plugins.StyleWriter` plugin
     *
     *  Saves the styles. Without a :class:`gxp.plugins.StyleWriter` plugin
     *  configured for this instance, nothing will happen.
     */
    saveStyles: function(options) {
        this.modified === true && this.fireEvent("beforesaved", this, options);
    },
    
    /** private: method[updateStyleRemoveButton]
     *  Enable/disable the "Remove" button to make sure that we don't delete
     *  the last style.
     */
    updateStyleRemoveButton: function() {
        var userStyle = this.selectedStyle &&
            this.selectedStyle.get("userStyle");
        this.items.get(1).items.get(1).setDisabled(!userStyle ||
            this.stylesStore.getCount() <= 1 ||  userStyle.isDefault === true);
    },
    
    /** private: method[updateRuleRemoveButton]
     *  Enable/disable the "Remove" button to make sure that we don't delete
     *  the last rule.
     */
    updateRuleRemoveButton: function() {
        this.items.get(3).items.get(1).setDisabled(
            !this.selectedRule || this.items.get(2).items.get(0).rules.length < 2
        );
    },
    
    /** private: method[createRule]
     */
    createRule: function() {
        return new OpenLayers.Rule({
            symbolizers: [new OpenLayers.Symbolizer[this.symbolType]]
        });
    },
    
    /** private: method[addRulesFieldSet]
     *  :return: ``Ext.form.FieldSet``
     *
     *  Creates the rules fieldSet and adds it to this container.
     */
    addRulesFieldSet: function() {
        var rulesFieldSet = new Ext.form.FieldSet({
            itemId: "rulesfieldset",
            title: this.rulesFieldsetTitle,
            autoScroll: true,
            style: "margin-bottom: 0;",
            hideMode: "offsets",
            hidden: true
        });
        var rulesToolbar = new Ext.Toolbar({
            style: "border-width: 0 1px 1px 1px;",
            hidden: true,
            items: [
                {
                    xtype: "button",
                    iconCls: "add",
                    text: this.addRuleText,
                    tooltip: this.addRuleTip,
                    handler: this.addRule,
                    scope: this
                }, {
                    xtype: "button",
                    iconCls: "delete",
                    text: this.deleteRuleText,
                    tooltip: this.deleteRuleTip,
                    handler: this.removeRule,
                    scope: this,
                    disabled: true
                }, {
                    xtype: "button",
                    iconCls: "edit",
                    text: this.editRuleText,
                    toolitp: this.editRuleTip,
                    handler: function() {
                        this.layerDescription ?
                            this.editRule() :
                            this.describeLayer(this.editRule);
                    },
                    scope: this,
                    disabled: true
                }, {
                    xtype: "button",
                    iconCls: "duplicate",
                    text: this.duplicateRuleText,
                    tip: this.duplicateRuleTip,
                    handler: this.duplicateRule,
                    scope: this,
                    disabled: true
                }
            ]
        });
        this.add(rulesFieldSet, rulesToolbar);
        this.doLayout();
        return rulesFieldSet;
    },
    
    /** private: method[addRule]
     */
    addRule: function() {
        var legend = this.items.get(2).items.get(0);
        this.selectedStyle.get("userStyle").rules.push(
            this.createRule()
        );
        legend.update();
        // mark the style as modified
        this.selectedStyle.store.afterEdit(this.selectedStyle);
        this.updateRuleRemoveButton();
    },
    
    /** private: method[removeRule]
     */
    removeRule: function() {
        var selectedRule = this.selectedRule;
        this.items.get(2).items.get(0).unselect();
        this.selectedStyle.get("userStyle").rules.remove(selectedRule);
        // mark the style as modified
        this.afterRuleChange();
    },
    
    /** private: method[duplicateRule]
     */
    duplicateRule: function() {
        var legend = this.items.get(2).items.get(0);
        var newRule = this.selectedRule.clone();
        this.selectedStyle.get("userStyle").rules.push(
            newRule
        );
        legend.update();
        // mark the style as modified
        this.selectedStyle.store.afterEdit(this.selectedStyle);
        this.updateRuleRemoveButton();
    },
    
    /** private: method[editRule]
     */
    editRule: function() {
        var rule = this.selectedRule;
        var origRule = rule.clone();

        var ruleDlg = new this.dialogCls({
            title: String.format(this.ruleWindowTitle,
                rule.title || rule.name || this.newRuleText),
            shortTitle: rule.title || rule.name || this.newRuleText,
            layout: "fit",
            width: 320,
            height: 450,
            modal: true,
            items: [{
                xtype: "gxp_rulepanel",
                ref: "rulePanel",
                symbolType: this.symbolType,
                rule: rule,
                attributes: new GeoExt.data.AttributeStore({
                    url: this.layerDescription.owsURL,
                    baseParams: {
                        "SERVICE": this.layerDescription.owsType,
                        "REQUEST": "DescribeFeatureType",
                        "TYPENAME": this.layerDescription.typeName
                    },
                    method: "GET",
                    disableCaching: false
                }),
                autoScroll: true,
                border: false,
                defaults: {
                    autoHeight: true,
                    hideMode: "offsets"
                },
                listeners: {
                    "change": this.saveRule,
                    "tabchange": function() {
                        if (ruleDlg instanceof Ext.Window) {
                            ruleDlg.syncShadow();
                        }
                    },
                    scope: this
                }
            }],
            bbar: ["->", {
                text: this.cancelText,
                iconCls: "cancel",
                handler: function() {
                    this.saveRule(ruleDlg.rulePanel, origRule);
                    ruleDlg.destroy();
                },
                scope: this
            }, {
                text: this.saveText,
                iconCls: "save",
                handler: function() { ruleDlg.destroy(); }
            }]
        });
        this.showDlg(ruleDlg);
    },
    
    /** private: method[saveRule]
     *  :arg cmp:
     *  :arg rule: the rule to save back to the userStyle
     */
    saveRule: function(cmp, rule) {
        var style = this.selectedStyle;
        var legend = this.items.get(2).items.get(0);
        var userStyle = style.get("userStyle");
        var i = userStyle.rules.indexOf(this.selectedRule);
        userStyle.rules[i] = rule;
        this.afterRuleChange(rule);
    },
    
    /** private: method[afterRuleChange]
     *  :arg rule: the rule to set as selectedRule, can be null
     *  
     *  Performs actions that are required to update the selectedRule and
     *  selectedStyle after a rule was changed.
     */
    afterRuleChange: function(rule) {
        var legend = this.items.get(2).items.get(0);
        this.selectedRule = rule;
        // mark the style as modified
        this.selectedStyle.store.afterEdit(this.selectedStyle);
    },
    
    /** private: method[setRulesFieldSetVisible]
     *  :arg visible: ``Boolean``
     *
     *  Sets the visibility of the rules fieldset
     */
    setRulesFieldSetVisible: function(visible) {
        // the toolbar
        this.items.get(3).setVisible(visible && this.editable);
        // and the fieldset itself
        this.items.get(2).setVisible(visible);
        this.doLayout();
    },

    /** private: method[parseSLD]
     *  :arg response: ``Object``
     *  :arg options: ``Object``
     *  
     *  Success handler for the GetStyles response. Includes a fallback
     *  to GetLegendGraphic if no valid SLD is returned.
     */
    parseSLD: function(response, options) {
        var data = response.responseXML;
        if (!data || !data.documentElement) {
            data = new OpenLayers.Format.XML().read(response.responseText);
        }
        var layerParams = this.layerRecord.getLayer().params;

        var initialStyle = this.initialConfig.styleName || layerParams.STYLES;
        if (initialStyle) {
            this.selectedStyle = this.stylesStore.getAt(
                this.stylesStore.findExact("name", initialStyle));
        }
        
        var format = new OpenLayers.Format.SLD({profile: "GeoServer", multipleSymbolizers: true});
        
        try {
            var sld = format.read(data);

            // add userStyle objects to the stylesStore
            //TODO this only works if the LAYERS param contains one layer
            var userStyles = sld.namedLayers[layerParams.LAYERS].userStyles;

            // add styles from the layer's SLD_BODY *after* the userStyles
            var inlineStyles;
            if (layerParams.SLD_BODY) {
                var sldBody = format.read(layerParams.SLD_BODY);
                inlineStyles = sldBody.namedLayers[layerParams.LAYERS].userStyles;
                Array.prototype.push.apply(userStyles, inlineStyles);
            }            
            
            // our stylesStore comes from the layerRecord's styles - clear it
            // and repopulate from GetStyles
            this.stylesStore.removeAll();
            this.selectedStyle = null;
            
            var userStyle, record, index, defaultStyle;
            for (var i=0, len=userStyles.length; i<len; ++i) {
                userStyle = userStyles[i];
                // remove existing record - this way we replace styles from
                // userStyles with inline styles.
                index = this.stylesStore.findExact("name", userStyle.name);
                index !== -1 && this.stylesStore.removeAt(index);
                record = new this.stylesStore.recordType({
                    "name": userStyle.name,
                    "title": userStyle.title,
                    "abstract": userStyle.description,
                    "userStyle": userStyle
                });
                record.phantom = false;
                this.stylesStore.add(record);
                // set the default style if no STYLES param is set on the layer
                if (!this.selectedStyle && (initialStyle === userStyle.name ||
                            (!initialStyle && userStyle.isDefault === true))) {
                    this.selectedStyle = record;
                }
                if (userStyle.isDefault === true) {
                    defaultStyle = record;
                }
            }
            // fallback to the default style, this can happen when the layer referenced
            // a non-existing style as initialStyle
            if (!this.selectedStyle) {
                this.selectedStyle = defaultStyle;
            }
            
            this.addRulesFieldSet();
            this.createLegend(this.selectedStyle.get("userStyle").rules);
            
            this.stylesStoreReady();
            layerParams.SLD_BODY && this.markModified();
        }
        catch(e) {
            if (window.console) {
                console.warn(e.message);
            }
            this.setupNonEditable();
        }
    },
    
    /** private: method[createLegend]
     *  :arg rules: ``Array``
     */
    createLegend: function(rules) {
        var R = OpenLayers.Symbolizer.Raster;
        if (R && rules[0] && rules[0].symbolizers[0] instanceof R) {            
            throw new Error("Raster symbolizers are not supported.");
        } else {
            this.addVectorLegend(rules);
        }
    },
    
    /** private: methos[setNonEditable]
     */
    setupNonEditable: function() {
        this.editable = false;
        // disable styles toolbar
        this.items.get(1).hide();
        var rulesFieldSet = this.getComponent("rulesfieldset") ||
            this.addRulesFieldSet();
        rulesFieldSet.add(this.createLegendImage());
        this.doLayout();
        // disable rules toolbar
        this.items.get(3).hide();
        this.stylesStoreReady();
    },
    
    /** private: method[stylesStoreReady]
     *  Adds listeners and triggers the ``load`` event of the ``styleStore``.
     */
    stylesStoreReady: function() {
        // start with a clean store
        this.stylesStore.commitChanges();
        this.stylesStore.on({
            "load": function() {
                this.addStylesCombo();
                this.updateStyleRemoveButton();
            },
            "add": function(store, records, index) {
                this.updateStyleRemoveButton();
                // update the "Choose style" combo's value
                var combo = this.items.get(0).items.get(0);
                this.markModified();
                combo.fireEvent("select", combo, store.getAt(index), index);
                combo.setValue(this.selectedStyle.get("name"));
            },
            "remove": function(store, record, index) {
                if (!this._cancelling) {
                    this._removing = true;
                    var newIndex =  Math.min(index, store.getCount() - 1);
                    this.updateStyleRemoveButton();
                    // update the "Choose style" combo's value
                    var combo = this.items.get(0).items.get(0);
                    this.markModified();
                    combo.fireEvent("select", combo, store.getAt(newIndex), newIndex);
                    combo.setValue(this.selectedStyle.get("name"));
                    delete this._removing;
                }
            },
            "update": function(store, record) {
                var userStyle = record.get("userStyle");
                var data = {
                    "name": userStyle.name,
                    "title": userStyle.title || userStyle.name,
                    "abstract": userStyle.description
                };
                Ext.apply(record.data, data);
                // make sure that the legend gets updated
                this.changeStyle(record, {
                    updateCombo: true,
                    markModified: true
                });
            },
            scope: this
        });

        this.stylesStore.fireEvent("load", this.stylesStore,
            this.stylesStore.getRange()
        );

        this._ready = true;
        this.fireEvent("ready");
    },
    
    /** private: method[markModified]
     */
    markModified: function() {
        if(this.modified === false) {
            this.modified = true;
        }
        if (!this._saving) {
            this.fireEvent("modified", this, this.selectedStyle.get("name"));
        }
    },
    
    /** private: method[createStylesStore]
     */
    createStylesStore: function(callback) {
        var styles = this.layerRecord.get("styles") || [];
        this.stylesStore = new Ext.data.JsonStore({
            data: {
                styles: styles
            },
            idProperty: "name",
            root: "styles",
            // add a userStyle field (not included in styles from
            // GetCapabilities), which will be populated with the userStyle
            // object if GetStyles is supported by the WMS
            fields: ["name", "title", "abstract", "legend", "userStyle"],
            listeners: {
                "add": function(store, records) {
                    for(var rec, i=records.length-1; i>=0; --i) {
                        rec = records[i];
                        store.suspendEvents();
                        rec.get("title") || rec.set("title", rec.get("name"));
                        store.resumeEvents();
                    }
                }
            }
        });
    },
    
    /** private: method[getStyles]
     *  :arg callback: ``Function`` function that will be called when the
     *      request result was returned.
     */
    getStyles: function(callback) {
        var layer = this.layerRecord.getLayer();
        if(this.editable === true) {
            var version = layer.params["VERSION"];
            if (parseFloat(version) > 1.1) {
                //TODO don't force 1.1.1, fall back instead
                version = "1.1.1";
            }
            Ext.Ajax.request({
                url: layer.url,
                params: {
                    "SERVICE": "WMS",
                    "VERSION": version,
                    "REQUEST": "GetStyles",
                    "LAYERS": [layer.params["LAYERS"]].join(",")
                },
                method: "GET",
                disableCaching: false,
                success: this.parseSLD,
                failure: this.setupNonEditable,
                callback: callback,
                scope: this
            });            
        } else {
            this.setupNonEditable();
        }
    },
    
    /** private: method[describeLayer]
     *  :arg callback: ``Function`` function that will be called when the
     *      request result was returned.
     */
    describeLayer: function(callback) {
        if (this.layerDescription) {
            // always return before calling callback
            window.setTimeout(function() {
                callback.call(this);
            }, 0);
        } else {
            var layer = this.layerRecord.getLayer();
            var version = layer.params["VERSION"];
            if (parseFloat(version) > 1.1) {
                //TODO don't force 1.1.1, fall back instead
                version = "1.1.1";
            }
            Ext.Ajax.request({
                url: layer.url,
                params: {
                    "SERVICE": "WMS",
                    "VERSION": version,
                    "REQUEST": "DescribeLayer",
                    "LAYERS": [layer.params["LAYERS"]].join(",")
                },
                method: "GET",
                disableCaching: false,
                success: function(response) {
                    var result = new OpenLayers.Format.WMSDescribeLayer().read(
                        response.responseXML && response.responseXML.documentElement ?
                            response.responseXML : response.responseText);
                    this.layerDescription = result[0];
                },
                callback: callback,
                scope: this
            });
        }
    },
    
    /** private: method[addStylesCombo]
     * 
     *  Adds a combo box with the available style names found for the layer
     *  in the capabilities document to this component's stylesFieldset.
     */
    addStylesCombo: function() {
        var store = this.stylesStore;
        var combo = new Ext.form.ComboBox(Ext.apply({
            fieldLabel: this.chooseStyleText,
            store: store,
            editable: false,
            displayField: "title",
            valueField: "name",
            value: this.selectedStyle ?
                this.selectedStyle.get("title") :
                this.layerRecord.getLayer().params.STYLES || "default",
            disabled: !store.getCount(),
            mode: "local",
            typeAhead: true,
            triggerAction: "all",
            forceSelection: true,
            anchor: "100%",
            listeners: {
                "select": function(combo, record) {
                    this.changeStyle(record);
                    if (!record.phantom && !this._removing) {
                        this.fireEvent("styleselected", this, record.get("name"));
                    }
                },
                scope: this
            }
        }, this.initialConfig.stylesComboOptions));
        // add combo to the styles fieldset
        this.items.get(0).add(combo);
        this.doLayout();
    },
    
    /** private: method[createLegendImage]
     *  :return: ``GeoExt.LegendImage`` or undefined if none available.
     * 
     *  Creates a legend image for the first style of the current layer. This
     *  is used when GetStyles is not available from the layer's WMS.
     */
    createLegendImage: function() {
        var legend = new GeoExt.WMSLegend({
            showTitle: false,
            layerRecord: this.layerRecord,
            autoScroll: true,
            defaults: {
                listeners: {
                    "render": function(cmp) {
                        cmp.getEl().on({
                            load: function(evt, img) {
                                if (img.getAttribute("src") != cmp.defaultImgSrc) {
                                    this.setRulesFieldSetVisible(true);
                                    if (cmp.getEl().getHeight() > 250) {
                                        legend.setHeight(250);
                                    }
                                }
                            },
                            "error": function() {
                                this.setRulesFieldSetVisible(false);
                            },
                            scope: this
                        });
                    },
                    scope: this
                }
            }
        });
        return legend;
    },
    
    /** api: method[changeStyle]
     *  :arg value: ``Ext.data.Record``
     *  :arg options: ``Object`` Additional options for this method.
     *
     *  Available options:
     *  * updateCombo - ``Boolean`` set to true to update the combo box
     *  * markModified - ``Boolean`` set to true to mark the dialog modified
     *
     *  Handler for the stylesCombo's ``select`` and the store's ``update``
     *  event. Updates the layer and the rules fieldset.
     */
    changeStyle: function(record, options) {
        options = options || {};
        var legend = this.items.get(2).items.get(0);
        this.selectedStyle = record;
        this.updateStyleRemoveButton();            
        var styleName = record.get("name");
        
        if (this.editable === true) {
            var userStyle = record.get("userStyle");
            if (userStyle.isDefault === true) {
                styleName = "";
            }
            var ruleIdx = legend.rules.indexOf(this.selectedRule);
            // replace the legend
            legend.ownerCt.remove(legend);
            this.createLegend(userStyle.rules, {selectedRuleIndex: ruleIdx});
        }
        if (options.updateCombo === true) {
            // update the combo's value with the new name
            this.items.get(0).items.get(0).setValue(userStyle.name);
            options.markModified === true && this.markModified();
        }
    },
    
    /** private: method[addVectorLegend]
     *  :arg rules: ``Array``
     *  :arg options: ``Object``
     *  :return: ``GeoExt.VectorLegend`` the legend that was created
     *
     *  Creates the vector legend for the provided rules and adds it to the
     *  rules fieldset.
     */
    addVectorLegend: function(rules, options) {
        options = Ext.applyIf(options || {}, {enableDD: true});
        
        this.symbolType = options.symbolType;
        if (!this.symbolType) {
            var typeHierarchy = ["Point", "Line", "Polygon"];
            // use the highest symbolizer type of the 1st rule
            highest = 0;
            var symbolizers = rules[0].symbolizers, symbolType;
            for (var i=symbolizers.length-1; i>=0; i--) {
                symbolType = symbolizers[i].CLASS_NAME.split(".").pop();
                highest = Math.max(highest, typeHierarchy.indexOf(symbolType));
            }
            this.symbolType = typeHierarchy[highest];
        }
        var legend = this.items.get(2).add({
            xtype: "gx_vectorlegend",
            showTitle: false,
            height: rules.length > 10 ? 250 : undefined,
            autoScroll: rules.length > 10,
            rules: rules,
            symbolType: this.symbolType,
            selectOnClick: true,
            enableDD: options.enableDD,
            listeners: {
                "ruleselected": function(cmp, rule) {
                    this.selectedRule = rule;
                    // enable the Remove, Edit and Duplicate buttons
                    var tbItems = this.items.get(3).items;
                    this.updateRuleRemoveButton();
                    tbItems.get(2).enable();
                    tbItems.get(3).enable();
                },
                "ruleunselected": function(cmp, rule) {
                    this.selectedRule = null;
                    // disable the Remove, Edit and Duplicate buttons
                    var tbItems = this.items.get(3).items;
                    tbItems.get(1).disable();
                    tbItems.get(2).disable();
                    tbItems.get(3).disable();
                },
                "rulemoved": function() {
                    this.markModified();
                },
                "afterlayout": function() {
                    // restore selection
                    //TODO QA: avoid accessing private properties/methods
                    if (this.selectedRule !== null &&
                            legend.selectedRule === null &&
                            legend.rules.indexOf(this.selectedRule) !== -1) {
                        legend.selectRuleEntry(this.selectedRule);
                    }
                },
                scope: this
            }
        });
        this.setRulesFieldSetVisible(true);
        return legend;
    },
    
    newStyleName: function() {
        var layerName = this.layerRecord.get("name");
        return layerName.split(":").pop() + "_" +
            gxp.util.md5(layerName + new Date() + Math.random()).substr(0, 8);
    },
    
    /** private: method[showDlg]
     *  :arg dlg:
     *
     *  Shows a subdialog
     */
    showDlg: function(dlg) {
        dlg.show();
    }
    
});

/** api: function[createGeoServerStylerConfig]
 *  :arg layerRecord: ``GeoExt.data.LayerRecord`` Layer record to configure the
 *      dialog for.
 *  :arg url: ``String`` Optional. Custaom URL for the GeoServer REST endpoint
 *      for writing styles.
 *
 *  Creates a configuration object for a :class:`gxp.WMSStylesDialog` with a
 *  :class:`gxp.plugins.GeoServerStyleWriter` plugin and listeners for the
 *  "styleselected", "modified" and "saved" events that take care of saving
 *  styles and keeping the layer view updated.
 */
gxp.WMSStylesDialog.createGeoServerStylerConfig = function(layerRecord, url) {
    var layer = layerRecord.getLayer();
    if (!url) {
        url = layerRecord.get("restUrl");
    }
    if (!url) {
        url = layer.url.split("?").shift().replace(/\/(wms|ows)\/?$/, "/rest");
    }
    return {
        xtype: "gxp_wmsstylesdialog",
        layerRecord: layerRecord,
        plugins: [{
            ptype: "gxp_geoserverstylewriter",
            baseUrl: url
        }],
        listeners: {
            "styleselected": function(cmp, style) {
                layer.mergeNewParams({
                    styles: style
                });
            },
            "modified": function(cmp, style) {
                cmp.saveStyles();
            },
            "saved": function(cmp, style) {
                layer.mergeNewParams({
                    _olSalt: Math.random(),
                    styles: style
                });
            },
            scope: this
        }
    };
};

// set SLD defaults for symbolizer
OpenLayers.Renderer.defaultSymbolizer = {
    fillColor: "#808080",
    fillOpacity: 1,
    strokeColor: "#000000",
    strokeOpacity: 1,
    strokeWidth: 1,
    strokeDashstyle: "solid",
    pointRadius: 3,
    graphicName: "square",
    fontColor: "#000000",
    fontSize: 10,
    haloColor: "#FFFFFF",
    haloOpacity: 1,
    haloRadius: 1,
    labelAlign: 'cm'
};

/** api: xtype = gxp_wmsstylesdialog */
Ext.reg('gxp_wmsstylesdialog', gxp.WMSStylesDialog);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp
 *  class = NewSourceDialog
 *  base_link = `Ext.Panel <http://extjs.com/deploy/dev/docs/?class=Ext.Container>`_
 */
Ext.namespace("gxp");

/** api: constructor
 * .. class:: gxp.NewSourceDialog(config)
 *
 *     An Ext.Panel with some defaults that better lend themselves toward use 
 *     as a quick query to get a service URL from a user.
 *
 */
gxp.NewSourceDialog = Ext.extend(Ext.Panel, {

    /** api: config[title]
     *  ``String``
     *  Dialog title (i18n).
     */
    title: "Add New Server...",

    /** api: config[cancelText]
     *  ``String``
     *  Text for cancel button (i18n).
     */
    cancelText: "Cancel",
    
    /** api: config[addServerText]
     *  ``String``
     *  Text for add server button (i18n).
     */
    addServerText: "Add Server",
    
    /** api: config[invalidURLText]
     *  ``String``
     *  Message to display when an invalid URL is entered (i18n).
     */
    invalidURLText: "Enter a valid URL to a WMS/TMS/REST endpoint (e.g. http://example.com/geoserver/wms)",

    /** api: config[contactingServerText]
     *  ``String``
     *  Text for server contact (i18n).
     */
    contactingServerText: "Contacting Server...",
    
    /** api: config[bodyStyle]
     * The default bodyStyle sets the padding to 0px
     */
    bodyStyle: "padding: 0px",

    /** api: property[error]
     * ``String``
     * The error message set (for example, when adding the source failed)
     */
    error: null,

    /** api: event[urlselected]
     *  Fired with a reference to this instance, the URL that the user
     *  provided and the type of service  as a parameters when the form is submitted.
     */     
     
    /** private: method[initComponent]
     */
    initComponent: function() {

        this.addEvents("urlselected");

        this.urlTextField = new Ext.form.TextField({
            fieldLabel: "URL",
            allowBlank: false,
            width: 240,
            msgTarget: "under",
            validator: this.urlValidator.createDelegate(this),
            listeners: {
                specialkey: function(f, e) {
                    if (e.getKey() === e.ENTER) {
                        this.addServer();
                    }
                },
                scope: this
            }
        });

        this.form = new Ext.form.FormPanel({
            items: [{
                xtype: 'combo',
                width: 240,
                name: 'type',
                fieldLabel: "Type",
                value: 'WMS',
                mode: 'local',
                triggerAction: 'all',
                store: [
                    ['WMS', 'Web Map Service (WMS)'], 
                    ['TMS', 'Tiled Map Service (TMS)'],
                    ['REST', 'ArcGIS REST Service (REST)']    
                ]
            }, this.urlTextField],
            border: false,
            labelWidth: 30,
            bodyStyle: "padding: 5px",
            autoWidth: true,
            autoHeight: true,
            listeners: {
                afterrender: function() {
                    this.urlTextField.focus(false, true);
                },
                scope: this
            }
        });

        this.bbar = [
            new Ext.Button({
                text: this.cancelText,
                handler: this.hide,
                scope: this
            }),
            new Ext.Toolbar.Fill(),
            new Ext.Button({
                text: this.addServerText,
                iconCls: "add",
                handler: this.addServer,
                scope: this
            })
        ];

        this.items = this.form;

        gxp.NewSourceDialog.superclass.initComponent.call(this);

        this.form.on("render", function() {
            this.loadMask = new Ext.LoadMask(this.form.getEl(), {msg:this.contactingServerText});
        }, this);

        this.on({
            hide: this.reset,
            removed: this.reset,
            scope: this
        });

        this.on("urlselected", function(cmp, url) {
            this.setLoading();
            var failure = function() {
                this.setError(this.sourceLoadFailureMessage);
            };

            // this.explorer.addSource(url, null, success, failure, this);
            this.addSource(url, this.hide, failure, this);
        }, this);

    },
    
    /** private: method[addServer]
     */
    addServer: function() {
        // Clear validation before trying again.
        this.error = null;
        if (this.urlTextField.validate()) {
            this.fireEvent("urlselected", this, this.urlTextField.getValue(),
                this.form.getForm().findField('type').getValue());
        }
    },
    
    /** API: method[reset]
     *  Resets the form and hides any load mask.
     */
    reset: function() {
        // Reset values so it looks right the next time it pops up.
        this.error = null;
        this.urlTextField.reset();
        this.loadMask.hide();
    },
    
    /** private: property[urlRegExp]
     *  `RegExp`
     *
     *  We want to allow protocol or scheme relative URL  
     *  (e.g. //example.com/).  We also want to allow username and 
     *  password in the URL (e.g. http://user:pass@example.com/).
     *  We also want to support virtual host names without a top
     *  level domain (e.g. http://localhost:9080/).  It also makes sense
     *  to limit scheme to http and https.
     *  The Ext "url" vtype does not support any of this.
     *  This doesn't have to be completely strict.  It is meant to help
     *  the user avoid typos.
     */
    urlRegExp: /^(http(s)?:)?\/\/([\w%]+:[\w%]+@)?([^@\/:]+)(:\d+)?\//i,
    
    /** private: method[urlValidator]
     *  :arg url: `String`
     *  :returns: `Boolean` The url looks valid.
     *  
     *  This method checks to see that a user entered URL looks valid.  It also
     *  does form validation based on the `error` property set when a response
     *  is parsed.
     */
    urlValidator: function(url) {
        var valid;
        if (!this.urlRegExp.test(url)) {
            valid = this.invalidURLText;
        } else {
            valid = !this.error || this.error;
        }
        // clear previous error message
        this.error = null;
        return valid;
    },

    /** private: method[setLoading]
     * Visually signify to the user that we're trying to load the service they 
     * requested, for example, by activating a loadmask.
     */
    setLoading: function() {
        this.loadMask.show();
    },

    /** private: method[setError] 
     * :param: error the message to display
     *
     * Display an error message to the user indicating a failure occurred while
     * trying to load the service.
     */
    setError: function(error) {
        this.loadMask.hide();
        this.error = error;
        this.urlTextField.validate();
    },

    /** api: config[addSource]
     * A callback function to be called when the user submits the form in the 
     * NewSourceDialog.
     *
     * TODO this can probably be extracted to an event handler
     */
    addSource: function(url, success, failure, scope) {
    }
});

/** api: xtype = gxp_newsourcedialog */
Ext.reg('gxp_newsourcedialog', gxp.NewSourceDialog);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires widgets/NewSourceDialog.js
 */

/** api: (define)
 *  module = gxp
 *  class = NewSourceWindow
 *  extends = Ext.Window
 */
Ext.namespace("gxp");

//TODO Remove this component when we cut a release

/** api: constructor
 * .. class:: gxp.NewSourceWindow(config)
 *
 *     An Ext.Window with some defaults that better lend themselves toward use 
 *     as a quick query to get a service URL from a user.
 */
gxp.NewSourceWindow = Ext.extend(Ext.Window, {

    /** api: config[bodyStyle]
     * The default bodyStyle sets the padding to 0px
     */
    bodyStyle: "padding: 0px",

    /** api: config[hideBorders]
     *  Defaults to true.
     */
    hideBorders: true,
    
    /** api: config[width]
     * The width defaults to 300
     */
    width: 300,

    /** api: config[closeAction]
     * The default closeAction is 'hide'
     */
    closeAction: 'hide',

    /** api: property[error]
     * ``String``
     * The error message set (for example, when adding the source failed)
     */
    error: null,    

    /** api: event[server-added]
     * Fired with the URL that the user provided as a parameter when the form 
     * is submitted.
     */
    
    initComponent: function() {
        window.setTimeout(function() {
            throw("gxp.NewSourceWindow is deprecated. Use gxp.NewSourceDialog instead.");
        }, 0);
        this.addEvents("server-added");
        gxp.NewSourceWindow.superclass.initComponent.apply(this, arguments);
        this.addEvents("server-added");
        var dialog = this.add(new gxp.NewSourceDialog(Ext.applyIf({
            addSource: this.addSource,
            header: false,
            listeners: {
                urlselected: function(cmp, url) {
                    this.fireEvent("server-added", url);
                }
            }
        }, this.initialConfig)));
        this.setTitle(dialog.title);
        this.setLoading = dialog.setLoading.createDelegate(dialog);
        this.setError = dialog.setError.createDelegate(dialog);
        this.on("hide", dialog.onHide, dialog);
    },
    
    /** api: config[addSource]
     * A callback function to be called when the user submits the form in the 
     * NewSourceWindow.
     *
     * TODO this can probably be extracted to an event handler
     */
    addSource: function(url, success, failure, scope) {
    }
});

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */
 
/**
 * @include widgets/form/ColorField.js
 */

/** api: (define)
 *  module = gxp
 *  class = FillSymbolizer
 *  base_link = `Ext.FormPanel <http://extjs.com/deploy/dev/docs/?class=Ext.FormPanel>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: FillSymbolizer(config)
 *   
 *      Form for configuring a symbolizer fill.
 */
gxp.FillSymbolizer = Ext.extend(Ext.FormPanel, {
    
    /** api: config[symbolizer]
     *  ``Object``
     *  A symbolizer object that will be used to fill in form values.
     *  This object will be modified when values change.  Clone first if
     *  you do not want your symbolizer modified.
     */
    symbolizer: null,

    /** api: config[colorProperty]
     *  ``String`` The property that should be set on the symbolizer to
     *  represent the fill color. Defaults to fillColor. But can also be
     *  set to fontColor for labels.
     */
    colorProperty: "fillColor",

    /** api: config[opacityProperty]
     *  ``String`` The property that should be set on the symbolizer to
     *  represent the fill opacity. Defaults to fillOpacity. But can also be
     *  set to fontOpacity for labels.
     */
    opacityProperty: "fillOpacity",
    
    /** api: config[colorManager]
     *  ``Function``
     *  Optional color manager constructor to be used as a plugin for the color
     *  field.
     */
    colorManager: null,
    
    /** api: config[checkboxToggle]
     *  ``Boolean`` Set to false if the "Fill" fieldset should not be
     *  toggleable. Default is true.
     */
    checkboxToggle: true,
    
    /** api: config[defaultColor]
     *  ``String`` Default background color for the Color field. This
     *  color will be displayed when no fillColor value for the symbolizer
     *  is available. Defaults to the ``fillColor`` property of
     *  ``OpenLayers.Renderer.defaultSymbolizer``.
     */
    defaultColor: null,

    border: false,
    
    /** i18n */
    fillText: "Fill",
    colorText: "Color",
    opacityText: "Opacity",
    
    initComponent: function() {
        
        if(!this.symbolizer) {
            this.symbolizer = {};
        }
        
        var colorFieldPlugins;
        if (this.colorManager) {
            colorFieldPlugins = [new this.colorManager()];
        }

        var sliderValue = 100;
        if (this.opacityProperty in this.symbolizer) {
            sliderValue = this.symbolizer[this.opacityProperty]*100;
        }
        else if (OpenLayers.Renderer.defaultSymbolizer[this.opacityProperty]) {
            sliderValue = OpenLayers.Renderer.defaultSymbolizer[this.opacityProperty]*100;
        }
        
        this.items = [{
            xtype: "fieldset",
            title: this.fillText,
            autoHeight: true,
            checkboxToggle: this.checkboxToggle,
            collapsed: this.checkboxToggle === true &&
                this.symbolizer.fill === false,
            hideMode: "offsets",
            defaults: {
                width: 100 // TODO: move to css
            },
            items: [{
                xtype: "gxp_colorfield",
                fieldLabel: this.colorText,
                name: "color",
                emptyText: OpenLayers.Renderer.defaultSymbolizer[this.colorProperty],
                value: this.symbolizer[this.colorProperty],
                defaultBackground: this.defaultColor ||
                    OpenLayers.Renderer.defaultSymbolizer[this.colorProperty],
                plugins: colorFieldPlugins,
                listeners: {
                    valid: function(field) {
                        var newValue = field.getValue();
                        var modified = this.symbolizer[this.colorProperty] != newValue; 
                        this.symbolizer[this.colorProperty] = newValue;
                        modified && this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                }
            }, {
                xtype: "slider",
                fieldLabel: this.opacityText,
                name: "opacity",
                values: [sliderValue],
                isFormField: true,
                listeners: {
                    changecomplete: function(slider, value) {
                        this.symbolizer[this.opacityProperty] = value / 100;
                        this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                },
                plugins: [
                    new GeoExt.SliderTip({
                        getText: function(thumb) {
                            return thumb.value + "%";
                        }
                    })
                ]
            }],
            listeners: {
                "collapse": function() {
                    if (this.symbolizer.fill !== false) {
                        this.symbolizer.fill = false;
                        this.fireEvent("change", this.symbolizer);
                    }
                },
                "expand": function() {
                    this.symbolizer.fill = true;
                    this.fireEvent("change", this.symbolizer);
                },
                scope: this
            }
        }];

        this.addEvents(
            /**
             * Event: change
             * Fires before any field blurs if the field value has changed.
             *
             * Listener arguments:
             * symbolizer - {Object} A symbolizer with fill related properties
             *     updated.
             */
            "change"
        ); 

        gxp.FillSymbolizer.superclass.initComponent.call(this);
        
    }
    
    
});

/** api: xtype = gxp_fillsymbolizer */
Ext.reg('gxp_fillsymbolizer', gxp.FillSymbolizer);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @include widgets/form/ColorField.js
 */

/** api: (define)
 *  module = gxp
 *  class = StrokeSymbolizer
 *  base_link = `Ext.FormPanel <http://extjs.com/deploy/dev/docs/?class=Ext.FormPanel>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: StrokeSymbolizer(config)
 *   
 *      Form for configuring a symbolizer stroke.
 */
gxp.StrokeSymbolizer = Ext.extend(Ext.FormPanel, {
    
    /* i18n */
    solidStrokeName: "solid",
    dashStrokeName: "dash",
    dotStrokeName: "dot",
    titleText: "Stroke",
    styleText: "Style",
    colorText: "Color",
    widthText: "Width",
    opacityText: "Opacity",
    /* ~i18n */
    
    /** api: config[symbolizer]
     *  ``Object``
     *  A symbolizer object that will be used to fill in form values.
     *  This object will be modified when values change.  Clone first if
     *  you do not want your symbolizer modified.
     */
    symbolizer: null,
    
    /** api: config[colorManager]
     *  ``Function``
     *  Optional color manager constructor to be used as a plugin for the color
     *  field.
     */
    colorManager: null,
    
    /** api: config[checkboxToggle]
     *  ``Boolean`` Set to false if the "Fill" fieldset should not be
     *  toggleable. Default is true.
     */
    checkboxToggle: true,
    
    /** api: config[defaultColor]
     *  ``String`` Default background color for the Color field. This
     *  color will be displayed when no strokeColor value for the symbolizer
     *  is available. Defaults to the ``strokeColor`` property of
     *  ``OpenLayers.Renderer.defaultSymbolizer``.
     */
    defaultColor: null,

    /** api: config[dashStyles]
     *  ``Array(Array)``
     *  A list of [value, name] pairs for stroke dash styles.
     *  The first item in each list is the value and the second is the
     *  display name.  Default is [["solid", "solid"], ["2 4", "dash"],
     *  ["1 4", "dot"]].
     */
    dashStyles: null,
    
    border: false,
    
    initComponent: function() {
        
        this.dashStyles = this.dashStyles || [["solid", this.solidStrokeName], ["4 4", this.dashStrokeName], ["2 4", this.dotStrokeName]];
        
        if(!this.symbolizer) {
            this.symbolizer = {};
        }
        
        var colorFieldPlugins;
        if (this.colorManager) {
            colorFieldPlugins = [new this.colorManager];
        }

        this.items = [{
            xtype: "fieldset",
            title: this.titleText,
            autoHeight: true,
            checkboxToggle: this.checkboxToggle,
            collapsed: this.checkboxToggle === true &&
                this.symbolizer.stroke === false,
            hideMode: "offsets",
            defaults: {
                width: 100 // TODO: move to css
            },
            items: [{
                xtype: "combo",
                name: "style",
                fieldLabel: this.styleText,
                store: new Ext.data.SimpleStore({
                    data: this.dashStyles,
                    fields: ["value", "display"]
                }),
                displayField: "display",
                valueField: "value",
                value: this.getDashArray(this.symbolizer.strokeDashstyle) || OpenLayers.Renderer.defaultSymbolizer.strokeDashstyle,
                mode: "local",
                allowBlank: true,
                triggerAction: "all",
                editable: false,
                listeners: {
                    select: function(combo, record) {
                        this.symbolizer.strokeDashstyle = record.get("value");
                        this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                }
            }, {
                xtype: "gxp_colorfield",
                name: "color",
                fieldLabel: this.colorText,
                emptyText: OpenLayers.Renderer.defaultSymbolizer.strokeColor,
                value: this.symbolizer.strokeColor,
                defaultBackground: this.defaultColor ||
                    OpenLayers.Renderer.defaultSymbolizer.strokeColor,
                plugins: colorFieldPlugins,
                listeners: {
                    valid: function(field) {
                        var newValue = field.getValue();
                        var modified = this.symbolizer.strokeColor != newValue;
                        this.symbolizer.strokeColor = newValue;
                        modified && this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                }
            }, {
                xtype: "numberfield",
                name: "width",
                fieldLabel: this.widthText,
                allowNegative: false,
                emptyText: OpenLayers.Renderer.defaultSymbolizer.strokeWidth,
                value: this.symbolizer.strokeWidth,
                listeners: {
                    change: function(field, value) {
                        value = parseFloat(value);
                        if (isNaN(value)) {
                            delete this.symbolizer.strokeWidth;
                        } else {
                            this.symbolizer.strokeWidth = value;
                        }
                        this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                }
            }, {
                xtype: "slider",
                name: "opacity",
                fieldLabel: this.opacityText,
                values: [(("strokeOpacity" in this.symbolizer) ? this.symbolizer.strokeOpacity : OpenLayers.Renderer.defaultSymbolizer.strokeOpacity) * 100],
                isFormField: true,
                listeners: {
                    changecomplete: function(slider, value) {
                        this.symbolizer.strokeOpacity = value / 100;
                        this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                },
                plugins: [
                    new GeoExt.SliderTip({
                        getText: function(thumb) {
                            return thumb.value + "%";
                        }
                    })
                ]
            }],
            listeners: {
                "collapse": function() {
                    if (this.symbolizer.stroke !== false) {
                        this.symbolizer.stroke = false;
                        this.fireEvent("change", this.symbolizer);
                    }
                },
                "expand": function() {
                    this.symbolizer.stroke = true;
                    this.fireEvent("change", this.symbolizer);
                },
                scope: this
            }
        }];

        this.addEvents(
            /**
             * Event: change
             * Fires before any field blurs if the field value has changed.
             *
             * Listener arguments:
             * symbolizer - {Object} A symbolizer with stroke related properties
             *     updated.
             */
            "change"
        ); 
 
        gxp.StrokeSymbolizer.superclass.initComponent.call(this);
        
    },

    getDashArray: function(style) {
        var array;
        if (style) {
            var parts = style.split(/\s+/);
            var ratio = parts[0] / parts[1];
            if (!isNaN(ratio)) {
                array = ratio >= 1 ? "4 4" : "2 4";
            }
        }
        return array;
    }
    
    
    
});

/** api: xtype = gxp_strokesymbolizer */
Ext.reg('gxp_strokesymbolizer', gxp.StrokeSymbolizer); 

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** 
 * @include widgets/FillSymbolizer.js
 * @include widgets/StrokeSymbolizer.js
 */

/** api: (define)
 *  module = gxp
 *  class = PointSymbolizer
 *  base_link = `Ext.Panel <http://extjs.com/deploy/dev/docs/?class=Ext.Panel>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: PointSymbolizer(config)
 *   
 *      Form for configuring a point symbolizer.
 */
gxp.PointSymbolizer = Ext.extend(Ext.Panel, {

    /** api: config[symbolizer]
     *  ``Object``
     *  A symbolizer object that will be used to fill in form values.
     *  This object will be modified when values change.  Clone first if
     *  you do not want your symbolizer modified.
     */
    symbolizer: null,
    
    /** i18n */
    graphicCircleText: "circle",
    graphicSquareText: "square",
    graphicTriangleText: "triangle",
    graphicStarText: "star",
    graphicCrossText: "cross",
    graphicXText: "x",
    graphicExternalText: "external",
    urlText: "URL",
    opacityText: "opacity",
    symbolText: "Symbol",
    sizeText: "Size",
    rotationText: "Rotation",
    
    /** api: config[pointGraphics]
     *  ``Array``
     *  A list of objects to be used as the root of the data for a
     *  JsonStore.  These will become records used in the selection of
     *  a point graphic.  If an object in the list has no "value" property,
     *  the user will be presented with an input to provide their own URL
     *  for an external graphic.  By default, names of well-known marks are
     *  provided.  In addition, the default list will produce a record with
     *  display of "external" that create an input for an external graphic
     *  URL.
     *
     * Fields:
     *
     *  * display - ``String`` The name to be displayed to the user.
     *  * preview - ``String`` URL to a graphic for preview.
     *  * value - ``String`` Value to be sent to the server.
     *  * mark - ``Boolean`` The value is a well-known name for a mark.  If
     *      ``false``, the value will be assumed to be a url for an external graphic.
     */
    pointGraphics: null,
    
   /** api: config[colorManager]
     *  ``Function``
     *  Optional color manager constructor to be used as a plugin for the color
     *  field.
     */
    colorManager: null,
    
    /** private: property[external]
     *  ``Boolean``
     *  Currently using an external graphic.
     */
    external: null,
    
    /** private: config[layout]
     *  ``String``
     */
    layout: "form",

    initComponent: function() {
        
        if(!this.symbolizer) {
            this.symbolizer = {};
        }   
        
        if (!this.pointGraphics) {
            this.pointGraphics = [
                {display: this.graphicCircleText, value: "circle", mark: true},
                {display: this.graphicSquareText, value: "square", mark: true},
                {display: this.graphicTriangleText, value: "triangle", mark: true},
                {display: this.graphicStarText, value: "star", mark: true},
                {display: this.graphicCrossText, value: "cross", mark: true},
                {display: this.graphicXText, value: "x", mark: true},
                {display: this.graphicExternalText}
            ];
        }
        
        this.external = !!this.symbolizer["externalGraphic"];

        this.markPanel = new Ext.Panel({
            border: false,
            collapsed: this.external,
            layout: "form",
            items: [{
                xtype: "gxp_fillsymbolizer",
                symbolizer: this.symbolizer,
                labelWidth: this.labelWidth,
                labelAlign: this.labelAlign,
                colorManager: this.colorManager,
                listeners: {
                    change: function(symbolizer) {
                        this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                }
            }, {
                xtype: "gxp_strokesymbolizer",
                symbolizer: this.symbolizer,
                labelWidth: this.labelWidth,
                labelAlign: this.labelAlign,
                colorManager: this.colorManager,
                listeners: {
                    change: function(symbolizer) {
                        this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                }
            }]
        });
        
        this.urlField = new Ext.form.TextField({
            name: "url",
            fieldLabel: this.urlText,
            value: this.symbolizer["externalGraphic"],
            hidden: !this.external,
            listeners: {
                change: function(field, value) {
                    this.symbolizer["externalGraphic"] = value;
                    this.fireEvent("change", this.symbolizer);
                },
                scope: this
            },
            width: 100 // TODO: push this to css
        });
        
        this.graphicPanel = new Ext.Panel({
            border: false,
            collapsed: !this.external,
            layout: "form",
            items: [this.urlField, {
                xtype: "slider",
                name: "opacity",
                fieldLabel: this.opacityText,
                value: [(this.symbolizer["graphicOpacity"] == null) ? 100 : this.symbolizer["graphicOpacity"] * 100],
                isFormField: true,
                listeners: {
                    changecomplete: function(slider, value) {
                        this.symbolizer["graphicOpacity"] = value / 100;
                        this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                },
                plugins: [
                    new GeoExt.SliderTip({
                        getText: function(thumb) {
                            return thumb.value + "%";
                        }
                    })
                ],
                width: 100 // TODO: push this to css                
            }]
        });

        this.items = [{
            xtype: "combo",
            name: "mark",
            fieldLabel: this.symbolText,
            store: new Ext.data.JsonStore({
                data: {root: this.pointGraphics},
                root: "root",
                fields: ["value", "display", "preview", {name: "mark", type: "boolean"}]
            }),
            value: this.external ? 0 : this.symbolizer["graphicName"],
            displayField: "display",
            valueField: "value",
            tpl: new Ext.XTemplate(
                '<tpl for=".">' +
                    '<div class="x-combo-list-item gx-pointsymbolizer-mark-item">' +
                    '<tpl if="preview">' +
                        '<img src="{preview}" alt="{display}"/>' +
                    '</tpl>' +
                    '<span>{display}</span>' +
                '</div></tpl>'
            ),
            mode: "local",
            allowBlank: false,
            triggerAction: "all",
            editable: false,
            listeners: {
                select: function(combo, record) {
                    var mark = record.get("mark");
                    var value = record.get("value");
                    if(!mark) {
                        if(value) {
                            this.urlField.hide();
                            this.symbolizer["externalGraphic"] = value;
                        } else {
                            this.urlField.show();
                        }
                        if(!this.external) {
                            this.external = true;
                            var urlValue = this.urlField.getValue();
                            if (!Ext.isEmpty(urlValue)) {
                                this.symbolizer["externalGraphic"] = urlValue;
                            }
                            delete this.symbolizer["graphicName"];
                            this.updateGraphicDisplay();
                        }
                    } else {
                        if(this.external) {
                            this.external = false;
                            delete this.symbolizer["externalGraphic"];
                            this.updateGraphicDisplay();
                        }
                        this.symbolizer["graphicName"] = value;
                    }
                    this.fireEvent("change", this.symbolizer);
                },
                scope: this
            },
            width: 100 // TODO: push this to css
        }, {
            xtype: "textfield",
            name: "size",
            fieldLabel: this.sizeText,
            value: this.symbolizer["pointRadius"] && this.symbolizer["pointRadius"] * 2,
            listeners: {
                change: function(field, value) {
                    this.symbolizer["pointRadius"] = value / 2;
                    this.fireEvent("change", this.symbolizer);
                },
                scope: this
            },
            width: 100 // TODO: push this to css
        }, {
            xtype: "textfield",
            name: "rotation",
            fieldLabel: this.rotationText,
            value: this.symbolizer["rotation"],
            listeners: {
                change: function(field, value) {
                    this.symbolizer["rotation"] = value;
                    this.fireEvent("change", this.symbolizer);
                },
                scope: this
            },
            width: 100 // TODO: push this to css
        }, this.markPanel, this.graphicPanel
        ];

        this.addEvents(
            /**
             * Event: change
             * Fires before any field blurs if the field value has changed.
             *
             * Listener arguments:
             * symbolizer - {Object} A symbolizer with stroke related properties
             *     updated.
             */
            "change"
        ); 

        gxp.PointSymbolizer.superclass.initComponent.call(this);

    },
    
    updateGraphicDisplay: function() {
        if(this.external) {
            this.markPanel.collapse();
            this.graphicPanel.expand();
        } else {
            this.graphicPanel.collapse();
            this.markPanel.expand();
        }
        // TODO: window shadow fails to sync
    }
    
    
});

/** api: xtype = gxp_pointsymbolizer */
Ext.reg('gxp_pointsymbolizer', gxp.PointSymbolizer);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp
 *  class = LayerUploadPanel
 *  base_link = `Ext.FormPanel <http://extjs.com/deploy/dev/docs/?class=Ext.FormPanel>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: LayerUploadPanel(config)
 *   
 *      A panel for uploading new layer data to GeoServer.
 */
gxp.LayerUploadPanel = Ext.extend(Ext.FormPanel, {
    
    /** i18n */
    titleLabel: "Title",
    titleEmptyText: "Layer title",
    abstractLabel: "Description",
    abstractEmptyText: "Layer description",
    fileLabel: "Data",
    fieldEmptyText: "Browse for data archive...",
    uploadText: "Upload",
    uploadFailedText: "Upload failed",
    processingUploadText: "Processing upload...",
    waitMsgText: "Uploading your data...",
    invalidFileExtensionText: "File extension must be one of: ",
    optionsText: "Options",
    workspaceLabel: "Workspace",
    workspaceEmptyText: "Default workspace",
    dataStoreLabel: "Store",
    dataStoreEmptyText: "Choose a store",
    dataStoreNewText: "Create new store",
    crsLabel: "CRS",
    crsEmptyText: "Coordinate Reference System ID",
    invalidCrsText: "CRS identifier should be an EPSG code (e.g. EPSG:4326)",
    
    /** private: property[fileUpload]
     *  ``Boolean``
     */
    fileUpload: true,
    
    /** api: config[validFileExtensions]
     *  ``Array``
     *  List of valid file extensions.  These will be used in validating the 
     *  file input value.  Default is ``[".zip", ".tif", ".tiff", ".gz", ".tar.bz2", 
     *  ".tar", ".tgz", ".tbz2"]``.
     */
    validFileExtensions: [".zip", ".tif", ".tiff", ".gz", ".tar.bz2", ".tar", ".tgz", ".tbz2"],
    
    /** api: config[url]
     *  ``String``
     *  URL for GeoServer RESTConfig root.  E.g. "http://example.com/geoserver/rest".
     */

    /** private: property[defaultDataStore]
     *  ``string``
     */
    defaultDataStore: null,
    
    /** private: method[constructor]
     */
    constructor: function(config) {
        // Allow for a custom method to handle upload responses.
        config.errorReader = {
            read: config.handleUploadResponse || this.handleUploadResponse.createDelegate(this)
        };
        gxp.LayerUploadPanel.superclass.constructor.call(this, config);
    },
    
    /** private: property[selectedWorkspace]
     *  {Ext.data.Record}
     */
    selectedWorkspace: null,
    
    /** private: method[initComponent]
     */
    initComponent: function() {
        
        this.items = [{
            xtype: "textfield",
            name: "title",
            fieldLabel: this.titleLabel,
            emptyText: this.titleEmptyText,
            allowBlank: true
        }, {
            xtype: "textarea",
            name: "abstract",
            fieldLabel: this.abstractLabel,
            emptyText: this.abstractEmptyText,
            allowBlank: true
        }, {
            xtype: "fileuploadfield",
            id: "file",
            anchor: "90%",
            emptyText: this.fieldEmptyText,
            fieldLabel: this.fileLabel,
            name: "file",
            buttonText: "",
            buttonCfg: {
                iconCls: "gxp-icon-filebrowse"
            },
            listeners: {
                "fileselected": function(cmp, value) {
                    // remove the path from the filename - avoids C:/fakepath etc.
                    cmp.setValue(value.split(/[/\\]/).pop());
                }
            },
            validator: this.fileNameValidator.createDelegate(this)
        }, {
            xtype: "fieldset",
            ref: "optionsFieldset",
            title: this.optionsText,
            checkboxToggle: true,
            collapsed: true,
            hidden: this.workspace != undefined && this.store != undefined && this.crs != undefined,
            hideMode: "offsets",
            defaults: {
                anchor: "97%"
            },
            items: [
                this.createWorkspacesCombo(),
                this.createDataStoresCombo(),
                {
                    xtype: "textfield",
                    name: "nativeCRS",
                    // anchor: "90%",
                    fieldLabel: this.crsLabel,
                    emptyText: this.crsEmptyText,
                    allowBlank: true,
                    regex: /^epsg:\d+$/i,
                    regexText: this.invalidCrsText
                }
            ],
            listeners: {
                collapse: function(fieldset) {
                    // reset all combos
                    fieldset.items.each(function(item) {
                        item.reset();
                    });
                }
            }
        }];
        
        this.buttons = [{
            text: this.uploadText,
            handler: function() {
                var form = this.getForm();
                if (form.isValid()) {
                    var fields = form.getFieldValues(),
                        jsonData = {'import': {}};
                    if (fields.workspace) {
                        jsonData["import"].targetWorkspace = {workspace: {name: fields.workspace}};
                    }
                    if (Ext.isEmpty(fields.store) && this.defaultDataStore) {
                        jsonData["import"].targetStore = {dataStore: {name: this.defaultDataStore}};
                    } else if (!Ext.isEmpty(fields.store) && fields.store !== this.dataStoreNewText) {
                        jsonData["import"].targetStore = {dataStore: {name: fields.store}};
                    }
                    Ext.Ajax.request({
                        url: this.getUploadUrl(),
                        method: "POST",
                        jsonData: jsonData,
                        success: function(response) {
                            this._import = response.getResponseHeader("Location");
                            this.optionsFieldset.expand();
                            form.submit({
                                url: this._import + "/tasks?expand=all",
                                waitMsg: this.waitMsgText,
                                waitMsgTarget: true,
                                reset: true,
                                scope: this
                            });
                        },
                        scope: this
                    });
                }
            },
            scope: this
        }];
        
        this.addEvents(
            /**
             * Event: workspaceselected
             * Fires when a workspace is selected.
             *
             * Listener arguments:
             * panel - {<gxp.LayerUploadPanel} This form panel.
             * record - {Ext.data.Record} The selected workspace record.
             */
            "workspaceselected",

            /**
             * Event: datastoreselected
             * Fires when a datastore is selected.
             *
             * Listener arguments:
             * panel - {<gxp.LayerUploadPanel} This form panel.
             * record - {Ext.data.Record} The selected datastore record.
             */
            "datastoreselected",

            /**
             * Event: uploadcomplete
             * Fires upon successful upload.
             *
             * Listener arguments:
             * panel - {<gxp.LayerUploadPanel} This form panel.
             * details - {Object} An object with an "import" property,
             *     representing a summary of the import result as provided by
             *     GeoServer's Importer API.
             */
            "uploadcomplete"
        );
        
        this.getDefaultDataStore('default');

        gxp.LayerUploadPanel.superclass.initComponent.call(this);

    },
    
    /** private: method[fileNameValidator]
     *  :arg name: ``String`` The chosen filename.
     *  :returns: ``Boolean | String``  True if valid, message otherwise.
     */
    fileNameValidator: function(name) {
        var valid = false;
        var ext, len = name.length;
        for (var i=0, ii=this.validFileExtensions.length; i<ii; ++i) {
            ext = this.validFileExtensions[i];
            if (name.slice(-ext.length).toLowerCase() === ext) {
                valid = true;
                break;
            }
        }
        return valid || this.invalidFileExtensionText + '<br/>' + this.validFileExtensions.join(", ");
    },

    /** private: method[createWorkspacesCombo]
     *  :returns: ``Object`` Combo config.
     */
    createWorkspacesCombo: function() {
        return {
            xtype: "combo",
            name: "workspace",
            ref: "../workspace",
            fieldLabel: this.workspaceLabel,
            store: new Ext.data.JsonStore({
                url: this.getWorkspacesUrl(),
                autoLoad: true,
                root: "workspaces.workspace",
                fields: ["name", "href"]
            }),
            displayField: "name",
            valueField: "name",
            mode: "local",
            allowBlank: true,
            triggerAction: "all",
            forceSelection: true,
            listeners: {
                select: function(combo, record, index) {
                    this.getDefaultDataStore(record.get('name'));
                    this.fireEvent("workspaceselected", this, record);
                },
                scope: this
            }
        };
    },
    
    /** private: method[createDataStoresCombo]
     *  :returns: ``Ext.form.ComboBox``
     */
    createDataStoresCombo: function() {
        // this store will be loaded whenever a workspace is selected
        var store = new Ext.data.JsonStore({
            autoLoad: false,
            root: "dataStores.dataStore",
            fields: ["name", "href"]
        });
        this.on({
            workspaceselected: function(panel, record) {
                combo.reset();
                var workspaceUrl = record.get("href");
                store.removeAll();
                store.proxy = new Ext.data.HttpProxy({
                    url: workspaceUrl.split(".json").shift() + "/datastores.json"
                });
                store.proxy.on('loadexception', addDefault, this);
                store.load();
            },
            scope: this
        });

        var addDefault = function() {
            var defaultData = {
                name: this.dataStoreNewText
            };
            var r = new store.recordType(defaultData);
            store.insert(0, r);
            store.proxy && store.proxy.un('loadexception', addDefault, this);
        };

        store.on('load', addDefault, this);

        var combo = new Ext.form.ComboBox({
            name: "store",
            ref: "../dataStore",
            emptyText: this.dataStoreEmptyText,
            fieldLabel: this.dataStoreLabel,
            store: store,
            displayField: "name",
            valueField: "name",
            mode: "local",
            allowBlank: true,
            triggerAction: "all",
            forceSelection: true,
            listeners: {
                select: function(combo, record, index) {
                    this.fireEvent("datastoreselected", this, record);
                },
                scope: this
            }
        });
        
        return combo;
    },

    getDefaultDataStore: function(workspace) {
        Ext.Ajax.request({
            url: this.url + '/workspaces/' + workspace + '/datastores/default.json',
            callback: function(options, success, response) {
                this.defaultDataStore = null;
                if (response.status === 200) {
                    var json = Ext.decode(response.responseText);
                    if (workspace === 'default' && json.dataStore && json.dataStore.workspace) {
                        this.workspace.setValue(json.dataStore.workspace.name);
                        var store = this.workspace.store;
                        var data = {
                            name: json.dataStore.workspace.name,
                            href: json.dataStore.workspace.href
                        };
                        var r = new store.recordType(data);
                        this.fireEvent("workspaceselected", this, r);
                    }
                    //TODO Revisit this logic - currently we assume that stores
                    // with the substring "file" in the type are file based,
                    // and for file-based data stores we want to crate a new
                    // store.
                    if (json.dataStore && json.dataStore.enabled === true && !/file/i.test(json.dataStore.type)) {
                        this.defaultDataStore = json.dataStore.name;
                        this.dataStore.setValue(this.defaultDataStore);
                    }
                }
            },
            scope: this
        });
    },

    /** private: method[getUploadUrl]
     */
    getUploadUrl: function() {
        return this.url + "/imports";
    },
    
    /** private: method[getWorkspacesUrl]
     */
    getWorkspacesUrl: function() {
        return this.url + "/workspaces.json";
    },
    
    /** private: method[handleUploadResponse]
     *  TODO: if response includes errors object, this can be removed
     *  Though it should only be removed if the server always returns text/html!
     */
    handleUploadResponse: function(response) {
        var obj = this.parseResponseText(response.responseText),
            records, tasks, task, msg, i,
            formData = this.getForm().getFieldValues(),
            success = !!obj;
        if (obj) {
            if (typeof obj === "string") {
                success = false;
                msg = obj;
            } else {
                tasks = obj.tasks || [obj.task];
                if (tasks.length === 0) {
                    success = false;
                    msg = "Upload contains no suitable files.";
                } else {
                    for (i=tasks.length-1; i>=0; --i) {
                        task = tasks[i];
                        if (!task) {
                            success = false;
                            msg = "Unknown upload error";
                        } else if (task.state === 'NO_FORMAT') {
                            success = false;
                            msg = "Upload contains no suitable files.";
                        } else if (task.state === 'NO_CRS' && !formData.nativeCRS) {
                            success = false;
                            msg = "Coordinate Reference System (CRS) of source file " + task.data.file + " could not be determined. Please specify manually.";
                        }
                    }
                }
            }
        }
        if (!success) {
            // mark the file field as invlid
            records = [{data: {id: "file", msg: msg || this.uploadFailedText}}];
        } else {
            var itemModified = !!(formData.title || formData["abstract"] || formData.nativeCRS);
            // do not do this for coverages see https://github.com/boundlessgeo/suite/issues/184
            if (itemModified && tasks[0].target.dataStore) {
                this.waitMsg = new Ext.LoadMask((this.ownerCt || this).getEl(), {msg: this.processingUploadText});
                this.waitMsg.show();
                // for now we only support a single task
                var payload = {
                    title: formData.title || undefined,
                    "abstract": formData["abstract"] || undefined,
                    srs: formData.nativeCRS || undefined
                };
                Ext.Ajax.request({
                    method: "PUT",
                    url: tasks[0].layer.href,
                    jsonData: payload,
                    success: this.finishUpload,
                    failure: function(response) {
                        if (this.waitMsg) {
                            this.waitMsg.hide();
                        }
                        var errors = [];
                        try {
                            var json = Ext.decode(response.responseText);
                            if (json.errors) {
                                for (var i=0, ii=json.errors.length; i<ii; ++i) {
                                    errors.push({
                                        id: ~json.errors[i].indexOf('SRS') ? 'nativeCRS' : 'file',
                                        msg: json.errors[i]
                                    });
                                }
                            }
                        } catch(e) {
                            errors.push({
                                id: "file",
                                msg: response.responseText
                            });
                        }
                        this.getForm().markInvalid(errors);
                    },
                    scope: this
                });
            } else {
                this.finishUpload();
            }
        }
        // always return unsuccessful - we manually reset the form in callbacks
        return {success: false, records: records};
    },
    
    finishUpload: function() {
        Ext.Ajax.request({
            method: "POST",
            url: this._import,
            failure: this.handleFailure,
            success: this.handleUploadSuccess,
            scope: this
        });
    },
    
    /** private: parseResponseText
     *  :arg text: ``String``
     *  :returns:  ``Object``
     *
     *  Parse the response text.  Assuming a JSON string but allowing for a 
     *  string wrapped in a <pre> element (given non text/html response type).
     */
    parseResponseText: function(text) {
        var obj;
        try {
            obj = Ext.decode(text);
        } catch (err) {
            // if response type was text/plain, the text will be wrapped in a <pre>
            var match = text.match(/^\s*<pre[^>]*>(.*)<\/pre>\s*/);
            if (match) {
                try {
                    obj = Ext.decode(match[1]);
                } catch (err) {
                    obj = match[1];
                }
            }
        }
        return obj;
    },
    
    /** private: method[handleUploadSuccess]
     */
    handleUploadSuccess: function(response) {
        Ext.Ajax.request({
            method: "GET",
            url: this._import + '?expand=all',
            failure: this.handleFailure,
            success: function(response) {
                if (this.waitMsg) {
                    this.waitMsg.hide();
                }
                this.getForm().reset();
                var details = Ext.decode(response.responseText);
                this.fireEvent("uploadcomplete", this, details);
                delete this._import;
            },
            scope: this
        });
    },
    
    /** private: method[handleFailure]
     */
    handleFailure: function(response) {
        // see http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
        if (response && response.status === 1223) {
            this.handleUploadSuccess(response);
        } else {
            if (this.waitMsg) {
                this.waitMsg.hide();
            }
            this.getForm().markInvalid([{file: this.uploadFailedText}]);
        }
    }

});

/** api: xtype = gxp_layeruploadpanel */
Ext.reg("gxp_layeruploadpanel", gxp.LayerUploadPanel);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @include widgets/StrokeSymbolizer.js
 */

/** api: (define)
 *  module = gxp
 *  class = LineSymbolizer
 *  base_link = `Ext.Panel <http://extjs.com/deploy/dev/docs/?class=Ext.Panel>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: LineSymbolizer(config)
 *   
 *      Form for configuring a line symbolizer.
 */
gxp.LineSymbolizer = Ext.extend(Ext.Panel, {

    /** api: config[symbolizer]
     *  ``Object``
     *  A symbolizer object that will be used to fill in form values.
     *  This object will be modified when values change.  Clone first if
     *  you do not want your symbolizer modified.
     */
    symbolizer: null,

    initComponent: function() {
        
        this.items = [{
            xtype: "gxp_strokesymbolizer",
            symbolizer: this.symbolizer,
            listeners: {
                change: function(symbolizer) {
                    this.fireEvent("change", this.symbolizer);
                },
                scope: this
            }
        }];

        this.addEvents(
            /**
             * Event: change
             * Fires before any field blurs if the field value has changed.
             *
             * Listener arguments:
             * symbolizer - {Object} A symbolizer with stroke related properties
             *     updated.
             */
            "change"
        ); 

        gxp.LineSymbolizer.superclass.initComponent.call(this);

    }
    
    
});

/** api: xtype = gxp_linesymbolizer */
Ext.reg('gxp_linesymbolizer', gxp.LineSymbolizer);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** 
 * @include widgets/FillSymbolizer.js
 * @include widgets/StrokeSymbolizer.js
 */

/** api: (define)
 *  module = gxp
 *  class = PolygonSymbolizer
 *  base_link = `Ext.Panel <http://extjs.com/deploy/dev/docs/?class=Ext.Panel>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: PolygonSymbolizer(config)
 *   
 *      Form for configuring a polygon symbolizer.
 */
gxp.PolygonSymbolizer = Ext.extend(Ext.Panel, {

    /** api: config[symbolizer]
     *  ``Object``
     *  A symbolizer object that will be used to fill in form values.
     *  This object will be modified when values change.  Clone first if
     *  you do not want your symbolizer modified.
     */
    symbolizer: null,

    initComponent: function() {
        
        this.items = [{
            xtype: "gxp_fillsymbolizer",
            symbolizer: this.symbolizer,
            listeners: {
                change: function(symbolizer) {
                    this.fireEvent("change", this.symbolizer);
                },
                scope: this
            }
        }, {
            xtype: "gxp_strokesymbolizer",
            symbolizer: this.symbolizer,
            listeners: {
                change: function(symbolizer) {
                    this.fireEvent("change", this.symbolizer);
                },
                scope: this
            }
        }];

        this.addEvents(
            /**
             * Event: change
             * Fires before any field blurs if the field value has changed.
             *
             * Listener arguments:
             * symbolizer - {Object} A symbolizer with stroke related properties
             *     updated.
             */
            "change"
        ); 

        gxp.PolygonSymbolizer.superclass.initComponent.call(this);

    }
    
    
});

/** api: xtype = gxp_linesymbolizer */
Ext.reg('gxp_polygonsymbolizer', gxp.PolygonSymbolizer);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @include widgets/ScaleLimitPanel.js
 * @include widgets/TextSymbolizer.js
 * @include widgets/PolygonSymbolizer.js
 * @include widgets/LineSymbolizer.js
 * @include widgets/PointSymbolizer.js
 * @include widgets/FilterBuilder.js
 */

/** api: (define)
 *  module = gxp
 *  class = RulePanel
 *  base_link = `Ext.TabPanel <http://extjs.com/deploy/dev/docs/?class=Ext.TabPanel>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: RulePanel(config)
 *   
 *      Create a panel for assembling SLD rules.
 */
gxp.RulePanel = Ext.extend(Ext.TabPanel, {
    
    /** api: property[fonts]
     *  ``Array(String)`` List of fonts for the font combo.  If not set,
     *      defaults  to the list provided by the <Styler.FontComboBox>.
     */
    fonts: undefined,

    /** api: property[symbolType]
     *  ``String`` One of "Point", "Line", or "Polygon".  If no rule is 
     *  provided, default is "Point".
     */
    symbolType: "Point",

    /** api: config[rule]
     *  ``OpenLayers.Rule`` Optional rule provided in the initial
     *  configuration.  If a rule is provided and no `symbolType` is provided,
     *  the symbol type will be derived from the first symbolizer found in the
     *  rule.
     */
    rule: null,
    
    /** private: property[attributes]
     *  ``GeoExt.data.AttributeStore`` A configured attributes store for use
     *  in the filter property combo.
     */
    attributes: null,
    
    /** private: property[pointGraphics]
     *  ``Array`` A list of objects to be used as the root of the data for a
     *  JsonStore.  These will become records used in the selection of
     *  a point graphic.  If an object in the list has no "value" property,
     *  the user will be presented with an input to provide their own URL
     *  for an external graphic.  By default, names of well-known marks are
     *  provided.  In addition, the default list will produce a record with
     *  display of "external" that create an input for an external graphic
     *  URL.
     *
     *  Fields:
     * 
     *  * display - ``String`` The name to be displayed to the user.
     *  * preview - ``String`` URL to a graphic for preview.
     *  * value - ``String`` Value to be sent to the server.
     *  * mark - ``Boolean`` The value is a well-known name for a mark.  If
     *    false, the value will be assumed to be a url for an external graphic.
     */

    /** private: property[nestedFilters]
     *  ``Boolean`` Allow addition of nested logical filters.  This sets the
     *  allowGroups property of the filter builder.  Default is true.
     */
    nestedFilters: true,
    
    /** private: property[minScaleDenominatorLimit]
     *  ``Number`` Lower limit for scale denominators.  Default is what you get
     *  when  you assume 20 zoom levels starting with the world in Spherical
     *  Mercator on a single 256 x 256 tile at zoom 0 where the zoom factor is
     *  2.
     */
    minScaleDenominatorLimit: Math.pow(0.5, 19) * 40075016.68 * 39.3701 * OpenLayers.DOTS_PER_INCH / 256,

    /** private: property[maxScaleDenominatorLimit]
     *  ``Number`` Upper limit for scale denominators.  Default is what you get
     *  when you project the world in Spherical Mercator onto a single
     *  256 x 256 pixel tile and assume OpenLayers.DOTS_PER_INCH (this
     *  corresponds to zoom level 0 in Google Maps).
     */
    maxScaleDenominatorLimit: 40075016.68 * 39.3701 * OpenLayers.DOTS_PER_INCH / 256,
    
    /** private: property [scaleLevels]
     *  ``Number`` Number of scale levels to assume.  This is only for scaling
     *  values exponentially along the slider.  Scale values are not
     *  required to one of the discrete levels.  Default is 20.
     */
    scaleLevels: 20,
    
    /** private: property[scaleSliderTemplate]
     *  ``String`` Template for the tip displayed by the scale threshold slider.
     *
     *  Can be customized using the following keywords in curly braces:
     *  
     *  * zoom - the zoom level
     *  * scale - the scale denominator
     *  * type - "Max" or "Min" denominator
     *  * scaleType - "Min" or "Max" scale (sense is opposite of type)
     *
     *  Default is "{scaleType} Scale 1:{scale}".
     */
    scaleSliderTemplate: "{scaleType} Scale 1:{scale}",
    
    /** private: method[modifyScaleTipContext]
     *  Called from the multi-slider tip's getText function.  The function
     *  will receive two arguments - a reference to the panel and a data
     *  object.  The data object will have scale, zoom, and type properties
     *  already calculated.  Other properties added to the data object
     *  are available to the <scaleSliderTemplate>.
     */
    modifyScaleTipContext: Ext.emptyFn,
    
    /** i18n */
    labelFeaturesText: "Label Features",
    labelsText: "Labels",
    basicText: "Basic",
    advancedText: "Advanced",
    limitByScaleText: "Limit by scale",
    limitByConditionText: "Limit by condition",
    symbolText: "Symbol",
    nameText: "Name",

    /** private */
    initComponent: function() {
        
        var defConfig = {
            plain: true,
            border: false
        };
        Ext.applyIf(this, defConfig);
        
        if(!this.rule) {
            this.rule = new OpenLayers.Rule({
                name: this.uniqueRuleName()
            });
        } else {
            if (!this.initialConfig.symbolType) {
                this.symbolType = this.getSymbolTypeFromRule(this.rule) || this.symbolType;
            }
        }
        
        this.activeTab = 0;
        
        this.textSymbolizer = new gxp.TextSymbolizer({
            symbolizer: this.getTextSymbolizer(),
            attributes: this.attributes,
            fonts: this.fonts,
            listeners: {
                change: function(symbolizer) {
                    this.fireEvent("change", this, this.rule);
                },
                scope: this
            }
        });
        
        /**
         * The interpretation here is that scale values of zero are equivalent to
         * no scale value.  If someone thinks that a scale value of zero should have
         * a different interpretation, this needs to be changed.
         */
        this.scaleLimitPanel = new gxp.ScaleLimitPanel({
            maxScaleDenominator: this.rule.maxScaleDenominator || undefined,
            limitMaxScaleDenominator: !!this.rule.maxScaleDenominator,
            maxScaleDenominatorLimit: this.maxScaleDenominatorLimit,
            minScaleDenominator: this.rule.minScaleDenominator || undefined,
            limitMinScaleDenominator: !!this.rule.minScaleDenominator,
            minScaleDenominatorLimit: this.minScaleDenominatorLimit,
            scaleLevels: this.scaleLevels,
            scaleSliderTemplate: this.scaleSliderTemplate,
            modifyScaleTipContext: this.modifyScaleTipContext,
            listeners: {
                change: function(comp, min, max) {
                    this.rule.minScaleDenominator = min;
                    this.rule.maxScaleDenominator = max;
                    this.fireEvent("change", this, this.rule);
                },
                scope: this
            }
        });
        
        this.filterBuilder = new gxp.FilterBuilder({
            allowGroups: this.nestedFilters,
            filter: this.rule && this.rule.filter && this.rule.filter.clone(),
            attributes: this.attributes,
            listeners: {
                change: function(builder) {
                    var filter = builder.getFilter(); 
                    this.rule.filter = filter;
                    this.fireEvent("change", this, this.rule);
                },
                scope: this
            }
        });
        
        this.items = [{
            title: this.labelsText,
            autoScroll: true,
            bodyStyle: {"padding": "10px"},
            items: [{
                xtype: "fieldset",
                title: this.labelFeaturesText,
                autoHeight: true,
                checkboxToggle: true,
                collapsed: !this.hasTextSymbolizer(),
                items: [
                    this.textSymbolizer
                ],
                listeners: {
                    collapse: function() {
                        OpenLayers.Util.removeItem(this.rule.symbolizers, this.getTextSymbolizer());
                        this.fireEvent("change", this, this.rule);
                    },
                    expand: function() {
                        this.setTextSymbolizer(this.textSymbolizer.symbolizer);
                        this.fireEvent("change", this, this.rule);
                    },
                    scope: this
                }
            }]
        }];
        if (this.getSymbolTypeFromRule(this.rule) || this.symbolType) {
            this.items = [{
                title: this.basicText,
                autoScroll: true,
                items: [this.createHeaderPanel(), this.createSymbolizerPanel()]
            }, this.items[0], {
                title: this.advancedText,
                defaults: {
                    style: {
                        margin: "7px"
                    }
                },
                autoScroll: true,
                items: [{
                    xtype: "fieldset",
                    title: this.limitByScaleText,
                    checkboxToggle: true,
                    collapsed: !(this.rule && (this.rule.minScaleDenominator || this.rule.maxScaleDenominator)),
                    autoHeight: true,
                    items: [this.scaleLimitPanel],
                    listeners: {
                        collapse: function() {
                            delete this.rule.minScaleDenominator;
                            delete this.rule.maxScaleDenominator;
                            this.fireEvent("change", this, this.rule);
                        },
                        expand: function() {
                            /**
                             * Start workaround for
                             * http://projects.opengeo.org/suite/ticket/676
                             */
                            var tab = this.getActiveTab();
                            this.activeTab = null;
                            this.setActiveTab(tab);
                            /**
                             * End workaround for
                             * http://projects.opengeo.org/suite/ticket/676
                             */
                            var changed = false;
                            if (this.scaleLimitPanel.limitMinScaleDenominator) {
                                this.rule.minScaleDenominator = this.scaleLimitPanel.minScaleDenominator;
                                changed = true;
                            }
                            if (this.scaleLimitPanel.limitMaxScaleDenominator) {
                                this.rule.maxScaleDenominator = this.scaleLimitPanel.maxScaleDenominator;
                                changed = true;
                            }
                            if (changed) {
                                this.fireEvent("change", this, this.rule);
                            }
                        },
                        scope: this
                    }
                }, {
                    xtype: "fieldset",
                    title: this.limitByConditionText,
                    checkboxToggle: true,
                    collapsed: !(this.rule && this.rule.filter),
                    autoHeight: true,
                    items: [this.filterBuilder],
                    listeners: {
                        collapse: function(){
                            delete this.rule.filter;
                            this.fireEvent("change", this, this.rule);
                        },
                        expand: function(){
                            var changed = false;
                            this.rule.filter = this.filterBuilder.getFilter();
                            this.fireEvent("change", this, this.rule);
                        },
                        scope: this
                    }
                }]
            }];
        }
        this.items[0].autoHeight = true;

        this.addEvents(
            /** api: events[change]
             *  Fires when any rule property changes.
             *
             *  Listener arguments:
             *  * panel - :class:`gxp.RulePanel` This panel.
             *  * rule - ``OpenLayers.Rule`` The updated rule.
             */
            "change"
        ); 
        
        this.on({
            tabchange: function(panel, tab) {
                tab.doLayout();
            },
            scope: this
        });

        gxp.RulePanel.superclass.initComponent.call(this);
    },

    /** private: method[hasTextSymbolizer]
     */
    hasTextSymbolizer: function() {
        var candidate, symbolizer;
        for (var i=0, ii=this.rule.symbolizers.length; i<ii; ++i) {
            candidate = this.rule.symbolizers[i];
            if (candidate instanceof OpenLayers.Symbolizer.Text) {
                symbolizer = candidate;
                break;
            }
        }
        return symbolizer;
    },
    
    /** private: method[getTextSymbolizer]
     *  Get the first text symbolizer in the rule.  If one does not exist,
     *  create one.
     */
    getTextSymbolizer: function() {
        var symbolizer = this.hasTextSymbolizer();
        if (!symbolizer) {
            symbolizer = new OpenLayers.Symbolizer.Text({graphic: false});
        }
        return symbolizer;
    },
    
    /** private: method[setTextSymbolizer]
     *  Update the first text symbolizer in the rule.  If one does not exist,
     *  add it.
     */
    setTextSymbolizer: function(symbolizer) {
        var found;
        for (var i=0, ii=this.rule.symbolizers.length; i<ii; ++i) {
            candidate = this.rule.symbolizers[i];
            if (this.rule.symbolizers[i] instanceof OpenLayers.Symbolizer.Text) {
                this.rule.symbolizers[i] = symbolizer;
                found = true;
                break;
            }
        }
        if (!found) {
            this.rule.symbolizers.push(symbolizer);
        }        
    },

    /** private: method[uniqueRuleName]
     *  Generate a unique rule name.  This name will only be unique for this
     *  session assuming other names are created by the same method.  If
     *  name needs to be unique given some other context, override it.
     */
    uniqueRuleName: function() {
        return OpenLayers.Util.createUniqueID("rule_");
    },
    
    /** private: method[createHeaderPanel]
     *  Creates a panel config containing rule name, symbolizer, and scale
     *  constraints.
     */
    createHeaderPanel: function() {
        this.symbolizerSwatch = new GeoExt.FeatureRenderer({
            symbolType: this.symbolType,
            isFormField: true,
            fieldLabel: this.symbolText
        });
        return {
            xtype: "form",
            border: false,
            labelAlign: "top",
            defaults: {border: false},
            style: {"padding": "0.3em 0 0 1em"},
            items: [{
                layout: "column",
                defaults: {
                    border: false,
                    style: {"padding-right": "1em"}
                },
                items: [{
                    layout: "form",
                    width: 150,
                    items: [{
                        xtype: "textfield",
                        fieldLabel: this.nameText,
                        anchor: "95%",
                        value: this.rule && (this.rule.title || this.rule.name || ""),
                        listeners: {
                            change: function(el, value) {
                                this.rule.title = value;
                                this.fireEvent("change", this, this.rule);
                            },
                            scope: this
                        }
                    }]
                }, {
                    layout: "form",
                    width: 70,
                    items: [this.symbolizerSwatch]
                }]
            }]
        };
    },

    /** private: method[createSymbolizerPanel]
     */
    createSymbolizerPanel: function() {
        // use first symbolizer that matches symbolType
        var candidate, symbolizer;
        var Type = OpenLayers.Symbolizer[this.symbolType];
        var existing = false;
        if (Type) {
            for (var i=0, ii=this.rule.symbolizers.length; i<ii; ++i) {
                candidate = this.rule.symbolizers[i];
                if (candidate instanceof Type) {
                    existing = true;
                    symbolizer = candidate;
                    break;
                }
            }
            if (!symbolizer) {
                // allow addition of new symbolizer
                symbolizer = new Type({fill: false, stroke: false});
            }
        } else {
            throw new Error("Appropriate symbolizer type not included in build: " + this.symbolType);
        }
        this.symbolizerSwatch.setSymbolizers([symbolizer],
            {draw: this.symbolizerSwatch.rendered}
        );
        var cfg = {
            xtype: "gxp_" + this.symbolType.toLowerCase() + "symbolizer",
            symbolizer: symbolizer,
            bodyStyle: {padding: "10px"},
            border: false,
            labelWidth: 70,
            defaults: {
                labelWidth: 70
            },
            listeners: {
                change: function(symbolizer) {
                    this.symbolizerSwatch.setSymbolizers(
                        [symbolizer], {draw: this.symbolizerSwatch.rendered}
                    );
                    if (!existing) {
                        this.rule.symbolizers.push(symbolizer);
                        existing = true;
                    }
                    this.fireEvent("change", this, this.rule);
                },
                scope: this
            }
        };
        if (this.symbolType === "Point" && this.pointGraphics) {
            cfg.pointGraphics = this.pointGraphics;
        }
        return cfg;
        
    },

    /** private: method[getSymbolTypeFromRule]
     *  :arg rule: `OpenLayers.Rule`
     *  :return: `String` "Point", "Line" or "Polygon" (or undefined if none
     *      of the three.
     *
     *  Determines the symbol type of the first symbolizer of a rule that is
     *  not a text symbolizer
     */
    getSymbolTypeFromRule: function(rule) {
        var candidate, type;
        for (var i=0, ii=rule.symbolizers.length; i<ii; ++i) {
            candidate = rule.symbolizers[i];
            if (!(candidate instanceof OpenLayers.Symbolizer.Text)) {
                type = candidate.CLASS_NAME.split(".").pop();
                break;
            }
        }
        return type;
    }

});

/** api: xtype = gxp_rulepanel */
Ext.reg('gxp_rulepanel', gxp.RulePanel); 

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @include widgets/tips/SliderTip.js
 */

/** api: (define)
 *  module = gxp
 *  class = ScaleLimitPanel
 *  base_link = `Ext.Panel <http://extjs.com/deploy/dev/docs/?class=Ext.Panel>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: ScaleLimitPanel(config)
 *   
 *      A panel for assembling scale constraints in SLD styles.
 */
gxp.ScaleLimitPanel = Ext.extend(Ext.Panel, {
    
    /** api: config[maxScaleDenominatorLimit]
     *  ``Number`` Upper limit for scale denominators.  Default is what you get
     *     when you project the world in Spherical Mercator onto a single
     *     256 x 256 pixel tile and assume OpenLayers.DOTS_PER_INCH (this
     *     corresponds to zoom level 0 in Google Maps).
     */
    maxScaleDenominatorLimit: 40075016.68 * 39.3701 * OpenLayers.DOTS_PER_INCH / 256,
    
    /** api: config[limitMaxScaleDenominator]
     *  ``Boolean`` Limit the maximum scale denominator.  If false, no upper
     *     limit will be imposed.
     */
    limitMaxScaleDenominator: true,

    /** api: config[maxScaleDenominator]
     *  ``Number`` The initial maximum scale denominator.  If <limitMaxScaleDenominator> is
     *     true and no minScaleDenominator is provided, <maxScaleDenominatorLimit> will
     *     be used.
     */
    maxScaleDenominator: undefined,

    /** api: config[minScaleDenominatorLimit]
     *  ``Number`` Lower limit for scale denominators.  Default is what you get when
     *     you assume 20 zoom levels starting with the world in Spherical
     *     Mercator on a single 256 x 256 tile at zoom 0 where the zoom factor
     *     is 2.
     */
    minScaleDenominatorLimit: Math.pow(0.5, 19) * 40075016.68 * 39.3701 * OpenLayers.DOTS_PER_INCH / 256,

    /** api: config[limitMinScaleDenominator]
     *  ``Boolean`` Limit the minimum scale denominator.  If false, no lower
     *     limit will be imposed.
     */
    limitMinScaleDenominator: true,

    /** api: config[minScaleDenominator]
     *  ``Number`` The initial minimum scale denominator.  If <limitMinScaleDenominator> is
     *     true and no minScaleDenominator is provided, <minScaleDenominatorLimit> will
     *     be used.
     */
    minScaleDenominator: undefined,
    
    /** api: config[scaleLevels]
     *  ``Number`` Number of scale levels to assume.  This is only for scaling
     *     values exponentially along the slider.  Scale values are not
     *     required to one of the discrete levels.  Default is 20.
     */
    scaleLevels: 20,
    
    /** api: config[scaleSliderTemplate]
     *  ``String`` Template for the tip displayed by the scale threshold slider.
     *
     *  Can be customized using the following keywords in curly braces:
     *
     *  * zoom - the zoom level
     *  * scale - the scale denominator
     *  * type - "Max" or "Min" denominator
     *  * scaleType - "Min" or "Max" scale (sense is opposite of type)
     *
     *  Default is "{scaleType} Scale 1:{scale}".
     */
    scaleSliderTemplate: "{scaleType} Scale 1:{scale}",
    
    /** api: config[modifyScaleTipContext]
     *  ``Function`` Called from the multi-slider tip's getText function.  The
     *     function will receive two arguments - a reference to the panel and
     *     a data object.  The data object will have scale, zoom, and type
     *     properties already calculated.  Other properties added to the data
     *     object  are available to the <scaleSliderTemplate>.
     */
    modifyScaleTipContext: Ext.emptyFn,

    /** private: property[scaleFactor]
     *  ``Number`` Calculated base for determining exponential scaling of values
     *     for the slider.
     */
    scaleFactor: null,
    
    /** private: property[changing]
     *  ``Boolean`` The panel is updating itself.
     */
    changing: false,
    
    border: false,
    
    /** i18n */
    maxScaleLimitText: "Max scale limit",
    minScaleLimitText: "Min scale limit",
    
    /** private: method[initComponent]
     */
    initComponent: function() {
        
        this.layout = "column";
        
        this.defaults = {
            border: false,
            bodyStyle: "margin: 0 5px;"
        };
        this.bodyStyle = {
            padding: "5px"
        };
        
        this.scaleSliderTemplate = new Ext.Template(this.scaleSliderTemplate);
        
        Ext.applyIf(this, {
            minScaleDenominator: this.minScaleDenominatorLimit,
            maxScaleDenominator: this.maxScaleDenominatorLimit
        });
        
        this.scaleFactor = Math.pow(
            this.maxScaleDenominatorLimit / this.minScaleDenominatorLimit,
            1 / (this.scaleLevels - 1)
        );
        
        this.scaleSlider = new Ext.Slider({
            vertical: true,
            height: 100,
            values: [0, 100],
            listeners: {
                changecomplete: function(slider, value) {
                    this.updateScaleValues(slider);
                },
                render: function(slider) {
                    slider.thumbs[0].el.setVisible(this.limitMaxScaleDenominator);
                    slider.thumbs[1].el.setVisible(this.limitMinScaleDenominator);
                    slider.setDisabled(!this.limitMinScaleDenominator && !this.limitMaxScaleDenominator);
                },
                scope: this
            },
            plugins: [new gxp.slider.Tip({
                getText: (function(thumb) {
                    var index = thumb.slider.thumbs.indexOf(thumb);
                    var value = thumb.value;
                    var scales = this.sliderValuesToScale([thumb.value]);
                    var data = {
                        scale: String(scales[0]),
                        zoom: (thumb.value * (this.scaleLevels / 100)).toFixed(1),
                        type: (index === 0) ? "Max" : "Min",
                        scaleType: (index === 0) ? "Min" : "Max"
                    };
                    this.modifyScaleTipContext(this, data);
                    return this.scaleSliderTemplate.apply(data);
                }).createDelegate(this)
            })]
        });
        
        this.maxScaleDenominatorInput = new Ext.form.NumberField({
            allowNegative: false,
            width: 100,
            fieldLabel: "1",
            value: Math.round(this.maxScaleDenominator),
            disabled: !this.limitMaxScaleDenominator,
            validator: (function(value) {
                return !this.limitMinScaleDenominator || (value > this.minScaleDenominator);
            }).createDelegate(this),
            listeners: {
                valid: function(field) {
                    var value = Number(field.getValue());
                    var limit = Math.round(this.maxScaleDenominatorLimit);
                    if(value < limit && value > this.minScaleDenominator) {
                        this.maxScaleDenominator = value;
                        this.updateSliderValues();
                    }
                },
                change: function(field) {
                    var value = Number(field.getValue());
                    var limit = Math.round(this.maxScaleDenominatorLimit);
                    if(value > limit) {
                        field.setValue(limit);
                    } else if(value < this.minScaleDenominator) {
                        field.setValue(this.minScaleDenominator);
                    } else {
                        this.maxScaleDenominator = value;
                        this.updateSliderValues();
                    }
                },
                scope: this
            }
        });

        this.minScaleDenominatorInput = new Ext.form.NumberField({
            allowNegative: false,
            width: 100,
            fieldLabel: "1",
            value: Math.round(this.minScaleDenominator),
            disabled: !this.limitMinScaleDenominator,
            validator: (function(value) {
                return !this.limitMaxScaleDenominator || (value < this.maxScaleDenominator);
            }).createDelegate(this),
            listeners: {
                valid: function(field) {
                    var value = Number(field.getValue());
                    var limit = Math.round(this.minScaleDenominatorLimit);
                    if(value > limit && value < this.maxScaleDenominator) {
                        this.minScaleDenominator = value;
                        this.updateSliderValues();
                    }
                },
                change: function(field) {
                    var value = Number(field.getValue());
                    var limit = Math.round(this.minScaleDenominatorLimit);
                    if(value < limit) {
                        field.setValue(limit);
                    } else if(value > this.maxScaleDenominator) {
                        field.setValue(this.maxScaleDenominator);
                    } else {
                        this.minScaleDenominator = value;
                        this.updateSliderValues();
                    }
                },
                scope: this
            }
        });
        
        this.items = [this.scaleSlider, {
            xtype: "panel",
            layout: "form",
            defaults: {border: false},
            items: [{
                labelWidth: 90,
                layout: "form",
                width: 150,
                items: [{
                    xtype: "checkbox",
                    checked: !!this.limitMinScaleDenominator,
                    fieldLabel: this.maxScaleLimitText,
                    listeners: {
                        check: function(box, checked) {
                            this.limitMinScaleDenominator = checked;
                            var slider = this.scaleSlider;
                            slider.setValue(1, 100);
                            slider.thumbs[1].el.setVisible(checked);
                            this.minScaleDenominatorInput.setDisabled(!checked);
                            this.updateScaleValues(slider);
                            slider.setDisabled(!this.limitMinScaleDenominator && !this.limitMaxScaleDenominator);
                        },
                        scope: this
                    }
                }]
            }, {
                labelWidth: 10,
                layout: "form",
                items: [this.minScaleDenominatorInput]
            }, {
                labelWidth: 90,
                layout: "form",
                items: [{
                    xtype: "checkbox",
                    checked: !!this.limitMaxScaleDenominator,
                    fieldLabel: this.minScaleLimitText,
                    listeners: {
                        check: function(box, checked) {
                            this.limitMaxScaleDenominator = checked;
                            var slider = this.scaleSlider;
                            slider.setValue(0, 0);
                            slider.thumbs[0].el.setVisible(checked);
                            this.maxScaleDenominatorInput.setDisabled(!checked);
                            this.updateScaleValues(slider);
                            slider.setDisabled(!this.limitMinScaleDenominator && !this.limitMaxScaleDenominator);
                        },
                        scope: this
                    }
                }]
            }, {
                labelWidth: 10,
                layout: "form",
                items: [this.maxScaleDenominatorInput]
            }]
        }];

        this.addEvents(
            /**
             * Event: change
             * Fires before any field blurs if the field value has changed.
             *
             * Listener arguments:
             * symbolizer - {Object} A symbolizer with fill related properties
             *     updated.
             */
            "change"
        ); 

        gxp.ScaleLimitPanel.superclass.initComponent.call(this);
        
    },
    
    /** private: method[updateScaleValues]
     */
    updateScaleValues: function(slider) {
        if(!this.changing) {
            var values = slider.getValues();
            var resetSlider = false;
            if(!this.limitMaxScaleDenominator) {
                if(values[0] > 0) {
                    values[0] = 0;
                    resetSlider = true;
                }
            }
            if(!this.limitMinScaleDenominator) {
                if(values[1] < 100) {
                    values[1] = 100;
                    resetSlider = true;
                }
            }
            if(resetSlider) {
                slider.setValue(0, values[0]);
                slider.setValue(1, values[1]);
            } else {
                var scales = this.sliderValuesToScale(values);
                var max = scales[0];
                var min = scales[1];
                this.changing = true;
                this.minScaleDenominatorInput.setValue(min);
                this.maxScaleDenominatorInput.setValue(max);
                this.changing = false;
                this.fireEvent(
                    "change", this,
                    (this.limitMinScaleDenominator) ? min : undefined,
                    (this.limitMaxScaleDenominator) ? max : undefined
                );
            }
        }
    },
    
    /** private: method[updateSliderValues]
     */
    updateSliderValues: function() {
        if(!this.changing) {
            var min = this.minScaleDenominator;
            var max = this.maxScaleDenominator;
            var values = this.scaleToSliderValues([max, min]);
            this.changing = true;
            this.scaleSlider.setValue(0, values[0]);
            this.scaleSlider.setValue(1, values[1]);
            this.changing = false;
            this.fireEvent(
                "change", this,
                (this.limitMinScaleDenominator) ? min : undefined,
                (this.limitMaxScaleDenominator) ? max : undefined
            );
        }
    },

    /** private: method[sliderValuesToScale]
     *  :arg values: ``Array`` Values from the scale slider.
     *  :return: ``Array`` A two item array of min and max scale denominators.
     *  
     *  Given two values between 0 and 100, generate the min and max scale
     *  denominators.  Assuming exponential scaling with <scaleFactor>.
     */
    sliderValuesToScale: function(values) {
        var interval = 100 / (this.scaleLevels - 1);
        return [Math.round(Math.pow(this.scaleFactor, (100 - values[0]) / interval) * this.minScaleDenominatorLimit),
                Math.round(Math.pow(this.scaleFactor, (100 - values[1]) / interval) * this.minScaleDenominatorLimit)];
    },
    
    /** private: method[scaleToSliderValues]
     */
    scaleToSliderValues: function(scales) {
        var interval = 100 / (this.scaleLevels - 1);
        return [100 - (interval * Math.log(scales[0] / this.minScaleDenominatorLimit) / Math.log(this.scaleFactor)),
                100 - (interval * Math.log(scales[1] / this.minScaleDenominatorLimit) / Math.log(this.scaleFactor))];
    }
    
});

/** api: xtype = gxp_scalelimitpanel */
Ext.reg('gxp_scalelimitpanel', gxp.ScaleLimitPanel); 

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @include widgets/FillSymbolizer.js
 * @include widgets/PointSymbolizer.js
 * @include widgets/form/FontComboBox.js
 * @requires plugins/FormFieldHelp.js
 */

/** api: (define)
 *  module = gxp
 *  class = TextSymbolizer
 *  base_link = `Ext.Panel <http://extjs.com/deploy/dev/docs/?class=Ext.Panel>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: TextSymbolizer(config)
 *   
 *      Form for configuring a text symbolizer.
 */
gxp.TextSymbolizer = Ext.extend(Ext.Panel, {
    
    /** api: config[fonts]
     *  ``Array(String)``
     *  List of fonts for the font combo.  If not set, defaults to the list
     *  provided by the :class:`gxp.FontComboBox`.
     */
    fonts: undefined,
    
    /** api: config[symbolizer]
     *  ``Object``
     *  A symbolizer object that will be used to fill in form values.
     *  This object will be modified when values change.  Clone first if
     *  you do not want your symbolizer modified.
     */
    symbolizer: null,
    
    /** api: config[defaultSymbolizer]
     *  ``Object``
     *  Default symbolizer properties to be used where none provided.
     */
    defaultSymbolizer: null,
    
    /** api: config[attributes]
     *  :class:`GeoExt.data.AttributeStore`
     *  A configured attributes store for use in the filter property combo.
     */
    attributes: null,
    
    /** api: config[colorManager]
     *  ``Function``
     *  Optional color manager constructor to be used as a plugin for the color
     *  field.
     */
    colorManager: null,

    /** private: property[haloCache]
     *  ``Object``
     *  Stores halo properties while fieldset is collapsed.
     */
    haloCache: null,
    
    border: false,    
    layout: "form",
    
    /** i18n */
    labelValuesText: "Label values",
    haloText: "Halo",
    sizeText: "Size",
    priorityText: "Priority",
    labelOptionsText: "Label options",
    autoWrapText: "Auto wrap",
    followLineText: "Follow line",
    maxDisplacementText: "Maximum displacement",
    repeatText: "Repeat",
    forceLeftToRightText: "Force left to right",
    groupText: "Grouping",
    spaceAroundText: "Space around",
    labelAllGroupText: "Label all segments in line group",
    maxAngleDeltaText: "Maximum angle delta",
    conflictResolutionText: "Conflict resolution",
    goodnessOfFitText: "Goodness of fit",
    polygonAlignText: "Polygon alignment",
    graphicResizeText: "Graphic resize",
    graphicMarginText: "Graphic margin",
    graphicTitle: "Graphic",
    fontColorTitle: "Font color and opacity",
    positioningText: "Label positioning",
    anchorPointText: "Anchor point",
    displacementXText: "Displacement (X-direction)",
    displacementYText: "Displacement (Y-direction)",
    perpendicularOffsetText: "Perpendicular offset",
    priorityHelp: "The higher the value of the specified field, the sooner the label will be drawn (which makes it win in the conflict resolution game)",
    autoWrapHelp: "Wrap labels that exceed a certain length in pixels",
    followLineHelp: "Should the label follow the geometry of the line?",
    maxDisplacementHelp: "Maximum displacement in pixels if label position is busy",
    repeatHelp: "Repeat labels after a certain number of pixels",
    forceLeftToRightHelp: "Labels are usually flipped to make them readable. If the character happens to be a directional arrow then this is not desirable",
    groupHelp: "Grouping works by collecting all features with the same label text, then choosing a representative geometry for the group. Road data is a classic example to show why grouping is useful. It is usually desirable to display only a single label for all of 'Main Street', not a label for every block of 'Main Street.'",
    spaceAroundHelp: "Overlapping and Separating Labels. By default GeoServer will not render labels 'on top of each other'. By using the spaceAround option you can either allow labels to overlap, or add extra space around labels. The value supplied for the option is a positive or negative size in pixels. Using the default value of 0, the bounding box of a label cannot overlap the bounding box of another label.",
    labelAllGroupHelp: "The labelAllGroup option makes sure that all of the segments in a line group are labeled instead of just the longest one.",
    conflictResolutionHelp: "By default labels are subjected to conflict resolution, meaning the renderer will not allow any label to overlap with a label that has been drawn already. Setting this parameter to false pull the label out of the conflict resolution game, meaning the label will be drawn even if it overlaps with other labels, and other labels drawn after it wont mind overlapping with it.",
    goodnessOfFitHelp: "Geoserver will remove labels if they are a particularly bad fit for the geometry they are labeling. For Polygons: the label is sampled approximately at every letter. The distance from these points to the polygon is determined and each sample votes based on how close it is to the polygon. The default value is 0.5.",
    graphic_resizeHelp: "Specifies a mode for resizing label graphics (such as highway shields) to fit the text of the label. The default mode, none, never modifies the label graphic. In stretch mode, GeoServer will resize the graphic to exactly surround the label text, possibly modifying the images aspect ratio. In proportional mode, GeoServer will expand the image to be large enough to surround the text while preserving its original aspect ratio.",
    maxAngleDeltaHelp: "Designed to use used in conjuection with followLine, the maxAngleDelta option sets the maximum angle, in degrees, between two subsequent characters in a curved label. Large angles create either visually disconnected words or overlapping characters. It is advised not to use angles larger than 30.",
    polygonAlignHelp: "GeoServer normally tries to place horizontal labels within a polygon, and give up in case the label position is busy or if the label does not fit enough in the polygon. This options allows GeoServer to try alternate rotations for the labels. Possible options: the default value, only the rotation manually specified in the <Rotation> tag will be used (manual), If the label does not fit horizontally and the polygon is taller than wider the vertical alignement will also be tried (ortho), If the label does not fit horizontally the minimum bounding rectangle will be computed and a label aligned to it will be tried out as well (mbr).",
    graphic_marginHelp: "Similar to the margin shorthand property in CSS for HTML, its interpretation varies depending on how many margin values are provided: 1 = use that margin length on all sides of the label 2 = use the first for top & bottom margins and the second for left & right margins. 3 = use the first for the top margin, second for left & right margins, third for the bottom margin. 4 = use the first for the top margin, second for the right margin, third for the bottom margin, and fourth for the left margin.",

    initComponent: function() {

        if(!this.symbolizer) {
            this.symbolizer = {};
        }
        Ext.applyIf(this.symbolizer, this.defaultSymbolizer);

        if (!this.symbolizer.vendorOptions) {
            this.symbolizer.vendorOptions = {};
        }

        this.haloCache = {};

        this.attributes.on('load', this.showHideGeometryOptions, this);
        this.attributes.load();

        var defAttributesComboConfig = {
            xtype: "combo",
            fieldLabel: this.labelValuesText,
            store: this.attributes,
            mode: 'local',
            lastQuery: '',
            editable: false,
            triggerAction: "all",
            allowBlank: false,
            displayField: "name",
            valueField: "name",
            value: this.symbolizer.label && this.symbolizer.label.replace(/^\${(.*)}$/, "$1"),
            listeners: {
                select: function(combo, record) {
                    this.symbolizer.label = "${" + record.get("name") + "}";
                    this.fireEvent("change", this.symbolizer);
                },
                scope: this
            },
            width: 120
        };
        this.attributesComboConfig = this.attributesComboConfig || {};
        Ext.applyIf(this.attributesComboConfig, defAttributesComboConfig);
        
        this.labelWidth = 80;
        
        this.items = [this.attributesComboConfig, {
            cls: "x-html-editor-tb",
            style: "background: transparent; border: none; padding: 0 0em 0.5em;",
            xtype: "toolbar",
            items: [{
                xtype: "gxp_fontcombo",
                fonts: this.fonts || undefined,
                width: 110,
                value: this.symbolizer.fontFamily,
                listeners: {
                    select: function(combo, record) {
                        this.symbolizer.fontFamily = record.get("field1");
                        this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                }
            }, {
                xtype: "tbtext",
                text: this.sizeText + ": "
            }, {
                xtype: "numberfield",
                allowNegative: false,
                emptyText: OpenLayers.Renderer.defaultSymbolizer.fontSize,
                value: this.symbolizer.fontSize,
                width: 30,
                listeners: {
                    change: function(field, value) {
                        value = parseFloat(value);
                        if (isNaN(value)) {
                            delete this.symbolizer.fontSize;
                        } else {
                            this.symbolizer.fontSize = value;
                        }
                        this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                }
            }, {
                enableToggle: true,
                cls: "x-btn-icon",
                iconCls: "x-edit-bold",
                pressed: this.symbolizer.fontWeight === "bold",
                listeners: {
                    toggle: function(button, pressed) {
                        this.symbolizer.fontWeight = pressed ? "bold" : "normal";
                        this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                }
            }, {
                enableToggle: true,
                cls: "x-btn-icon",
                iconCls: "x-edit-italic",
                pressed: this.symbolizer.fontStyle === "italic",
                listeners: {
                    toggle: function(button, pressed) {
                        this.symbolizer.fontStyle = pressed ? "italic" : "normal";
                        this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                }
            }]
        }, {
            xtype: "gxp_fillsymbolizer",
            fillText: this.fontColorTitle,
            symbolizer: this.symbolizer,
            colorProperty: "fontColor",
            opacityProperty: "fontOpacity",
            checkboxToggle: false,
            autoHeight: true,
            width: 213,
            labelWidth: 70,
            plugins: this.colorManager && [new this.colorManager()],
            listeners: {
                change: function(symbolizer) {
                    this.fireEvent("change", this.symbolizer);
                },
                scope: this
            }
        }, {
            xtype: "fieldset",
            title: this.graphicTitle,
            checkboxToggle: true,
            hideMode: 'offsets',
            collapsed: !(this.symbolizer.fillColor || this.symbolizer.fillOpacity || this.symbolizer.vendorOptions["graphic-resize"] || this.symbolizer.vendorOptions["graphic-margin"]),
            labelWidth: 70,
            items: [{
                xtype: "gxp_pointsymbolizer",
                symbolizer: this.symbolizer,
                listeners: {
                    "change": function(symbolizer) {
                        symbolizer.graphic = !!symbolizer.graphicName || !!symbolizer.externalGraphic;
                        this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                },
                border: false,
                labelWidth: 70
            }, this.createVendorSpecificField({
                name: "graphic-resize",
                xtype: "combo",
                store: ["none", "stretch", "proportional"],
                mode: 'local',
                listeners: {
                    "select": function(combo, record) {
                        if (combo.getValue() === "none") {
                            this.graphicMargin.hide();
                        } else {
                            if (Ext.isEmpty(this.graphicMargin.getValue())) {
                                this.graphicMargin.setValue(0);
                                this.symbolizer.vendorOptions["graphic-margin"] = 0;
                            }
                            this.graphicMargin.show();
                        }
                    },
                    scope: this
                },
                width: 100,
                triggerAction: 'all',
                fieldLabel: this.graphicResizeText
            }), this.createVendorSpecificField({
                name: "graphic-margin",
                ref: "../graphicMargin",
                hidden: (this.symbolizer.vendorOptions["graphic-resize"] !== "stretch" && this.symbolizer.vendorOptions["graphic-resize"] !== "proportional"),
                width: 100,
                fieldLabel: this.graphicMarginText,
                xtype: "textfield"
            })],
            listeners: {
                collapse: function() {
                    this.graphicCache = {
                        externalGraphic: this.symbolizer.externalGraphic,
                        fillColor: this.symbolizer.fillColor,
                        fillOpacity: this.symbolizer.fillOpacity,
                        graphicName: this.symbolizer.graphicName,
                        pointRadius: this.symbolizer.pointRadius,
                        rotation: this.symbolizer.rotation,
                        strokeColor: this.symbolizer.strokeColor,
                        strokeWidth: this.symbolizer.strokeWidth,
                        strokeDashStyle: this.symbolizer.strokeDashStyle
                    };
                    delete this.symbolizer.externalGraphic;
                    delete this.symbolizer.fillColor;
                    delete this.symbolizer.fillOpacity;
                    delete this.symbolizer.graphicName;
                    delete this.symbolizer.pointRadius;
                    delete this.symbolizer.rotation;
                    delete this.symbolizer.strokeColor;
                    delete this.symbolizer.strokeWidth;
                    delete this.symbolizer.strokeDashStyle;
                    this.fireEvent("change", this.symbolizer)
                },
                expand: function() {
                    Ext.apply(this.symbolizer, this.graphicCache);
                    /**
                     * Start workaround for
                     * http://projects.opengeo.org/suite/ticket/676
                     */
                    this.doLayout();
                    /**
                     * End workaround for
                     * http://projects.opengeo.org/suite/ticket/676
                     */
                    this.fireEvent("change", this.symbolizer);
                },
                scope: this
            }
        }, {
            xtype: "fieldset",
            title: this.haloText,
            checkboxToggle: true,
            collapsed: !(this.symbolizer.haloRadius || this.symbolizer.haloColor || this.symbolizer.haloOpacity),
            autoHeight: true,
            labelWidth: 50,
            items: [{
                xtype: "numberfield",
                fieldLabel: this.sizeText,
                anchor: "89%",
                allowNegative: false,
                emptyText: OpenLayers.Renderer.defaultSymbolizer.haloRadius,
                value: this.symbolizer.haloRadius,
                listeners: {
                    change: function(field, value) {
                        value = parseFloat(value);
                        if (isNaN(value)) {
                            delete this.symbolizer.haloRadius;
                        } else {
                            this.symbolizer.haloRadius = value;
                        }
                        this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                }
            }, {
                xtype: "gxp_fillsymbolizer",
                symbolizer: {
                    fillColor: ("haloColor" in this.symbolizer) ? this.symbolizer.haloColor : OpenLayers.Renderer.defaultSymbolizer.haloColor,
                    fillOpacity: ("haloOpacity" in this.symbolizer) ? this.symbolizer.haloOpacity : OpenLayers.Renderer.defaultSymbolizer.haloOpacity*100
                },
                defaultColor: OpenLayers.Renderer.defaultSymbolizer.haloColor,
                checkboxToggle: false,
                width: 190,
                labelWidth: 60,
                plugins: this.colorManager && [new this.colorManager()],
                listeners: {
                    change: function(symbolizer) {
                        this.symbolizer.haloColor = symbolizer.fillColor;
                        this.symbolizer.haloOpacity = symbolizer.fillOpacity;
                        this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                }
            }],
            listeners: {
                collapse: function() {
                    this.haloCache = {
                        haloRadius: this.symbolizer.haloRadius,
                        haloColor: this.symbolizer.haloColor,
                        haloOpacity: this.symbolizer.haloOpacity
                    };
                    delete this.symbolizer.haloRadius;
                    delete this.symbolizer.haloColor;
                    delete this.symbolizer.haloOpacity;
                    this.fireEvent("change", this.symbolizer)
                },
                expand: function() {
                    Ext.apply(this.symbolizer, this.haloCache);
                    /**
                     * Start workaround for
                     * http://projects.opengeo.org/suite/ticket/676
                     */
                    this.doLayout();
                    /**
                     * End workaround for
                     * http://projects.opengeo.org/suite/ticket/676
                     */                    
                    this.fireEvent("change", this.symbolizer);
                },
                scope: this
            }
        }, {
            xtype: "fieldset",
            collapsed: !(this.symbolizer.labelAlign || this.symbolizer.vendorOptions['polygonAlign'] || this.symbolizer.labelXOffset || this.symbolizer.labelYOffset || this.symbolizer.labelPerpendicularOffset),
            title: this.positioningText,
            checkboxToggle: true,
            autoHeight: true,
            labelWidth: 75,
            defaults: {
                width: 100
            },
            items: [this.createField(Ext.applyIf({
                fieldLabel: this.anchorPointText,
                geometryTypes: ["POINT"],
                value: this.symbolizer.labelAlign || "lb",
                store: [
                    ['lt', 'Left-top'], 
                    ['ct', 'Center-top'], 
                    ['rt', 'Right-top'],
                    ['lm', 'Left-center'],
                    ['cm', 'Center'],
                    ['rm', 'Right-center'],
                    ['lb', 'Left-bottom'],
                    ['cb', 'Center-bottom'],
                    ['rb', 'Right-bottom']
                ],
                listeners: {
                    select: function(combo, record) {
                        this.symbolizer.labelAlign = combo.getValue();
                        delete this.symbolizer.labelAnchorPointX;
                        delete this.symbolizer.labelAnchorPointY;
                        this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                }
            }, this.attributesComboConfig)), this.createField({
                xtype: "numberfield",
                geometryTypes: ["POINT"],
                fieldLabel: this.displacementXText,
                value: this.symbolizer.labelXOffset,
                listeners: {
                    change: function(field, value) {
                        this.symbolizer.labelXOffset = value;
                        this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                }
            }), this.createField({
                xtype: "numberfield",
                geometryTypes: ["POINT"],
                fieldLabel: this.displacementYText,
                value: this.symbolizer.labelYOffset,
                listeners: {
                    change: function(field, value) {
                        this.symbolizer.labelYOffset = value;
                        this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                }
            }), this.createField({
                xtype: "numberfield",
                geometryTypes: ["LINE"],
                fieldLabel: this.perpendicularOffsetText,
                value: this.symbolizer.labelPerpendicularOffset,
                listeners: {
                    change: function(field, value) {
                        if (Ext.isEmpty(value)) {
                            delete this.symbolizer.labelPerpendicularOffset;
                        } else {
                            this.symbolizer.labelPerpendicularOffset = value;
                        }
                        this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                }
            }),
            this.createVendorSpecificField({
                name: 'polygonAlign',
                geometryTypes: ['POLYGON'],
                xtype: "combo",
                mode: 'local',
                value: this.symbolizer.vendorOptions['polygonAlign'] || 'manual',
                triggerAction: 'all',
                store: ["manual", "ortho", "mbr"],
                fieldLabel: this.polygonAlignText
            })]
        }, {
            xtype: "fieldset",
            title: this.priorityText,
            checkboxToggle: true,
            collapsed: !(this.symbolizer.priority),
            autoHeight: true,
            labelWidth: 50,
            items: [Ext.applyIf({
                fieldLabel: this.priorityText,
                value: this.symbolizer.priority && this.symbolizer.priority.replace(/^\${(.*)}$/, "$1"),
                allowBlank: true,
                name: 'priority',
                plugins: [{
                    ptype: 'gxp_formfieldhelp',
                    dismissDelay: 20000,
                    helpText: this.priorityHelp
                }],
                listeners: {
                    select: function(combo, record) {
                        this.symbolizer[combo.name] = "${" + record.get("name") + "}";
                        this.fireEvent("change", this.symbolizer);
                    },
                    scope: this
                }
            }, this.attributesComboConfig)]
        }, {
            xtype: "fieldset",
            title: this.labelOptionsText,
            checkboxToggle: true,
            collapsed: !(this.symbolizer.vendorOptions['autoWrap'] || this.symbolizer.vendorOptions['followLine'] || this.symbolizer.vendorOptions['maxAngleDelta'] || this.symbolizer.vendorOptions['maxDisplacement'] || this.symbolizer.vendorOptions['repeat'] || this.symbolizer.vendorOptions['forceLeftToRight'] || this.symbolizer.vendorOptions['group'] || this.symbolizer.vendorOptions['spaceAround'] || this.symbolizer.vendorOptions['labelAllGroup'] || this.symbolizer.vendorOptions['conflictResolution'] || this.symbolizer.vendorOptions['goodnessOfFit'] || this.symbolizer.vendorOptions['polygonAlign']),
            autoHeight: true,
            labelWidth: 80,
            defaults: {
                width: 100
            },
            items: [
                this.createVendorSpecificField({
                    name: 'autoWrap',
                    allowBlank: false,
                    fieldLabel: this.autoWrapText
                }),
                this.createVendorSpecificField({
                    name: 'followLine', 
                    geometryTypes: ["LINE"],
                    xtype: 'checkbox', 
                    listeners: {
                        'check': function(cb, checked) {
                            if (!checked) {
                                this.maxAngleDelta.hide();
                            } else {
                                this.maxAngleDelta.show();
                            }
                        },
                        scope: this
                    },
                    fieldLabel: this.followLineText
                }),
                this.createVendorSpecificField({
                    name: 'maxAngleDelta',
                    ref: "../maxAngleDelta",
                    hidden: (this.symbolizer.vendorOptions["followLine"] == null),
                    geometryTypes: ["LINE"],
                    fieldLabel: this.maxAngleDeltaText
                }),
                this.createVendorSpecificField({
                    name: 'maxDisplacement',
                    fieldLabel: this.maxDisplacementText
                }),
                this.createVendorSpecificField({
                    name: 'repeat',
                    geometryTypes: ["LINE"],
                    fieldLabel: this.repeatText
                }),
                this.createVendorSpecificField({
                    name: 'forceLeftToRight',
                    xtype: "checkbox",
                    geometryTypes: ["LINE"],
                    fieldLabel: this.forceLeftToRightText
                }),
                this.createVendorSpecificField({
                    name: 'group',
                    listeners: {
                        'check': function(cb, value) {
                            if (this.geometryType === 'LINE') {
                                if (value === false) {
                                    this.labelAllGroup.hide();
                                } else {
                                    this.labelAllGroup.show();
                                }
                            }
                        },
                        scope: this
                    },
                    xtype: 'checkbox',
                    yesno: true,
                    fieldLabel: this.groupText
                }),
                this.createVendorSpecificField({
                    name: 'labelAllGroup',
                    ref: "../labelAllGroup",
                    geometryTypes: ["LINE"],
                    hidden: (this.symbolizer.vendorOptions['group'] !== 'yes'),
                    xtype: "checkbox",
                    fieldLabel: this.labelAllGroupText
                }),
                this.createVendorSpecificField({
                    name: 'conflictResolution',
                    xtype: "checkbox",
                    listeners: {
                        'check': function(cb, checked) {
                            if (!checked) {
                                this.spaceAround.hide();
                            } else {
                                this.spaceAround.show();
                            }
                        },
                        scope: this
                    },
                    fieldLabel: this.conflictResolutionText
                }),
                this.createVendorSpecificField({
                    name: 'spaceAround',
                    hidden: (this.symbolizer.vendorOptions['conflictResolution'] !== true),
                    allowNegative: true,
                    ref: "../spaceAround",
                    fieldLabel: this.spaceAroundText
                }),
                this.createVendorSpecificField({
                    name: 'goodnessOfFit',
                    geometryTypes: ['POLYGON'],
                    fieldLabel: this.goodnessOfFitText
                })
            ]
        }];

        this.addEvents(
            /**
             * Event: change
             * Fires before any field blurs if the field value has changed.
             *
             * Listener arguments:
             * symbolizer - {Object} A symbolizer with text related properties
             *     updated.
             */
            "change"
        ); 
 
        gxp.TextSymbolizer.superclass.initComponent.call(this);
        
    },

    createField: function(config) {
        var field = Ext.ComponentMgr.create(config);
        if (config.geometryTypes) {
            this.on('geometrytype', function(type) {
                if (config.geometryTypes.indexOf(type) === -1) {
                    field.hide();
                }
            });
        }
        return field;
    },

    /**
     * private: method[createVendorSpecificField]
     *  :arg config: ``Object`` config object for the field to create
     *
     *  Create a form field that will generate a VendorSpecific tag.
     */
    createVendorSpecificField: function(config) {
        var listener = function(field, value) {
            // empty VendorOption tags can cause null pointer exceptions in GeoServer
            if (Ext.isEmpty(value)) {
                delete this.symbolizer.vendorOptions[config.name];
            } else {
               if (config.yesno === true) {
                   this.symbolizer.vendorOptions[config.name] = (value == true) ? 'yes': 'no';
               } else {
                   this.symbolizer.vendorOptions[config.name] = value;
               }
            }
            this.fireEvent("change", this.symbolizer);
        };
        var field = Ext.ComponentMgr.create(Ext.applyIf(config, {
            xtype: "numberfield",
            allowNegative: false,
            value: config.value || this.symbolizer.vendorOptions[config.name],
            checked: (config.yesno === true) ? (this.symbolizer.vendorOptions[config.name] === 'yes') : this.symbolizer.vendorOptions[config.name],
            plugins: [{
                ptype: 'gxp_formfieldhelp',
                dismissDelay: 20000,
                helpText: this[config.name.replace(/-/g, '_') + 'Help']
            }]
        }));
        field.on("change", listener, this);
        field.on("check", listener, this);
        if (config.geometryTypes) {
            this.on('geometrytype', function(type) {
                if (config.geometryTypes.indexOf(type) === -1) {
                    field.hide();
                }
            });
        }
        return field;
    },

    showHideGeometryOptions: function() {
        var geomRegex = /gml:((Multi)?(Point|Line|Polygon|Curve|Surface|Geometry)).*/;
        var polygonRegex = /gml:((Multi)?(Polygon|Surface)).*/;
        var pointRegex = /gml:((Multi)?(Point)).*/;
        var lineRegex = /gml:((Multi)?(Line|Curve|Surface)).*/;
        var geomType = null;
        this.attributes.each(function(r) {
            var type = r.get("type");
            var match = geomRegex.exec(type);
            if (match) {
                if (polygonRegex.exec(type)) {
                    geomType = "POLYGON";
                } else if (pointRegex.exec(type)) {
                    geomType = "POINT";
                } else if (lineRegex.exec(type)) {
                    geomType = "LINE";
                }
            }
        }, this);
        if (geomType !== null) {
            this.geometryType = geomType;
            this.fireEvent('geometrytype', geomType);
        }
    }

});

/** api: xtype = gxp_textsymbolizer */
Ext.reg('gxp_textsymbolizer', gxp.TextSymbolizer); 

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires util.js
 * @requires OpenLayers/Control/Attribution.js
 * @requires OpenLayers/Control/ZoomPanel.js
 * @requires OpenLayers/Control/Navigation.js
 * @requires OpenLayers/Kinetic.js
 * @requires OpenLayers/Control/PanPanel.js
 * @requires GeoExt/widgets/MapPanel.js
 * @requires GeoExt/widgets/ZoomSlider.js
 * @requires GeoExt/widgets/tips/ZoomSliderTip.js
 */

/** api: (define)
 *  module = gxp
 *  class = Viewer
 *  base_link = `Ext.util.Observable <http://extjs.com/deploy/dev/docs/?class=Ext.util.Observable>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: Viewer(config)
 *   
 *    A map viewer application framework that can be extended with plugins
 *    for layer sources and tools. Types of viewers that can be built with
 *    this framework range from simple map viewers to complex web-based GIS
 *    applications with capabilities like feature editing, styling and more.
 */
/** api: example
 *    A viewer can be added to an HTML page with a script block containing
 *    something like this for a minimal viewer with an OSM layer:
 *
 *    .. code-block:: javascript
 *
 *      var app = new gxp.Viewer({
 *          sources: {
 *              osm: {
 *                  ptype: "gxp_osmsource"
 *              }
 *          },
 *          map: {
 *              center: [0, 0],
 *              zoom: 2,
 *              layers: [{
 *                  source: "osm",
 *                  name: "mapnik"
 *              }]
 *          }
 *      });
 */
gxp.Viewer = Ext.extend(Ext.util.Observable, {
    
    /** private: property[mapPanel]
     *  ``GeoExt.MapPanel``
     */

    /** api: config[proxy]
     * ``String`` An optional proxy url which can be used to bypass the same
     * origin policy. This will be set as ``OpenLayers.ProxyHost``.
     */
    
    /** api: config[mapItems]
     *  ``Array(Ext.Component)``
     *  Any items to be added to the map panel. A typical item to put on a map
     *  would be a ``GeoExt.ZoomSlider``.
     */

    /** api: config[mapPlugins]
     *  ``Array(Ext.util.Observable)``
     *  Any plugins to be added to the map panel.
     */
     
    /** api: config[portalConfig]
     *  ``Object`` Configuration object for the wrapping container of the
     *  viewer. This will be an ``Ext.Panel`` if it has a ``renderTo``
     *  property, or an ``Ext.Viewport`` otherwise.
     */
    
    /** api: config[portalItems]
     *  ``Array`` Items for the portal. A MapPanel will automatically be added
     *  to the portal, unless ``portalConfig`` has ``items`` configured.
     */
    
    /** api: config[sources]
     *  ``Object`` Layer source configurations for this viewer, keyed by source
     *  id. The source id will be used to reference the layer source in the
     *  ``layers`` array of the ``map`` object.
     */

    /** api: config[map]
     *  ``Object`` Map configuration for this viewer. This object is similar
     *  to the ``GeoExt.MapPanel`` configuration, with the following
     *  exceptions:
     *
     *  * center: ``Array`` of lon (x) and lat (y) values
     *  * items: not available - use ``mapItems`` instead
     *  * tbar: not available - use :class:`gxp.Tool` plugins to populate
     *    the tbar
     *  * wrapDateLine: ``Boolean`` Should we wrap the dateline? Defaults to
     *    true
     *  * numZoomLevels: ``Integer`` The number of zoom levels to use.
     *  * layers: ``Array(Object)``. Each object has a ``source`` property
     *    referencing a :class:`gxp.plugins.LayerSource`. The viewer will call
     *    the ``createLayerRecord`` of this source with the object as
     *    argument, which will result in a layer being created with the
     *    configuration provided here.
     *
     *    Valid config options for all layer sources:
     *
     *    * source: ``String`` referencing a source from ``sources``
     *    * name: ``String`` - the name from the source's ``store`` (only for
     *      sources that maintain a store)
     *    * visibility: ``Boolean`` - initial layer visibility
     *    * opacity: ``Number`` - initial layer.opacity
     *    * group: ``String`` - group for the layer when the viewer also uses a
     *      :class:`gxp.plugins.LayerTree`. Set this to "background" to make
     *      the layer a base layer
     *    * fixed: ``Boolean`` - Set to true to prevent the layer from being
     *      removed by a :class:`gxp.plugins.RemoveLayer` tool and from being
     *      dragged in a :class:`gxp.plugins.LayerTree`
     *    * selected: ``Boolean`` - Set to true to mark the layer selected
     *  * map: not available, can be configured with ``maxExtent``,
     *    ``numZoomLevels`` and ``theme``.
     *  * restrictedExtent: ``Array`` to be consumed by
     *    ``OpenLayers.Bounds.fromArray`` - the restrictedExtent of the map
     *  * maxExtent: ``Array`` to be consumed by
     *    ``OpenLayers.Bounds.fromArray`` - the maxExtent of the map
     *  * numZoomLevels: ``Number`` - the number of zoom levels if not
     *    available on the first layer
     *  * theme: ``String`` - optional theme for the ``OpenLayers.Map``, as
     *    in ``OpenLayers.Map.theme``.
     */
     
    /** api: config[defaultToolType]
     *  ``String``
     *  The default tool plugin type. Default is "gxp_tool"
     */
    defaultToolType: "gxp_tool",

    /** api: config[tools]
     *  ``Array(`` :class:`gxp.plugins.Tool` ``)``
     *  Any tools to be added to the viewer. Tools are plugins that will be
     *  plugged into this viewer's ``portal``. The ``tools`` array is usually
     *  populated with configuration objects for plugins (using a ptype),
     *  rather than instances. A default ptype can be configured with this
     *  viewer's ``defaultToolType`` option.
     */
    
    /** api: property[tools]
     *  ``Object`` Storage of tool instances for this viewer, keyed by id
     */
    tools: null,
     
    /** api: config[defaultSourceType]
     *  ``String``
     *  The default layer source plugin type.
     */
     
    /** api: property[portalItems]
     *  ``Array(Ext.Component)``
     *  Items that make up the portal.
     */
     
    /** api: property[selectedLayer]
     *  ``GeoExt.data.LayerRecord`` The currently selected layer
     */
    selectedLayer: null,
    
    /** api: config[field]
     *  :class:`gxp.form.ViewerField` Optional - set by
     *  :class:`gxp.form.ViewerField` so plugins like
     *  :class:`gxp.plugins.FeatureToField` can set the form field's value.
     */
    
    /** api: property[field]
     *  :class:`gxp.form.ViewerField` Used by plugins to access the form field.
     *  Only available if this viewer is wrapped into an
     *  :class:`Ext.form.ViewerField`.
     */
    
    /** api: config[authenticate]
     *  ``Function`` A global authentication function that is invoked by
     *  :meth:`doAuthorized` if no user is logged in or the current user is not
     *  authorized. That process is supposed to call :meth:`setAuthorizedRoles`
     *  upon successful authentication, and :meth:`cancelAuthentication` if the
     *  user cancels the login process. Typically this function creates and
     *  opens a login window. Optional, default is null.
     */
    
    /** api: property[authenticate]
     *  ``Function`` Like the config option above, but this can be set after
     *  configuration e.g. by a plugin that provides authentication. It can
     *  also be accessed to check if an authentication mechanism is available.
     */
    authenticate: null,
    
    /** api: property[authorizedRoles]
     *  ``Array`` Roles the application is authorized for. This property is
     *  usually set by the :meth:`setAuthorizedRoles` method, which is
     *  typically called by a component that authenticates the user (e.g. a
     *  login window. After authentication, if the client is authorized to do
     *  everything,  this should be set to ``["ROLE_ADMINISTRATOR"]``.
     *
     *  If this property is undefined, the ``isAuthorized()`` method will
     *  return undefined, so plugins can check for that to do their own auth
     *  checks in this case. So if the application uses an authentication
     *  component (e.g. a login window), it is recommended to set this to
     *  ``[]`` (equivalent to "not authorized to do anything") initially.
     */

    /** api: config[saveErrorText]
     *  ``String``
     */
    saveErrorText: "Trouble saving: ",
    
    /** private: method[constructor]
     *  Construct the viewer.
     */
    constructor: function(config) {

        // add any custom application events
        this.addEvents(
            /** api: event[ready]
             *  Fires when application is ready for user interaction.
             */
            "ready",

            /** api: event[beforecreateportal]
             *  Fires before the portal is created by the Ext ComponentManager.
             */
            "beforecreateportal",
            
            /** api: event[portalready]
             *  Fires after the portal is initialized.
             */
            "portalready",

            /** api: event[beforelayerselectionchange]
             *  Fired before the selected set of layers changes.  Listeners 
             *  can return ``false`` to stop the selected layers from being 
             *  changed.
             *
             *  Listeners arguments:
             *
             *  * layerRecord - ``GeoExt.data.LayerRecord`` the record of the
             *    selected layer, or null if no layer is selected.
             */
            "beforelayerselectionchange",
            
            /** api: event[layerselectionchange]
             *  Fired when the selected set of layers changes. 
             *
             *  Listeners arguments:
             *
             *  * layerRecord - ``GeoExt.data.LayerRecord`` the record of the
             *    selected layer, or null if no layer is selected.
             */
            "layerselectionchange",
            
            /** api: event[featureedit]
             *  Fired when features were edited.
             *
             *  Listener arguments:
             *
             *  * featureManager - :class:`gxp.plugins.FeatureManager` the
             *    the feature manager that was used for editing
             *  * layer - ``Object`` object with name and source of the layer
             *    that was edited
             */
            "featureedit",

            /** api: event[authorizationchange]
             *  Fired when the authorizedRoles are changed, e.g. when a user 
             *  logs in or out.
             */
            "authorizationchange",

            /** api: event[beforesave]
             *  Fires before application saves a map. If the listener returns
             *  false, the save is cancelled.
             *
             *  Listeners arguments:
             *
             *  * requestConfig - ``Object`` configuration object for the request,
             *    which has the following properties: method, url and data.
             *  * callback - ``Function`` Optional callback function which was
             *    passed on to the save function.
             */
            "beforesave",

            /** api: event[save]
             *  Fires when the map has been saved.
             *
             *  Listener arguments:
             *  * id - ``Integer`` The identifier of the saved map
             */
            "save",

            /** api: event[beforehashchange]
             *  Fires before the hash is updated after saving a map. Return
             *  false in the listener not to update the hash.
             *
             *  Listeners arguments:
             *  * hash - ``String`` The hash which will be set as 
             *    window.location.hash
             */
            "beforehashchange"
        );
        
        Ext.apply(this, {
            layerSources: {},
            portalItems: []
        });

        // private array of pending getLayerRecord requests
        this.createLayerRecordQueue = [];
        
        (config.loadConfig || this.loadConfig).call(this, config, this.applyConfig);
        gxp.Viewer.superclass.constructor.apply(this, arguments);
        
    },
    
    /** api: method[selectLayer]
     *  :arg record: ``GeoExt.data.LayerRecord``` Layer record.  Call with no 
     *      layer record to remove layer selection.
     *  :returns: ``Boolean`` Layers were set as selected.
     *
     *  TODO: change to selectLayers (plural)
     */
    selectLayer: function(record) {
        record = record || null;
        var changed = false;
        var allow = this.fireEvent("beforelayerselectionchange", record);
        if (allow !== false) {
            changed = true;
            if (this.selectedLayer) {
                this.selectedLayer.set("selected", false);
            }
            this.selectedLayer = record;
            if (this.selectedLayer) {
                this.selectedLayer.set("selected", true);
            }
            this.fireEvent("layerselectionchange", record);
        }
        return changed;
    },
    
    /** api: method[loadConfig]
     *  :arg config: ``Object`` The config object passed to the constructor.
     *
     *  Subclasses that load config asynchronously can override this to load
     *  any configuration before applyConfig is called.
     */
    loadConfig: function(config) {
        this.applyConfig(config);
    },
    
    applyConfig: function(config) {
        this.initialConfig = Ext.apply({}, config);
        Ext.apply(this, this.initialConfig);
        this.load();
    },
    
    load: function() {

        // pass on any proxy config to OpenLayers
        if (this.proxy) {
            OpenLayers.ProxyHost = this.proxy;
        }
        
        this.initMapPanel();
        
        this.initTools();
        
        // initialize all layer source plugins
        var config, queue = [];
        for (var key in this.sources) {
            queue.push(this.createSourceLoader(key));
        }
        
        // create portal when dom is ready
        queue.push(function(done) {
            Ext.onReady(function() {
                this.initPortal();
                done();
            }, this);
        });
        
        gxp.util.dispatch(queue, this.activate, this);
        
    },
    
    createSourceLoader: function(key) {
        return function(done) {
            var config = this.sources[key];
            config.projection = this.initialConfig.map.projection;
            this.addLayerSource({
                id: key,
                config: config,
                callback: done,
                fallback: function(source, msg, details) {
                    // TODO: log these issues somewhere that the app can display
                    // them after loading.
                    // console.log(arguments);
                    done();
                },
                scope: this
            });
        };
    },
    
    addLayerSource: function(options) {
        var id = options.id || Ext.id(null, "gxp-source-");
        var source;
        var config = options.config;
        config.id = id;
        try {
            source = Ext.ComponentMgr.createPlugin(
                config, this.defaultSourceType
            );
        } catch (err) {
            throw new Error("Could not create new source plugin with ptype: " + options.config.ptype);
        }
        source.on({
            ready: {
                fn: function() {
                    var callback = options.callback || Ext.emptyFn;
                    callback.call(options.scope || this, id);
                },
                scope: this,
                single: true
            },
            failure: {
                fn: function() {
                    var fallback = options.fallback || Ext.emptyFn;
                    delete this.layerSources[id];
                    fallback.apply(options.scope || this, arguments);
                },
                scope: this,
                single: true
            }
        });
        this.layerSources[id] = source;
        source.init(this);
        
        return source;
    },
    
    initMapPanel: function() {
        
        var config = Ext.apply({}, this.initialConfig.map);
        var mapConfig = {};
        var baseLayerConfig = {
            wrapDateLine: config.wrapDateLine !== undefined ? config.wrapDateLine : true,
            maxResolution: config.maxResolution,
            numZoomLevels: config.numZoomLevels,
            displayInLayerSwitcher: false
        };
        
        // split initial map configuration into map and panel config
        if (this.initialConfig.map) {
            var props = "theme,controls,resolutions,projection,units,maxExtent,restrictedExtent,maxResolution,numZoomLevels,panMethod".split(",");
            var prop;
            for (var i=props.length-1; i>=0; --i) {
                prop = props[i];
                if (prop in config) {
                    mapConfig[prop] = config[prop];
                    delete config[prop];
                }
            }
        }

        this.mapPanel = Ext.ComponentMgr.create(Ext.applyIf({
            xtype: config.xtype || "gx_mappanel",
            map: Ext.applyIf({
                theme: mapConfig.theme || null,
                controls: mapConfig.controls || [
                    new OpenLayers.Control.Navigation({
                        zoomWheelOptions: {interval: 250},
                        dragPanOptions: {enableKinetic: true}
                    }),
                    new OpenLayers.Control.PanPanel(),
                    new OpenLayers.Control.ZoomPanel(),
                    new OpenLayers.Control.Attribution()
                ],
                maxExtent: mapConfig.maxExtent && OpenLayers.Bounds.fromArray(mapConfig.maxExtent),
                restrictedExtent: mapConfig.restrictedExtent && OpenLayers.Bounds.fromArray(mapConfig.restrictedExtent),
                numZoomLevels: mapConfig.numZoomLevels || 20
            }, mapConfig),
            center: config.center && new OpenLayers.LonLat(config.center[0], config.center[1]),
            resolutions: config.resolutions,
            forceInitialExtent: true,
            layers: [new OpenLayers.Layer(null, baseLayerConfig)],
            items: this.mapItems,
            plugins: this.mapPlugins,
            tbar: config.tbar || new Ext.Toolbar({
                hidden: true
            })
        }, config));
        this.mapPanel.getTopToolbar().on({
            afterlayout: this.mapPanel.map.updateSize,
            show: this.mapPanel.map.updateSize,
            hide: this.mapPanel.map.updateSize,
            scope: this.mapPanel.map
        });
        
        this.mapPanel.layers.on({
            "add": function(store, records) {
                // check selected layer status
                var record;
                for (var i=records.length-1; i>= 0; i--) {
                    record = records[i];
                    if (record.get("selected") === true) {
                        this.selectLayer(record);
                    }
                }
            },
            "remove": function(store, record) {
                if (record.get("selected") === true) {
                    this.selectLayer();
                }
            },
            scope: this
        });
    },
    
    initTools: function() {
        this.tools = {};
        if (this.initialConfig.tools && this.initialConfig.tools.length > 0) {
            var tool;
            for (var i=0, len=this.initialConfig.tools.length; i<len; i++) {
                try {
                    tool = Ext.ComponentMgr.createPlugin(
                        this.initialConfig.tools[i], this.defaultToolType
                    );
                } catch (err) {
                    throw new Error("Could not create tool plugin with ptype: " + this.initialConfig.tools[i].ptype);
                }
                tool.init(this);
            }
        }
    },

    initPortal: function() {
        
        var config = Ext.apply({}, this.portalConfig);
        
        if (this.portalItems.length === 0) {
            this.mapPanel.region = "center";
            this.portalItems.push(this.mapPanel);
        }

        this.fireEvent("beforecreateportal");
        
        this.portal = Ext.ComponentMgr.create(Ext.applyIf(config, {
            layout: "fit",
            hideBorders: true,
            items: {
                layout: "border",
                deferredRender: false,
                items: this.portalItems
            }
        }), config.renderTo ? "panel" : "viewport");
        
        this.fireEvent("portalready");
    },
    
    activate: function() {
        // initialize tooltips
        Ext.QuickTips.init();

        // add any layers from config
        this.addLayers();
        
        // respond to any queued requests for layer records
        this.checkLayerRecordQueue();
        
        // broadcast ready state
        this.fireEvent("ready");
    },
    
    addLayers: function() {
        var mapConfig = this.initialConfig.map;
        if(mapConfig && mapConfig.layers) {
            var conf, source, record, baseRecords = [], overlayRecords = [];
            for (var i=0; i<mapConfig.layers.length; ++i) {
                conf = mapConfig.layers[i];
                source = this.layerSources[conf.source];
                // source may not have loaded properly (failure handled elsewhere)
                if (source) {
                    record = source.createLayerRecord(conf);
                    if (record) {
                        if (record.get("group") === "background") {
                            baseRecords.push(record);
                        } else {
                            overlayRecords.push(record);
                        }
                    }
                } else if (window.console) {
                    console.warn("Non-existing source '" + conf.source + "' referenced in layer config.");
                } 
            }
            
            var panel = this.mapPanel;
            var map = panel.map;
            
            var records = baseRecords.concat(overlayRecords);
            if (records.length) {
                panel.layers.add(records);
            }
            
        }        
    },
    
    /** api: method[getLayerRecordFromMap]
     *  :arg config: ``Object`` A minimal layer configuration object with source
     *      and name properties.
     *  :returns: ``GeoExt.data.LayerRecord``
     *
     *  Retrieves a layer record from the map.
     */
    getLayerRecordFromMap: function(config) {
        var record = null;
        if (this.mapPanel) {
            this.mapPanel.layers.each(function(rec) {
                if (rec.get("source") == config.source && rec.get("name") == config.name) {
                    record = rec;
                    return false;
                }
            });
        }
        return record;
    },
    
    /** api: method[createLayerRecord]
     *  :arg config: ``Object`` A minimal layer configuration object with source
     *      and name properties.
     *  :arg callback: ``Function`` A function to be called with the layer 
     *      record that corresponds to the given config.
     *  :arg scope: ``Object`` Optional scope for the callback.
     *
     *  Asyncronously retrieves a layer record given a basic layer config.  The
     *  callback will be called as soon as the desired layer source is ready.
     *  This method should only be called to retrieve layer records from sources
     *  configured before the call.
     */
    createLayerRecord: function(config, callback, scope) {
        this.createLayerRecordQueue.push({
            config: config,
            callback: callback,
            scope: scope
        });
        this.checkLayerRecordQueue();
    },
    
    /** private: method[checkLayerRecordQueue]
     *  Check through createLayerRecord requests to see if any can be satisfied.
     */
    checkLayerRecordQueue: function() {
        var request, source, s, record, called;
        var remaining = [];
        for (var i=0, ii=this.createLayerRecordQueue.length; i<ii; ++i) {
            called = false;
            request = this.createLayerRecordQueue[i];
            s = request.config.source;
            if (s in this.layerSources) {
                source = this.layerSources[s];
                record = source.createLayerRecord(request.config);
                if (record) {
                    // we call this in the next cycle to guarantee that
                    // createLayerRecord returns before callback is called
                    (function(req, rec) {
                        window.setTimeout(function() {
                            req.callback.call(req.scope, rec);                        
                        }, 0);
                    })(request, record);
                    called = true;
                } else if (source.lazy) {
                    source.store.load({
                        callback: this.checkLayerRecordQueue,
                        scope: this
                    });
                }
            }
            if (!called) {
                remaining.push(request);
            }
        }
        this.createLayerRecordQueue = remaining;
    },
    
    /** api:method[getSource]
     *  :arg layerRec: ``GeoExt.data.LayerRecord`` the layer to get the
     *      source for.
     */
    getSource: function(layerRec) {
        return layerRec && this.layerSources[layerRec.get("source")];
    },

    /** private: method[getState]
     *  :returns: ``Object`` Representation of the app's current state.
     */ 
    getState: function() {

        // start with what was originally given
        var state = Ext.apply({}, this.initialConfig);
        
        // update anything that can change
        var center = this.mapPanel.map.getCenter();
        Ext.apply(state.map, {
            center: [center.lon, center.lat],
            zoom: this.mapPanel.map.zoom,
            layers: []
        });
        
        // include all layer config
        var sources = {};
        this.mapPanel.layers.each(function(record){
            var layer = record.getLayer();
            if (layer.displayInLayerSwitcher && !(layer instanceof OpenLayers.Layer.Vector) ) {
                var id = record.get("source");
                var source = this.layerSources[id];
                if (!source) {
                    throw new Error("Could not find source for record '" + record.get("name") + " and layer " + layer.name + "'");
                }
                // add layer
                state.map.layers.push(source.getConfigForRecord(record));
                if (!sources[id]) {
                    sources[id] = source.getState();
                }
            }
        }, this);
        // update sources, adding new ones
        Ext.apply(this.sources, sources);
        
        //standardize portal configuration to portalConfig
        /*
        if (state.portalItems) {
            //initial config included both portal config and items
            if (state.portalConfig && state.portalConfig.items && state.portalConfig.items.length) {
                //merge arrays of portalItems and portalConfig.items
                for (var items = state.portalItems, i = 0, len = items.length; i < len; i++) {
                    var item = items[i];
                    if (state.portalConfig.items.indexOf(item) == -1) {
                        state.portalConfig.items.push(item);
                    }
                }
            }
            else if (state.portalItems && state.portalItems.length) {
                !state.portalConfig && (state.portalConfig = {});
                state.portalConfig.items = state.portalItems;
            }
        }
        */
       
        //get tool states, for most tools this will be the same as its initial config
        state.tools = [];
        Ext.iterate(this.tools,function(key,val,obj){
            //only get and persist the state if there a tool specific getState method
            if(val.getState != gxp.plugins.Tool.prototype.getState){
                state.tools.push(val.getState());
            }
        });
        return state;
    },
    
    /** api: method[isAuthorized]
     *  :arg roles: ``String|Array`` optional, default is "ROLE_ADMINISTRATOR".
     *       If an array is provided, this method will return if any of the
     *       roles in the array is authorized.
     *  :returns: ``Boolean`` The user is authorized for the given role.
     *
     *  Returns true if the client is authorized with the provided role.
     *  In cases where the application doesn't explicitly handle authentication,
     *  the user is assumed to be authorized for all roles.  This results in
     *  authentication challenges from the browser when an action requires 
     *  credentials.
     */
    isAuthorized: function(roles) {
        /**
         * If the application doesn't support authentication, we expect 
         * authorizedRoles to be undefined.  In this case, from the UI 
         * perspective, we treat the user as if they are authorized to do
         * anything.  This will result in just-in-time authentication challenges
         * from the browser where authentication credentials are needed.
         * If the application does support authentication, we expect
         * authorizedRoles to be a list of roles for which the user is 
         * authorized.
         */
        var authorized = true;
        if (this.authorizedRoles) {
            authorized = false;
            if (!roles) {
                roles = "ROLE_ADMINISTRATOR";
            }
            if (!Ext.isArray(roles)) {
                roles = [roles];
            }
            for (var i=roles.length-1; i>=0; --i) {
                if (~this.authorizedRoles.indexOf(roles[i])) {
                    authorized = true;
                    break;
                }
            }
        }
        return authorized;
    },

    /** api: method[setAuthorizedRoles]
     *  :arg authorizedRoles: ``Array``
     *
     *  Change the authorized roles.
     */
    setAuthorizedRoles: function(authorizedRoles) {
        this.authorizedRoles = authorizedRoles;
        this.fireEvent("authorizationchange");
    },
    
    /** api: method[cancelAuthentication]
     *  Cancel an authentication process.
     */
    cancelAuthentication: function() {
        if (this._authFn) {
            this.un("authorizationchange", this._authFn, this);
        }
        this.fireEvent("authorizationchange");
    },
    
    /** api: method[isAuthenticated]
     *  :returns: ``Boolean`` The user has authenticated.
     *
     *  Determines whether a user has logged in.  In cases where the application
     *  doesn't provide a login dialog, the user will be considered logged in.
     *  In this same case, where components require authentication, the browser
     *  will prompt for credentials when needed.
     */
    isAuthenticated: function(role) {
        /**
         * If the application supports authentication, we expect a list of
         * authorized roles to be set (length zero if user has not logged in).
         * If the application does not support authentication, authorizedRoles
         * should be undefined.  In this case, we return true so that components
         * that require authentication can still be enabled.  This leaves the
         * authentication challenge up to the browser.
         */
        return !this.authorizedRoles || this.authorizedRoles.length > 0;
    },
    
    /** api: method[doAuthorized]
     *  :param roles: ``Array`` Roles required for invoking the action
     *  :param callback: ``Function`` The action to perform
     *  :param scope: ``Object`` The execution scope for the callback
     *
     *  Performs an action (defined as ``callback`` function), but only if
     *  the user is authorized to perform it. If no user is logged in or the
     *  logged in user is not authorized, the viewer's :meth:`authenticate`
     *  function will be invoked. This method is usually called by plugins.
     */
    doAuthorized: function(roles, callback, scope) {
        if (this.isAuthorized(roles) || !this.authenticate) {
            window.setTimeout(function() { callback.call(scope); }, 0);
        } else {
            this.authenticate();
            this._authFn = function authFn() {
                delete this._authFn;
                this.doAuthorized(roles, callback, scope, true);
            };
            this.on("authorizationchange", this._authFn, this, {single: true});
        }
    },

    /** private: method[save]
     *
     * Saves the map config and displays the URL in a window.
     */
    save: function(callback, scope) {
        var configStr = Ext.util.JSON.encode(this.getState());
        var method, url;
        if (this.id) {
            method = "PUT";
            url = "../maps/" + this.id;
        } else {
            method = "POST";
            url = "../maps/";
        }
        var requestConfig = {
            method: method,
            url: url,
            data: configStr
        };
        if (this.fireEvent("beforesave", requestConfig, callback) !== false) {
            OpenLayers.Request.issue(Ext.apply(requestConfig, {
                callback: function(request) {
                    this.handleSave(request);
                    if (callback) {
                        callback.call(scope || this, request);
                    }
                },
                scope: this
            }));
        }
    },

    /** private: method[handleSave]
     *  :arg: ``XMLHttpRequest``
     */
    handleSave: function(request) {
        if (request.status == 200) {
            var config = Ext.util.JSON.decode(request.responseText);
            var mapId = config.id;
            if (mapId) {
                this.id = mapId;
                var hash = "#maps/" + mapId;
                if (this.fireEvent("beforehashchange", hash) !== false) {
                    window.location.hash = hash;
                }
                this.fireEvent("save", this.id);
            }
        } else {
            if (window.console) {
                console.warn(this.saveErrorText + request.responseText);
            }
        }
    },
    
    /** api: method[destroy]
     */
    destroy: function() {
        //TODO there is probably more that needs to be destroyed
        this.mapPanel.destroy();
        this.portal && this.portal.destroy();
    }
    
});

(function() {
    // OGC "standardized rendering pixel size"
    OpenLayers.DOTS_PER_INCH = 25.4 / 0.28;
})();

/**
 * Copyright (c) 2008-2012 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp.tree
 *  class = TreeGridNodeUI
 */
Ext.ns("gxp.tree");

/** api: constructor
 *  .. class:: TreeGridNodeUI(config)
 *
 *      Create a new UI for tree nodes of a TreeGrid which adds the checkbox.
 */
gxp.tree.TreeGridNodeUI = Ext.ux && Ext.ux.tree && Ext.ux.tree.TreeGridNodeUI && Ext.extend(Ext.ux.tree.TreeGridNodeUI, {

    renderElements : function(n, a, targetNode, bulkRender){
        var t = n.getOwnerTree(),
            cols = t.columns,
            c = cols[0],
            i, buf, len;

        this.indentMarkup = n.parentNode ? n.parentNode.ui.getChildIndent() : '';

        // start of change
        var cb = Ext.isBoolean(a.checked);
        // end of change
        buf = [
             '<tbody class="x-tree-node">',
                '<tr ext:tree-node-id="', n.id ,'" class="x-tree-node-el x-tree-node-leaf ', a.cls, '">',
                    '<td class="x-treegrid-col">',
                        '<span class="x-tree-node-indent">', this.indentMarkup, "</span>",
                        '<img src="', this.emptyIcon, '" class="x-tree-ec-icon x-tree-elbow" />',
                        '<img src="', a.icon || this.emptyIcon, '" class="x-tree-node-icon', (a.icon ? " x-tree-node-inline-icon" : ""), (a.iconCls ? " "+a.iconCls : ""), '" unselectable="on" />',
                        // start of change
                        cb ? ('<input class="x-tree-node-cb" type="checkbox" ' + (a.checked ? 'checked="checked" />' : '/>')) : '',
                        // end of change
                        '<a hidefocus="on" class="x-tree-node-anchor" href="', a.href ? a.href : '#', '" tabIndex="1" ',
                            a.hrefTarget ? ' target="'+a.hrefTarget+'"' : '', '>',
                        '<span unselectable="on">', (c.tpl ? c.tpl.apply(a) : a[c.dataIndex] || c.text), '</span></a>',
                    '</td>'
        ];

        for(i = 1, len = cols.length; i < len; i++){
            c = cols[i];
            buf.push(
                    '<td class="x-treegrid-col ', (c.cls ? c.cls : ''), '">',
                        '<div unselectable="on" class="x-treegrid-text"', (c.align ? ' style="text-align: ' + c.align + ';"' : ''), '>',
                            (c.tpl ? c.tpl.apply(a) : a[c.dataIndex]),
                        '</div>',
                    '</td>'
            );
        }

        buf.push(
            '</tr><tr class="x-tree-node-ct"><td colspan="', cols.length, '">',
            '<table class="x-treegrid-node-ct-table" cellpadding="0" cellspacing="0" style="table-layout: fixed; display: none; width: ', t.innerCt.getWidth() ,'px;"><colgroup>'
        );
        for(i = 0, len = cols.length; i<len; i++) {
            buf.push('<col style="width: ', (cols[i].hidden ? 0 : cols[i].width) ,'px;" />');
        }
        buf.push('</colgroup></table></td></tr></tbody>');

        if(bulkRender !== true && n.nextSibling && n.nextSibling.ui.getEl()){
            this.wrap = Ext.DomHelper.insertHtml("beforeBegin", n.nextSibling.ui.getEl(), buf.join(''));
        }else{
            this.wrap = Ext.DomHelper.insertHtml("beforeEnd", targetNode, buf.join(''));
        }
        this.elNode = this.wrap.childNodes[0];
        this.ctNode = this.wrap.childNodes[1].firstChild.firstChild;
        var cs = this.elNode.firstChild.childNodes;
        this.indentNode = cs[0];
        this.ecNode = cs[1];
        this.iconNode = cs[2];
        // start of change
        var index = 3;
        if(cb){
            this.checkbox = cs[3];
            // fix for IE6
            this.checkbox.defaultChecked = this.checkbox.checked;
            index++;
        }
        this.anchor = cs[index];
        this.textNode = cs[index].firstChild;
        // end of change
    }

});

/**
 * Copyright (c) 2008-2012 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires widgets/tree/TreeGridNodeUI.js
 */

/** api: (define)
 *  module = gxp.tree
 *  class = SymbolizerLoader
 *  base_link = `Ext.util.Observable <http://extjs.com/deploy/dev/docs/?class=Ext.util.Observable>`_
 */
Ext.ns("gxp.tree");

gxp.tree.SymbolizerLoader = function(config) {
    Ext.apply(this, config);
    gxp.tree.SymbolizerLoader.superclass.constructor.call(this);
};

/** api: constructor
 *  .. class:: SymbolizerLoader(config)
 *
 *      Create a new tree loader displaying symbolizers and its subtypes.
 */
Ext.extend(gxp.tree.SymbolizerLoader, Ext.util.Observable, {

    /** api: config[symbolizers]
     *  ``Array`` Array of symbolizers to display.
     */
    symbolizers: null,

    /** private: method[load]
     *  :param node: ``Ext.tree.TreeNode`` The node to add children to.
     *  :param callback: ``Function``
     */
    load: function(node, callback) {
        if(this.fireEvent("beforeload", this, node)) {
            while (node.firstChild) {
                node.removeChild(node.firstChild);
            }
            var divTpl = new Ext.Template('<div class="gxp-symbolgrid-swatch" id="{id}"></div>');
            for (var i=0, ii=this.symbolizers.length;i<ii;++i) {
                var symbolizer = this.symbolizers[i];
                var key = symbolizer.CLASS_NAME.substring(symbolizer.CLASS_NAME.lastIndexOf(".")+1);
                var fullSymbolizer = symbolizer.clone();
                if (key === 'Text') {
                    fullSymbolizer.label = "Ab";
                    if (fullSymbolizer.fillColor || fullSymbolizer.graphicName) {
                        fullSymbolizer.graphic = true;
                    }
                }
                var id = Ext.id();
                var child = this.createNode({
                    type: key, 
                    expanded: true, 
                    rendererId: id, 
                    originalSymbolizer: symbolizer,
                    symbolizer: fullSymbolizer, 
                    iconCls: 'gxp-icon-symbolgrid-' + key.toLowerCase(),
                    preview: divTpl.applyTemplate({id: id})
                });
                if (key === "Polygon" || key === "Point") {
                    id = Ext.id();
                    var strokeSym = fullSymbolizer.clone();
                    strokeSym.fill = false;
                    child.appendChild(this.createNode({
                        checked: fullSymbolizer.stroke !== undefined ? fullSymbolizer.stroke : true,
                        iconCls: "gxp-icon-symbolgrid-none",
                        type: 'Stroke', 
                        symbolizer: strokeSym,
                        rendererId: id, 
                        preview: divTpl.applyTemplate({id: id})
                    }));
                    id = Ext.id();
                    var fillSym = fullSymbolizer.clone();
                    fillSym.stroke = false;
                    child.appendChild(this.createNode({
                        checked: fullSymbolizer.fill !== undefined ? fullSymbolizer.fill : true,
                        iconCls: "gxp-icon-symbolgrid-none",
                        type: 'Fill', 
                        symbolizer: fillSym,
                        rendererId: id, 
                        preview: divTpl.applyTemplate({id: id})
                    }));
                } else if (key === "Line") {
                    id = Ext.id();
                    child.appendChild(this.createNode({
                        type: 'Stroke',
                        checked: true,
                        iconCls: "gxp-icon-symbolgrid-none",
                        symbolizer: fullSymbolizer.clone(),
                        rendererId: id,
                        preview: divTpl.applyTemplate({id: id})
                    }));
                } else if (key === "Text") {
                    id = Ext.id();
                    var labelSym = fullSymbolizer.clone();
                    labelSym.graphic = false;
                    child.appendChild(this.createNode({
                        checked: true,
                        iconCls: "gxp-icon-symbolgrid-none",
                        type: 'Label',
                        symbolizer: labelSym,
                        rendererId: id,
                        preview: divTpl.applyTemplate({id: id})
                    }));
                    id = Ext.id();
                    var graphicSym = fullSymbolizer.clone();
                    graphicSym.label = "";
                    child.appendChild(this.createNode({
                        checked: fullSymbolizer.graphic,
                        iconCls: "gxp-icon-symbolgrid-none",
                        type: 'Graphic',
                        symbolizer: graphicSym,
                        rendererId: id,
                        preview: divTpl.applyTemplate({id: id})
                    }));
                }
                node.appendChild(child);
            }
            if(typeof callback == "function"){
                callback();
            }
            this.fireEvent("load", this, node);
        }
    },

    /** api: method[createNode]
     *  :param attr: ``Object`` attributes for the new node
     *
     *  Override this function for custom TreeNode node implementation, or to
     *  modify the attributes at creation time.
     */
    createNode: function(attr) {
        if(this.baseAttrs){
            Ext.apply(attr, this.baseAttrs);
        }
        if (!attr.uiProvider) {
            attr.uiProvider = gxp.tree.TreeGridNodeUI;
        }
        attr.nodeType = attr.nodeType || "node";
        return new Ext.tree.TreePanel.nodeTypes[attr.nodeType](attr);
    }

});

/**
 * Copyright (c) 2008-2012 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires widgets/tree/SymbolizerLoader.js
 * @requires GeoExt/widgets/FeatureRenderer.js
 */

/** api: (define)
 *  module = gxp.grid
 *  class = SymbolizerGrid
 */
Ext.namespace("gxp.grid");

/** api: constructor
 *  .. class:: SymbolizerGrid(config)
 *
 *      Create a new grid displaying the symbolizers of a style and its subtypes.
 */
gxp.grid.SymbolizerGrid = Ext.ux && Ext.ux.tree && Ext.ux.tree.TreeGrid && Ext.extend(Ext.ux.tree.TreeGrid, {

    /** api: config[symbolizers]
     *  ``Array`` Array of OpenLayers symbolizer objects which will be
     *  displayed by the grid.
     */
    symbolizers: null,

    /** private overrides */
    enableHdMenu: false,
    enableSort: false,
    useArrows: false,
    columnResize: false,
    cls: "gxp-symbolgrid",

    /** i18n */
    typeTitle: "Symbolizer Type",
    previewTitle: "Preview",

    /** api: method[initComponent]
     *  Initializes the SymbolizerGrid.
     */
    initComponent: function() {
        this.on('checkchange', this.onCheckChange, this);
        this.loader = new gxp.tree.SymbolizerLoader({
            symbolizers: this.symbolizers
        });
        this.columns = [{
            header: this.typeTitle,
            dataIndex: 'type',
            width: 200
        }, {
            header: this.previewTitle,
            width: 100,
            dataIndex: 'preview'
        }];
        gxp.grid.SymbolizerGrid.superclass.initComponent.call(this);
    },

    /** api: method[getSymbolizers]
     *  :returns: ``Array`` Array of symbolizers.
     *
     *  Get the current state of the symbolizers array. Symbolizers who don't
     *  have any visible children will be filtered out.
     */
    getSymbolizers: function() {
        var symbolizers = [];
        this.root.eachChild(function(n){
            var childVisible = false;
            n.eachChild(function(c) {
                var type = c.attributes.type.toLowerCase();
                if (type !== "label") {
                    n.attributes.originalSymbolizer[type] = c.attributes.checked;
                }
                if (c.attributes.checked === true) {
                    childVisible = true;
                }
            });
            if (childVisible) {
                symbolizers.push(n.attributes.originalSymbolizer);
            }
        });
        return symbolizers;
    },

    /** private: method[beforeDestroy]
     *  Clean up.
     */
    beforeDestroy : function(){
        this.root.cascade(function(node) {
            if (node.attributes.featureRenderer) {
                node.attributes.featureRenderer.destroy();
                node.attributes.featureRenderer = null;
            }
        });
        gxp.grid.SymbolizerGrid.superclass.onDestroy.call(this);
    },

    /** private: method[onCheckChange]
     *  :arg node: ``Ext.data.Node``
     *  :arg checked: ``Boolean``
     *
     *  Handle the check change event. Update the symbolizers and their
     *  swatches.
     */
    onCheckChange: function(node, checked) {
        var a = node.attributes;
        var r = a.featureRenderer;
        var type = a.type.toLowerCase();
        var symbolizer = a.symbolizer;
        var fullSymbolizer = node.parentNode.attributes.symbolizer;
        if (type !== "label") {
            // special handling for graphic, can only be turned on if label is on
            if (type === 'graphic') {
                var label = node.parentNode.findChild('type', 'Label');
                if (label !== null) {
                    var labelChecked = label.attributes.checked;
                    if ((labelChecked && checked) || !checked) {
                        fullSymbolizer[type] = symbolizer[type] = checked;
                    } else {
                        node.getUI().toggleCheck(false);
                    }
                }
            } else {
                fullSymbolizer[type] = symbolizer[type] = checked;
            }
        } else {
            if (!checked) {
                symbolizer[type] = fullSymbolizer[type] = "";
                var graphic = node.parentNode.findChild('type', 'Graphic');
                if (graphic !== null) {
                    graphic.getUI().toggleCheck(false);
                }
            } else {
                symbolizer[type] = fullSymbolizer[type] = "Ab";
            }
        }
        if (node.parentNode.attributes.featureRenderer) {
            node.parentNode.attributes.featureRenderer.update({
                symbolizers: [fullSymbolizer]
            });
        }
        r.update({symbolizers: [symbolizer]});
    },

    /** private: method[afterRender]
     *  Create the swatches.
     */
    afterRender: function() {
        gxp.grid.SymbolizerGrid.superclass.afterRender.call(this);
        this.root.cascade(function(node) {
            if (node.attributes.rendererId) {
                var ct = Ext.get(node.attributes.rendererId);
                if (ct) {
                    node.attributes.featureRenderer = new GeoExt.FeatureRenderer({
                        symbolizers: [node.attributes.symbolizer],
                        renderTo: ct, 
                        width:21, 
                        height: 21
                    });
                }
            }
        });
    }

});

/** api: xtype = gxp_symbolgrid */
gxp.grid.SymbolizerGrid && Ext.reg('gxp_symbolgrid', gxp.grid.SymbolizerGrid);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @include data/AutoCompleteReader.js
 * @include data/AutoCompleteProxy.js
 */

/** api: (define)
 *  module = gxp.form
 *  class = AutoCompleteComboBox
 *  base_link = `Ext.form.ComboBox <http://extjs.com/deploy/dev/docs/?class=Ext.form.ComboBox>`_
 */
Ext.namespace("gxp.form");

/** api: constructor
 *  .. class:: AutoCompleteComboBox(config)
 *
 *  Creates an autocomplete combo box that issues queries to a WFS typename.
 *
 */
gxp.form.AutoCompleteComboBox = Ext.extend(Ext.form.ComboBox, {

    /** api: xtype = gxp_autocompletecombo */
    xtype: "gxp_autocompletecombo",

    /** api: config[fieldName]
     *  ``String``
     *  The name of the field/attribute to search on. The "name" of this form
     *  field will also default to fieldName if not provided explicitly. 
     */ 
    fieldName: null,

    /**
     * api: config[featureType]
     * ``String``
     * The WFS featureType to search on.
     */
    featureType: null,

    /**
     * api: config[featurePrefix]
     * ``String``
     * The featurePrefix associated with the featureType.
     */
    featurePrefix: null,

    /**
     * api: config[fieldLabel]
     * ``String``
     * The label to associate with this search field.
     */
    fieldLabel: null,

    /**
     * api: config[geometryName]
     * ``String``
     * The name of the geometry field.
     */
    geometryName: null,

    /**
     * api: config[maxFeatures]
     * ``Integer``
     * The maximum number of features to retrieve in one search action. 
     * Defaults to 500.
     */
    maxFeatures: 500,

    /**
     * api: config[url]
     * ``String``
     * The url of the WFS to search on.
     */
    url: null,

    /**
     * api: config[srsName]
     * ``String``
     * The SRS to use in the WFS GetFeature request.
     */ 
    srsName: null,

    autoHeight: true,

    hideTrigger: true,

    /** api: config[customSortInfo]
     *  ``Object``
     *  Providing custom sort info allows sorting of a single field value by
     *  multiple parts within that value.  For example, a value representing
     *  a street address like "1234 Main Street" would make sense to sort first
     *  by "Main Street" (case insensitive) and then by "1234" (as an integer).
     *  The ``customSortInfo`` object must contain ``matcher`` and ``parts``
     *  properties.
     *
     *  The ``matcher`` value will be used to create a regular expression (with 
     *  ``new RegExp(matcher)``).  This regular expression is assumed to have 
     *  grouping parentheses for each part of the value to be compared.
     * 
     *  The ``parts`` value must be an array with the same length as the number
     *  of groups, or parts of the value to be compared.  Each item in the 
     *  ``parts`` array may have an ``order`` property and a ``sortType``
     *  property.  The optional ``order`` value determines precedence for a part
     *  (e.g. part with order 0 will be compared before part with order 1).
     *  The optional ``sortType`` value must be a string matching one of the
     *  ``Ext.data.SortTypes`` methods (e.g. "asFloat").
     *
     *  Example custom sort info to match addresses like "123 Main St" first by
     *  street name and then by number:
     *
     *  .. code-block:: javascript
     *  
     *      customSortInfo: {
     *          matcher: "^(\\d+)\\s(.*)$",
     *          parts: [
     *              {order: 1, sortType: "asInt"},
     *              {order: 0, sortType: "asUCString"}
     *          ]
     *      }
     */
    customSortInfo: null,

    /** private: method[initComponent]
     *  Override
     */
    initComponent: function() {
        var fields = [{name: this.fieldName}];
        var propertyNames = [this.fieldName];
        if (this.geometryName !== null) {
            fields.push({name: this.geometryName});
            propertyNames.push(this.geometryName);
        }
        if (!this.name) {
            this.name = this.fieldName;
        }
        this.valueField = this.displayField = this.fieldName;
        this.tpl = new Ext.XTemplate('<tpl for="."><div class="x-form-field">','{'+this.fieldName+'}','</div></tpl>');
        this.itemSelector = 'div.x-form-field';
        this.store = new Ext.data.Store({
            fields: fields,
            reader: new gxp.data.AutoCompleteReader({uniqueField: this.fieldName}, propertyNames),
            proxy: new gxp.data.AutoCompleteProxy({protocol: new OpenLayers.Protocol.WFS({
                version: "1.1.0",
                url: this.url,
                featureType: this.featureType,
                featurePrefix: this.featurePrefix,
                srsName: this.srsName,
                propertyNames: propertyNames,
                maxFeatures: this.maxFeatures
            }), setParamsAsOptions: true}),
            sortInfo: this.customSortInfo && {
                field: this.fieldName,
                direction: this.customSortInfo.direction
            }
        });
        if (this.customSortInfo) {
            this.store.createSortFunction = this.createCustomSortFunction();
        }
        return gxp.form.AutoCompleteComboBox.superclass.initComponent.apply(this, arguments);
    },
    
    /** private: method[createCustomSortFunction]
     *  If a ``customSortInfo`` property is provided, this method will be called
     *  to replace the store's ``createSortFunction`` method.
     */
    createCustomSortFunction: function() {

        /** Example customSortInfo:
         *
         *  customSortInfo: {
         *      matcher: "^(\\d+)\\s(.*)$",
         *      parts: [
         *          {order: 1, sortType: "asInt"},
         *          {order: 0, sortType: "asUCString"}
         *      ]
         *  };
         */
        
        var matchRE = new RegExp(this.customSortInfo.matcher);
        var num = this.customSortInfo.parts.length;
        var orderLookup = new Array(num);
        var part;
        for (var i=0; i<num; ++i) {
            part = this.customSortInfo.parts[i];
            orderLookup[i] = {
                index: i,
                sortType: Ext.data.SortTypes[part.sortType || "none"],
                order: part.order || 0
            };
        }
        orderLookup.sort(function(a, b) {
            return a.order - b.order;
        });

        // this method is the replacement for store.createSortFunction
        return function(field, direction) {
            direction = direction || "ASC";
            var directionModifier = direction.toUpperCase() == "DESC" ? -1 : 1;
            
            // this is our custom comparison function that uses the given regex
            // to sort by parts of a single field value
            return function(r1, r2) {
                var d1 = r1.data[field];
                var d2 = r2.data[field];
                var matches1 = matchRE.exec(d1) || [];
                var matches2 = matchRE.exec(d2) || [];
                
                // compare matched parts in order - stopping at first unequal match
                var cmp, v1, v2, lookup;
                for (var i=0, ii=orderLookup.length; i<ii; ++i) {
                    lookup = orderLookup[i];
                    v1 = lookup.sortType(matches1[lookup.index + 1] || d1);
                    v2 = lookup.sortType(matches2[lookup.index + 1] || d2);
                    cmp = (v1 > v2 ? 1 : (v1 < v2 ? -1 : 0));
                    if (cmp) {
                        break;
                    }
                }
                // flip the sign if descending
                return directionModifier * cmp;
            };
        };

    }

});

Ext.reg(gxp.form.AutoCompleteComboBox.prototype.xtype, gxp.form.AutoCompleteComboBox);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires OpenLayers/Filter/Comparison.js
 */

/** api: (define)
 *  module = gxp.form
 *  class = ComparisonComboBox
 *  base_link = `Ext.form.ComboBox <http://extjs.com/deploy/dev/docs/?class=Ext.form.ComboBox>`_
 */
Ext.namespace("gxp.form");

/** api: constructor
 *  .. class:: ComparisonComboBox(config)
 *   
 *      A combo box for selecting comparison operators available in OGC
 *      filters.
 */
gxp.form.ComparisonComboBox = Ext.extend(Ext.form.ComboBox, {
    
    allowedTypes: [
        [OpenLayers.Filter.Comparison.EQUAL_TO, "="],
        [OpenLayers.Filter.Comparison.NOT_EQUAL_TO, "<>"],
        [OpenLayers.Filter.Comparison.LESS_THAN, "<"],
        [OpenLayers.Filter.Comparison.GREATER_THAN, ">"],
        [OpenLayers.Filter.Comparison.LESS_THAN_OR_EQUAL_TO, "<="],
        [OpenLayers.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO, ">="],
        [OpenLayers.Filter.Comparison.LIKE, "like"],
        [OpenLayers.Filter.Comparison.BETWEEN, "between"]
    ],

    allowBlank: false,

    mode: "local",

    typeAhead: true,

    forceSelection: true,

    triggerAction: "all",

    width: 50,

    editable: true,
  
    initComponent: function() {
        var defConfig = {
            displayField: "name",
            valueField: "value",
            store: new Ext.data.SimpleStore({
                data: this.allowedTypes,
                fields: ["value", "name"]
            }),
            value: (this.value === undefined) ? this.allowedTypes[0][0] : this.value,
            listeners: {
                // workaround for select event not being fired when tab is hit
                // after field was autocompleted with forceSelection
                "blur": function() {
                    var index = this.store.findExact("value", this.getValue());
                    if (index != -1) {
                        this.fireEvent("select", this, this.store.getAt(index));
                    } else if (this.startValue != null) {
                        this.setValue(this.startValue);
                    }
                }
            }
        };
        Ext.applyIf(this, defConfig);
        
        gxp.form.ComparisonComboBox.superclass.initComponent.call(this);
    }
});

Ext.reg("gxp_comparisoncombo", gxp.form.ComparisonComboBox);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp.form
 *  class = ColorField
 *  base_link = `Ext.form.TextField <http://extjs.com/deploy/dev/docs/?class=Ext.form.TextField>`_
 */
Ext.namespace("gxp.form");

/** api: constructor
 *  .. class:: ColorField(config)
 *   
 *      A text field that colors its own background based on the input value.
 *      The value may be any one of the 16 W3C supported CSS color names
 *      (http://www.w3.org/TR/css3-color/).  The value can also be an arbitrary
 *      RGB hex value prefixed by a '#' (e.g. '#FFCC66').
 */
gxp.form.ColorField = Ext.extend(Ext.form.TextField,  {

    /** api: property[cssColors]
     *  ``Object``
     *  Properties are supported CSS color names.  Values are RGB hex strings
     *  (prefixed with '#').
     */
    cssColors: {
        aqua: "#00FFFF",
        black: "#000000",
        blue: "#0000FF",
        fuchsia: "#FF00FF",
        gray: "#808080",
        green: "#008000",
        lime: "#00FF00",
        maroon: "#800000",
        navy: "#000080",
        olive: "#808000",
        purple: "#800080",
        red: "#FF0000",
        silver: "#C0C0C0",
        teal: "#008080",
        white: "#FFFFFF",
        yellow: "#FFFF00"
    },
    
    /** api: config[defaultBackground]
     *  The default background color if the symbolizer has no fillColor set.
     *  Defaults to #ffffff.
     */
    defaultBackground: "#ffffff",

    /** private: method[initComponent]
     *  Override
     */
    initComponent: function() {
        if (this.value) {
            this.value = this.hexToColor(this.value);
        }
        gxp.form.ColorField.superclass.initComponent.call(this);
        
        // Add the colorField listener to color the field.
        this.on({
            render: this.colorField,
            valid: this.colorField,
            scope: this
        });
        
    },
    
    /** private: method[isDark]
     *  :arg hex: ``String`` A RGB hex color string (prefixed by '#').
     *  :returns: ``Boolean`` The color is dark.
     *  
     *  Determine if a color is dark by avaluating brightness according to the
     *  W3C suggested algorithm for calculating brightness of screen colors.
     *  http://www.w3.org/WAI/ER/WD-AERT/#color-contrast
     */
    isDark: function(hex) {
        var dark = false;
        if(hex) {
            // convert hex color values to decimal
            var r = parseInt(hex.substring(1, 3), 16) / 255;
            var g = parseInt(hex.substring(3, 5), 16) / 255;
            var b = parseInt(hex.substring(5, 7), 16) / 255;
            // use w3C brightness measure
            var brightness = (r * 0.299) + (g * 0.587) + (b * 0.144);
            dark = brightness < 0.5;
        }
        return dark;
    },
    
    /** private: method[colorField]
     *  Set the background and font color for the field.
     */
    colorField: function() {
        var color = this.colorToHex(this.getValue()) || this.defaultBackground;
        this.getEl().setStyle({
            "background": color,
            "color": this.isDark(color) ? "#ffffff" : "#000000"
        });
    },
    
    /** api: method[getHexValue]
     *  :returns: ``String`` The RGB hex string for the field's value (prefixed
     *      with '#').
     *  
     *  As a compliment to the field's ``getValue`` method, this method always
     *  returns the RGB hex string representation of the current value
     *  in the field (given a named color or a hex string).
     */
    getHexValue: function() {
        return this.colorToHex(
            gxp.form.ColorField.superclass.getValue.apply(this, arguments));
    },

    /** api: method[getValue]
     *  :returns: ``String`` The RGB hex string for the field's value (prefixed
     *      with '#').
     *  
     *  This method always returns the RGB hex string representation of the
     *  current value in the field (given a named color or a hex string),
     *  except for the case when the value has not been changed.
     */
    getValue: function() {
        var v = this.getHexValue();
        var o = this.initialConfig.value;
        if (v === this.hexToColor(o)) {
            v = o;
        }
        return v;
    },
    
    /** api: method[setValue]
     *  :arg value: ``Object``
     *  
     *  Sets the value of the field. If the value matches one of the well known
     *  colors in ``cssColors``, a human readable value will be displayed
     *  instead of the hex code.
     */
    setValue: function(value) {
        gxp.form.ColorField.superclass.setValue.apply(this,
            [this.hexToColor(value)]);
    },
    
    /** private: method[colorToHex]
     *  :returns: ``String`` A RGB hex color string or null if none found.
     *  
     *  Return the RGB hex representation of a color string.  If a CSS supported
     *  named color is supplied, the hex representation will be returned.
     *  If a non-CSS supported named color is supplied, null will be
     *  returned.  If a RGB hex string is supplied, the same will be returned.
     */
    colorToHex: function(color) {
        if (!color) {
            return color;
        }
        var hex;
        if (color.match(/^#[0-9a-f]{6}$/i)) {
            hex = color;
        } else {
            hex = this.cssColors[color.toLowerCase()] || null;
        }
        return hex;
    },
    
    /** private: method[hexToColor]
     */
    hexToColor: function(hex) {
        if (!hex) {
            return hex;
        }
        var color = hex;
        for (var c in this.cssColors) {
            if (this.cssColors[c] == color.toUpperCase()) {
                color = c;
                break;
            }
        }
        return color;
    }
    
});

Ext.reg("gxp_colorfield", gxp.form.ColorField);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @include widgets/form/ComparisonComboBox.js
 * @requires GeoExt/data/AttributeStore.js
 */

/** api: (define)
 *  module = gxp.form
 *  class = FilterField
 *  base_link = `Ext.form.CompositeField <http://extjs.com/deploy/dev/docs/?class=Ext.form.CompositeField>`_
 */
Ext.namespace("gxp.form");

/** api: constructor
 *  .. class:: FilterField(config)
 *   
 *      A form field representing a comparison filter.
 */
gxp.form.FilterField = Ext.extend(Ext.form.CompositeField, {
    
    /** api:config[lowerBoundaryTip]
     *  ``String`` tooltip for the lower boundary textfield (i18n)
     */
    lowerBoundaryTip: "lower boundary",
     
    /** api:config[upperBoundaryTip]
     *  ``String`` tooltip for the lower boundary textfield (i18n)
     */
    upperBoundaryTip: "upper boundary",
     
    /** api: config[caseInsensitiveMatch]
     *  ``Boolean``
     *  Should Comparison Filters for Strings do case insensitive matching?  Default is ``"false"``.
     */
    caseInsensitiveMatch: false,

    /**
     * Property: filter
     * {OpenLayers.Filter} Optional non-logical filter provided in the initial
     *     configuration.  To retreive the filter, use <getFilter> instead
     *     of accessing this property directly.
     */
    filter: null,
    
    /**
     * Property: attributes
     * {GeoExt.data.AttributeStore} A configured attributes store for use in
     *     the filter property combo.
     */
    attributes: null,

    /** api:config[comparisonComboConfig]
     *  ``Object`` Config object for comparison combobox.
     */

    /** api:config[attributesComboConfig]
     *  ``Object`` Config object for attributes combobox.
     */
    
    /**
     * Property: attributesComboConfig
     * {Object}
     */
    attributesComboConfig: null,

    initComponent: function() {
                
        if(!this.filter) {
            this.filter = this.createDefaultFilter();
        }
        // Maintain compatibility with QueryPanel, which relies on "remote"
        // mode and the filterBy filter applied in it's attributeStore's load
        // listener *after* the initial combo filtering.
        //TODO Assume that the AttributeStore is already loaded and always
        // create a new one without geometry fields.
        var mode = "remote", attributes = new GeoExt.data.AttributeStore();
        if (this.attributes) {
            if (this.attributes.getCount() != 0) {
                mode = "local";
                this.attributes.each(function(r) {
                    var match = /gml:((Multi)?(Point|Line|Polygon|Curve|Surface|Geometry)).*/.exec(r.get("type"));
                    match || attributes.add([r]);
                });
            } else {
                attributes = this.attributes;
            }
        }

        var defAttributesComboConfig = {
            xtype: "combo",
            store: attributes,
            editable: mode == "local",
            typeAhead: true,
            forceSelection: true,
            mode: mode,
            triggerAction: "all",
            ref: "property",
            allowBlank: this.allowBlank,
            displayField: "name",
            valueField: "name",
            value: this.filter.property,
            listeners: {
                select: function(combo, record) {
                    this.items.get(1).enable();
                    this.filter.property = record.get("name");
                    this.fireEvent("change", this.filter, this);
                },
                // workaround for select event not being fired when tab is hit
                // after field was autocompleted with forceSelection
                "blur": function(combo) {
                    var index = combo.store.findExact("name", combo.getValue());
                    if (index != -1) {
                        combo.fireEvent("select", combo, combo.store.getAt(index));
                    } else if (combo.startValue != null) {
                        combo.setValue(combo.startValue);
                    }
                },
                scope: this
            },
            width: 120
        };
        this.attributesComboConfig = this.attributesComboConfig || {};
        Ext.applyIf(this.attributesComboConfig, defAttributesComboConfig);

        this.items = this.createFilterItems();
        
        this.addEvents(
            /**
             * Event: change
             * Fires when the filter changes.
             *
             * Listener arguments:
             * filter - {OpenLayers.Filter} This filter.
             * this - {gxp.form.FilterField} (TODO change sequence of event parameters)
             */
            "change"
        ); 

        gxp.form.FilterField.superclass.initComponent.call(this);
    },

    /**
     * Method: validateValue
     * Performs validation checks on the filter field.
     *
     * Returns:
     * {Boolean} True if value is valid. 
     */
    validateValue: function(value, preventMark) {
        if (this.filter.type === OpenLayers.Filter.Comparison.BETWEEN) {
            return (this.filter.property !== null && this.filter.upperBoundary !== null &&
                this.filter.lowerBoundary !== null);
        } else {
            return (this.filter.property !== null &&
                this.filter.value !== null && this.filter.type !== null);
        }
    },
    
    /**
     * Method: createDefaultFilter
     * May be overridden to change the default filter.
     *
     * Returns:
     * {OpenLayers.Filter} By default, returns a comparison filter.
     */
    createDefaultFilter: function() {
        return new OpenLayers.Filter.Comparison({matchCase: !this.caseInsensitiveMatch});
    },
    
    /**
     * Method: createFilterItems
     * Creates a panel config containing filter parts.
     */
    createFilterItems: function() {
        var isBetween = this.filter.type === OpenLayers.Filter.Comparison.BETWEEN;
        return [
            this.attributesComboConfig, Ext.applyIf({
                xtype: "gxp_comparisoncombo",
                ref: "type",
                disabled: this.filter.property == null,
                allowBlank: this.allowBlank,
                value: this.filter.type,
                listeners: {
                    select: function(combo, record) {
                        this.items.get(2).enable();
                        this.items.get(3).enable();
                        this.items.get(4).enable();
                        this.setFilterType(record.get("value"));
                        this.fireEvent("change", this.filter, this);
                    },
                    scope: this
                }
            }, this.comparisonComboConfig), {
                xtype: "textfield",
                disabled: this.filter.type == null,
                hidden: isBetween,
                ref: "value",
                value: this.filter.value,
                width: 50,
                grow: true,
                growMin: 50,
                anchor: "100%",
                allowBlank: this.allowBlank,
                listeners: {
                    "change": function(field, value) {
                        this.filter.value = value;
                        this.fireEvent("change", this.filter, this);
                    },
                    scope: this
                }
            }, {
                xtype: "textfield",
                disabled: this.filter.type == null,
                hidden: !isBetween,
                value: this.filter.lowerBoundary,
                tooltip: this.lowerBoundaryTip,
                grow: true,
                growMin: 30,
                ref: "lowerBoundary",
                anchor: "100%",
                allowBlank: this.allowBlank,
                listeners: {
                    "change": function(field, value) {
                        this.filter.lowerBoundary = value;
                        this.fireEvent("change", this.filter, this);
                    },
                    "render": function(c) {
                        Ext.QuickTips.register({
                            target: c.getEl(),
                            text: this.lowerBoundaryTip
                        });
                    },
                    "autosize": function(field, width) {
                        field.setWidth(width);
                        field.ownerCt.doLayout();
                    },
                    scope: this
                }
            }, {
                xtype: "textfield",
                disabled: this.filter.type == null,
                hidden: !isBetween,
                grow: true,
                growMin: 30,
                ref: "upperBoundary",
                value: this.filter.upperBoundary,
                allowBlank: this.allowBlank,
                listeners: {
                    "change": function(field, value) {
                        this.filter.upperBoundary = value;
                        this.fireEvent("change", this.filter, this);
                    },
                    "render": function(c) {
                        Ext.QuickTips.register({
                            target: c.getEl(),
                            text: this.upperBoundaryTip
                        });
                    },
                    scope: this
                }
            }
        ];
    },
    
    setFilterType: function(type) {
        this.filter.type = type;
        if (type === OpenLayers.Filter.Comparison.BETWEEN) {
            this.items.get(2).hide();
            this.items.get(3).show();
            this.items.get(4).show();
        } else {
            this.items.get(2).show();
            this.items.get(3).hide();
            this.items.get(4).hide();
        }
        this.doLayout();
    },

    /** api: method[setFilter]
     *  :arg filter: ``OpenLayers.Filter``` Change the filter object to be
     *  used.
     */
    setFilter: function(filter) {
        var previousType = this.filter.type;
        this.filter = filter;
        if (previousType !== filter.type) {
            this.setFilterType(filter.type);
        }
        this['property'].setValue(filter.property);
        this['type'].setValue(filter.type);
        if (filter.type === OpenLayers.Filter.Comparison.BETWEEN) {
            this['lowerBoundary'].setValue(filter.lowerBoundary);
            this['upperBoundary'].setValue(filter.upperBoundary);
        } else {
            this['value'].setValue(filter.value);
        }
        this.fireEvent("change", this.filter, this);
    }

});

Ext.reg('gxp_filterfield', gxp.form.FilterField);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp.form
 *  class = FontComboBox
 *  base_link = `Ext.form.ComboBox <http://extjs.com/deploy/dev/docs/?class=Ext.form.ComboBox>`_
 */
Ext.namespace("gxp.form");

/** api: constructor
 *  .. class:: FontComboBox(config)
 *   
 *      A combo box for selecting a font.
 */
gxp.form.FontComboBox = Ext.extend(Ext.form.ComboBox, {
    
    /** api: property[fonts]
     *  ``Array``
     *  List of font families to choose from.  Default is ["Arial",
     *  "Courier New", "Tahoma", "Times New Roman", "Verdana"].
     */
    fonts: [
        "Serif",
        "SansSerif",
        "Arial",
        "Courier New",
        "Tahoma",
        "Times New Roman",
        "Verdana"
    ],
    
    /** api: property[defaultFont]
     *  ``String``
     *  The ``fonts`` item to select by default.
     */
    defaultFont: "Serif",

    allowBlank: false,

    mode: "local",

    triggerAction: "all",

    editable: false,
  
    initComponent: function() {
        var fonts = this.fonts || gxp.form.FontComboBox.prototype.fonts;
        var defaultFont = this.defaultFont;
        if (fonts.indexOf(this.defaultFont) === -1) {
            defaultFont = fonts[0];
        }
        var defConfig = {
            displayField: "field1",
            valueField: "field1",
            store: fonts,
            value: defaultFont,
            tpl: new Ext.XTemplate(
                '<tpl for=".">' +
                    '<div class="x-combo-list-item">' +
                    '<span style="font-family: {field1};">{field1}</span>' +
                '</div></tpl>'
            )
        };
        Ext.applyIf(this, defConfig);
        
        gxp.form.FontComboBox.superclass.initComponent.call(this);
    }
});

/** api: xtype = gxp_fontcombo */
Ext.reg("gxp_fontcombo", gxp.form.FontComboBox);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp.form
 *  class = GoogleGeocoderComboBox
 *  base_link = `Ext.form.ComboBox <http://extjs.com/deploy/dev/docs/?class=Ext.form.ComboBox>`_
 */
Ext.namespace("gxp.form");

/** api: constructor
 *  .. class:: GoogleGeocoderComboBox(config)
 *
 *  Creates a combo box that issues queries to the Google Maps geocoding service.
 *  If the user enters a valid address in the search box, the combo's store
 *  will be populated with records that match the address.  Records have the 
 *  following fields:
 *  
 *  * address - ``String`` The formatted address.
 *  * location - ``OpenLayers.LonLat`` Location matching address.
 *  * viewport - ``OpenLayers.Bounds`` Recommended viewing bounds.
 *
 */   
gxp.form.GoogleGeocoderComboBox = Ext.extend(Ext.form.ComboBox, {
    
    /** api: xtype = gxp_googlegeocodercombo */
    xtype: "gxp_googlegeocodercombo",

    /** api: config[queryDelay]
     *  ``Number`` Delay before the search occurs.  Default is 100ms.
     */
    queryDelay: 100,
    
    /** api: config[bounds]
     *  ``OpenLayers.Bounds | Array`` Optional bounds (in geographic coordinates)
     *  for restricting search.
     */
    
    /** api: config[valueField]
     *  ``String``
     *  Field from selected record to use when the combo's ``getValue`` method
     *  is called.  Default is "location".  Possible value's are "location",
     *  "viewport", or "address".  The location value will be an 
     * ``OpenLayers.LonLat`` object that corresponds to the geocoded address.
     *  The viewport value will be an ``OpenLayers.Bounds`` object that is 
     *  the recommended viewport for viewing the resulting location.  The
     *  address value will be a string that is the formatted address.
     */
    valueField: "viewport",

    /** private: config[displayField]
     */
    displayField: "address",

    /** private: method[initComponent]
     *  Override
     */
    initComponent: function() {
        
        // only enable when Google Maps API is available
        this.disabled = true;
        var ready = !!(window.google && google.maps);
        if (!ready) {
            if (!gxp.plugins || !gxp.plugins.GoogleSource) {
                throw new Error("The gxp.form.GoogleGeocoderComboBox requires the gxp.plugins.GoogleSource or the Google Maps V3 API to be loaded.");
            }
            gxp.plugins.GoogleSource.loader.onLoad({
                otherParams: gxp.plugins.GoogleSource.prototype.otherParams,
                callback: this.prepGeocoder,
                errback: function() {
                    throw new Error("The Google Maps script failed to load within the given timeout.");
                },
                scope: this
            });
        } else {
            // call in the next turn to complete initialization
            window.setTimeout((function() {
                this.prepGeocoder();
            }).createDelegate(this), 0);
        }

        this.store = new Ext.data.JsonStore({
            root: "results",
            fields: [
                {name: "address", type: "string"},
                {name: "location"}, // OpenLayers.LonLat
                {name: "viewport"} // OpenLayers.Bounds
            ],
            autoLoad: false
        });
        
        this.on({
            focus: function() {
                this.clearValue();
            },
            scope: this
        });
        
        return gxp.form.GoogleGeocoderComboBox.superclass.initComponent.apply(this, arguments);

    },
    
    /** private: method[prepGeocoder]
     */
    prepGeocoder: function() {
        var geocoder = new google.maps.Geocoder();
        

        // create an async proxy for getting geocoder results
        var api = {};
        api[Ext.data.Api.actions.read] = true;
        var proxy = new Ext.data.DataProxy({api: api});
        var combo = this;
        
        // TODO: unhack this - this is due to the the tool output being generated too early
        var getBounds = (function() {
            // optional bounds for restricting search
            var bounds = this.bounds;
            if (bounds) {
                if (bounds instanceof OpenLayers.Bounds) {
                    bounds = bounds.toArray();
                }
                bounds = new google.maps.LatLngBounds(
                    new google.maps.LatLng(bounds[1], bounds[0]),
                    new google.maps.LatLng(bounds[3], bounds[2])
                );
            }
            return bounds;
        }).createDelegate(this);
        
        proxy.doRequest = function(action, rs, params, reader, callback, scope, options) {
            // Assumes all actions read.
            geocoder.geocode(
                {address: params.query, bounds: getBounds()},
                function(results, status) {
                    var readerResult;
                    if (status === google.maps.GeocoderStatus.OK || 
                        status === google.maps.GeocoderStatus.ZERO_RESULTS) {
                        try {
                            results = combo.transformResults(results);
                            readerResult = reader.readRecords({results: results});
                        } catch (err) {
                            combo.fireEvent("exception", combo, "response", action, options, status, err);
                        }
                    } else {
                        combo.fireEvent("exception", combo, "remote", action, options, status, null);
                    }
                    if (readerResult) {
                        callback.call(scope, readerResult, options, true);                        
                    } else {
                        callback.call(scope, null, options, false);                        
                    }
                }
            );
        };
        
        this.store.proxy = proxy;
        if (this.initialConfig.disabled != true) {
            this.enable();
        }
    },
        
    /** private: method[transformResults]
     *  Transform an array of results so values are OpenLayers objects.
     */
    transformResults: function(gResults) {
        var num = gResults.length;
        var olResults = new Array(num);
        var item, latLng, bounds, ne, sw;
        for (i=0; i<num; ++i) {
            item = gResults[i];
            latLng = item.geometry.location;
            bounds = item.geometry.viewport;
            ne = bounds.getNorthEast();
            sw = bounds.getSouthWest();
            olResults[i] = {
                address: item.formatted_address,
                location: new OpenLayers.LonLat(latLng.lng(), latLng.lat()),
                viewport: new OpenLayers.Bounds(sw.lng(), sw.lat(), ne.lng(), ne.lat())
            };
        }
        return olResults;
    }

});

Ext.reg(gxp.form.GoogleGeocoderComboBox.prototype.xtype, gxp.form.GoogleGeocoderComboBox);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp.form
 *  class = ViewerField
 *  base_link = `Ext.form.Field <http://extjs.com/deploy/dev/docs/?class=Ext.form.TextArea>`_
 */
Ext.namespace("gxp.form");

/** api: constructor
 *  .. class:: ViewerField(config)
 *   
 *    A form field that holds an entire :class:`gxp.Viewer`. This field is used
 *    to process geospatial information in forms. By itself, this field does
 *    nothing but showing a map viewer in a form element, aligned with field
 *    label and suited for an ``Ext.layouts.FormLayout``.
 *
 *    To actually have this field's textarea populated with information, a
 *    plugin accessing the additional ``field`` property that this component
 *    adds to its :class:`gxp.Viewer` instance is required.
 *    See :class:`gxp.plugins.FeatureToField` for a basic plugin that does
 *    this.
 */
gxp.form.ViewerField = Ext.extend(Ext.form.TextArea, {

    /** api: config[width]
     *  ``Number`` Width of the map viewer. Default is 350.
     */
    
    /** api: config[height]
     *  ``Number`` Height of the map viewer. Default is 220.
     */
    
    /** api: config[viewer]
     *  ``Object`` Configuration passed to the :class:`gxp.Viewer` constructor.
     *  The ``portalConfig`` will be extended to make sure that the portal is
     *  rendered into this field.
     */

    /** api: property[viewer]
     *  :class:`gxp.Viewer` The viewer wrapped by this field. This component
     *  adds an additional ``field`` (``Ext.form.TextArea``) property to the
     *  viewer, which is to be populated by a viewer plugin to actually give
     *  this field a value.
     */
    viewer: null,

    /** private: method[initComponent]
     *  Override
     */
    initComponent: function() {
        this.width = this.width || 350;
        this.height = this.height || 220;
        gxp.form.ViewerField.superclass.initComponent.call(this);
    },
    
    /** private: method[onRender]
     *  Override
     */
    onRender: function() {
        if(!this.el){
            this.defaultAutoCreate = {
                tag: "textarea",
                style: {
                    color: "transparent",
                    background: "none"
                }
            };
        }
        gxp.form.ViewerField.superclass.onRender.apply(this, arguments);
        
        this.viewerEl = Ext.get(document.createElement("div"));
        this.viewerEl.setStyle("position", "absolute");
        // keep focussed while working with the map viewer
        this.viewerEl.on({
            "mouseenter": function() {
                this.hasFocus || this.el.focus();
            },
            "mousemove": function() {
                this.hasFocus || this.el.focus();
            },
            "mouseleave": function() {
                this.hasFocus && this.el.blur();
            },
            scope: this
        });
        this.el.dom.parentNode.appendChild(this.viewerEl.dom);
        // align the viewer with the textarea and keep it anchored
        this.viewerEl.anchorTo(this.el, "tl-tl");
        
        var portalConfig = {
            border: false,
            renderTo: this.viewerEl,
            width: this.width,
            height: this.height,
            // transparent border so we can see the textarea's border, which
            // indicates focus
            style: "border: 1px solid transparent"
        };
        var config = Ext.applyIf(this.initialConfig.viewer || {}, {
            field: this,
            portalConfig: portalConfig
        });
        Ext.apply(config.portalConfig, portalConfig);
        this.viewer = new gxp.Viewer(config);
    }
    
});

Ext.reg("gxp_viewerfield", gxp.form.ViewerField);

/**
 * Copyright (c) 2008-2012 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp.form
 *  class = ExtendedDateField
 *  base_link = `Ext.form.DateField <http://extjs.com/deploy/dev/docs/?class=Ext.form.DateField>`_
 */
Ext.namespace("gxp.form");

Date.defaults.d = 1;
Date.defaults.m = 1;

gxp.form.ExtendedDateTimeField = Ext.extend(Ext.form.CompositeField, {
   
    initComponent: function() {
        //ensure that qtips are initialized
        Ext.QuickTips.init();
        this.items = [{
            xtype: 'gxp_datefield',
            allowBlank: (this.initialConfig.allowBlank !== false),
            todayText: this.initialConfig.todayText,
            selectToday: this.initialConfig.selectToday,
            ref: "date"
        }, {
            xtype: 'timefield',
            width: 80,
            ref: "time"
        }];
        gxp.form.ExtendedDateTimeField.superclass.initComponent.apply(this, arguments);
    },

    getValue : function() {
        var dateValue = this.date.getValue();
        var timeValue = this.time.getValue();
        if (dateValue !== null && timeValue === "") {
            timeValue = "12:00 AM";
        }
        if (timeValue !== "") {
            var dateTimeCurrent = this.time.parseDate(timeValue);
            var dateTimeOriginal = new Date(this.time.initDate);
            var diff = (dateTimeCurrent.getTime()/1000) - (dateTimeOriginal.getTime()/1000);
            // we should always return times as UTC
            return dateValue + diff - (new Date(dateValue*1000).getTimezoneOffset()*60);
        } else {
            return dateValue;
        }
    },

    setValue: function(v) {
        this.date.setValue(v);
        var value = new Date(parseFloat(v)*1000);
        value.setTime( value.getTime() + value.getTimezoneOffset()*60*1000 );
        if (value) {
            var hours = value.getHours();
            if (hours > 12) {
                hours -= 12;
            } else if (hours === 0) {
                hours = 12;
            }
            var minutes = value.getMinutes();
            if (minutes < 10) {
                minutes = '0' + minutes;
            }
            this.time.setValue(hours + ":" + minutes + " " + (value.getHours() > 12 ? "PM" : "AM"));
        }
    }

});

/** api: xtype = gxp_datetimefield */
Ext.reg('gxp_datetimefield', gxp.form.ExtendedDateTimeField);

/** api: constructor
 *  .. class:: ExtendedDateField(config)
 *   
 *      It has been noted that to support the entire date range of earth's
 *      history, we'll need an approach that does not totally rely on date
 *      objects. A reasonable approach is to use a big integer (or
 *      long) that represents the number of seconds before or after
 *      1970-01-01. This allows us to use date objects with little effort when
 *      a value is within the supported range and to use a date-like object
 *      (ignores things like leap-year, etc.) when the value is outside of
 *      that range.
 */
gxp.form.ExtendedDateField = Ext.extend(Ext.form.DateField, {

    //negative year formats will parse but give a positive year 
    altFormats : "-c|-Y|m -Y|n -Y|M -Y|m/d/-Y|n/j/-Y|m/j/-Y|n/d/-Y|c|Y|" + 
                    "m/d/Y|n/j/Y|n/j/y|m/j/y|n/d/y|m/j/Y|n/d/Y|m-d-y|m-d-Y|" +
                    "m/d|m-d|md|mdy|mdY|d|Y-m-d|n-j|n/j",
    
    bcYrRegEx : /^(-\d{3,4})|(-\d{3,4})$/,
    
    invalidText : "{0} is not a valid date. If you are attempting to enter a BCE date please enter a zero padded 4 digit year or just enter the year",
    
    beforeBlur: Ext.emptyFn,
    
    getValue : function() {
        var value = Ext.form.DateField.superclass.getValue.call(this);
        var date = this.parseDate(value);
        var bcYear = value.match(this.bcYrRegEx) && ((value.match(/-/g)||[]).length === 1 || value.charAt(0) === '-');
        if (bcYear) {
            if(date){
                date = new Date(-1*date.getFullYear(),date.getMonth(),date.getDate(),date.getHours(),date.getMinutes(),date.getSeconds());
            }
        }
        return (date) ? date.getTime()/1000 : null;
    },

    setValue: function(v) {
        var d = v;
        if (Ext.isNumber(parseFloat(v))) {
            d = new Date(parseFloat(v)*1000);
            d.setTime( d.getTime() + d.getTimezoneOffset()*60*1000 );
        }
        var str = this.formatDate(d);
        if (str) {
            var bcYear = str.match(this.bcYrRegEx);
            if (bcYear) {
                bcYear = bcYear[0] || bcYear[1];
                if (bcYear && bcYear.length < 5) {
                    var zeropad = '-';
                    for (var i=bcYear.length;i<=4; ++i) {
                        zeropad += '0';
                    }
                    str = str.replace(bcYear, zeropad + Math.abs(parseInt(bcYear, 10)));
                }
            }
        }
        return Ext.form.DateField.superclass.setValue.call(this, str);
    },

    getPickerDate: function() {
        return new Date();
    },

    onTriggerClick : function(){
        if(this.disabled){
            return;
        }
        if(!this.menu){
            this.menu = new Ext.menu.DateMenu({
                hideOnClick: false,
                focusOnSelect: false
            });
        }
        this.onFocus();
        Ext.apply(this.menu.picker,  {
            minDate : this.minValue,
            todayText: this.todayText ? this.todayText: Ext.DatePicker.prototype.todayText,
            selectToday: this.selectToday ? this.selectToday: Ext.DatePicker.prototype.selectToday,
            maxDate : this.maxValue,
            disabledDatesRE : this.disabledDatesRE,
            disabledDatesText : this.disabledDatesText,
            disabledDays : this.disabledDays,
            disabledDaysText : this.disabledDaysText,
            format : this.format,
            showToday : this.showToday,
            startDay: this.startDay,
            minText : String.format(this.minText, this.formatDate(this.minValue)),
            maxText : String.format(this.maxText, this.formatDate(this.maxValue))
        });
        // changed code
        var d;
        var v = this.getValue();
        if (v === null) {
            d = this.getPickerDate();
        } else {
            d = new Date(v*1000);
        }
        this.menu.picker.setValue(d);
        // end of change
        this.menu.show(this.el, "tl-bl?");
        this.menuEvents('on');
    }

});

Ext.reg('gxp_datefield', gxp.form.ExtendedDateField);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @include widgets/NewSourceWindow.js
 */

/** api: (define)
 *  module = gxp.grid
 *  class = CapabilitiesGrid
 *  base_link = `Ext.grid.GridPanel <http://extjs.com/deploy/dev/docs/?class=Ext.grid.GridPanel>`_
 */
Ext.namespace("gxp.grid");

/** api: constructor
 *  .. class:: CapabilitiesGrid(config)
 *  
 *      Create a new grid displaying the WMS cabilities of a URL, or the
 *      contents of a ``GeoExt.data.WMSCapabilitiesStore``\ .  The user can
 *      add layers to a passed-in ``GeoExt.MapPanel`` from the grid.
 */
gxp.grid.CapabilitiesGrid = Ext.extend(Ext.grid.GridPanel, {

    /** api: config[store]
     *  ``GeoExt.data.LayerStore``
     */
    store: null,

    /** api: config[metaStore]
     * ``Ext.data.Store``
     * A Store containing the alternative stores that are available for this 
     * GridPanel.  Stores added using the grid toolbar's 'add sources' button
     * will be added to this store.
     *
     * The store must provide at least the following fields:
     * 
     * .. list-table::
     *     :widths: 20 80
     * 
     *     * - ``name``
     *       - the display name for the store
     *     * - ``store`` 
     *       - the ``WMSCapabilitiesStore`` instance
     *     * - ``identifier``
     *       - an id string that layers may use to associate themselves with a 
     *         source (useful for serialization)
     *     * - ``url``
     *       - the root URL to the source's OWS service
     */

    /** api: config[cm]
     * ``Ext.grid.ColumnModel`` or Array[Object]
     * The ColumnModel as normally specified in Ext Grids
     */
    cm: null,

    /**
     * api: property[expander]
     * A plugin, such as a :class:'RowExpander', which displays more
     * information about a capability record.
     */
    expander: null,

    /** config: config[mapPanel]
     *  ``GeoExt.MapPanel``
     *  Map panel to which layers can be added via this grid.
     */
    mapPanel : null,

    /** api: config[url]
     *  ``String``
     *  The  OWS URL to which the GetCapabilities request is sent.  Necessary if
     *  a store is not passed in as a configuration option.
     */
    url: null,

    /** api: config[url]
     * The id of the column to auto-expand.  Unlike the standard ExtJS 
     * ``GridPanel``, this class provides a default value of 'title'.
     */
    autoExpandColumn: "title",

    /** api: config[allowNewSources]
     * ``Boolean``
     * Use this property (set it to false) to force the widget to hide the option to add new sources
     * even when a proxy is set up. Defaults to true.
     */
    allowNewSources: true,

    /** api: i18n[keys]
     * - nameHeaderText 
     * - titleHeaderText 
     * - queryableHeaderText 
     * - layerSelectionLabel
     * - layerAdditionLabel
     * - expanderTemplateText
     */
    nameHeaderText : "Name",
    titleHeaderText : "Title",
    queryableHeaderText : "Queryable",
    layerSelectionLabel: "View available data from:",
    layerAdditionLabel: "or add a new server.",
    expanderTemplateText: "<p><b>Abstract:</b> {abstract}</p>",

    /** private: method[constructor]
     */
    constructor: function() {
        this.addEvents(
            /** api: event[sourceselected]
             *  Fired when a new source is selected.
             *
             *  Listener arguments:
             *
             *  * grid - :class:`gxp.grid.CapabilitiesGrid` This grid.
             *  * source - :class:`gxp.plugins.LayerSource` The selected source.
             */
            "sourceselected"
        );
        gxp.grid.CapabilitiesGrid.superclass.constructor.apply(this, arguments);
    },

    /** private: method[initComponent]
     *
     *  Initializes the CapabilitiesGrid. Creates and loads a WMS Capabilities 
     *  store from the url property if one is not passed as a configuration 
     *  option. 
     */
    initComponent: function(){

        if(!this.store){
            this.store = new GeoExt.data.WMSCapabilitiesStore({
                url: this.url + "?service=wms&request=GetCapabilities"
            });

            this.store.load();
        }

        this.on('afterrender', function() {  
            this.fireEvent('sourceselected', this, this.store);
        }, this);

        if (!("expander" in this)){
            this.expander = new Ext.grid.RowExpander({
                tpl : new Ext.Template(this.expanderTemplateText)
            });
        }

        if(!this.plugins && this.expander){
            this.plugins = this.expander;
        }

        if(!this.cm){
            var cm = [
                {id: "title", header: this.titleHeaderText, dataIndex: "title", sortable: true},
                {header: this.nameHeaderText, dataIndex: "name", width: 180, sortable: true},
                {header: this.queryableHeaderText, dataIndex: "queryable", width: 70,
                    renderer: function(value, metaData, record, rowIndex, colIndex, store) {
                        metaData.css = 'x-btn';
                        var css = 'x-btn cancel';
                        if (value) {
                            css = 'x-btn add';
                        }
                        return '<div style="background-repeat: no-repeat; ' +
                            'background-position: 50% 0%; ' +
                            'height: 16px;" ' +
                            'class="' + css + '">&nbsp;</div>';
                    }
                }
            ];
            if (this.expander) {
                cm.unshift(this.expander);
            }
            this.cm = new Ext.grid.ColumnModel(cm);
        }

        if (!('allowNewSources' in this)) {
            this.allowNewSources = !!this.metaStore;
        }

        if (this.allowNewSources || (this.metaStore && this.metaStore.getCount() > 1)) {
            this.sourceComboBox = new Ext.form.ComboBox({
                store: this.metaStore,
                valueField: "identifier",
                displayField: "name",
                triggerAction: "all",
                editable: false,
                allowBlank: false,
                forceSelection: true,
                mode: "local",
                value: this.metaStore.getAt(this.metaStore.findBy(function(record) {
                    return record.get("store") == this.store;
                }, this)).get("identifier"),
                listeners: {
                    select: function(combo, record, index) {
                        this.fireEvent("sourceselected", this, record.data.store);
                        this.reconfigure(record.data.store, this.getColumnModel());
                        if (this.expander) this.expander.ows = record.get("url");
                    },
                    scope: this
                }
            });

            this.metaStore.on("add", function(store, records, index) {
                this.sourceComboBox.onSelect(records[0], index);
            }, this);

            this.tbar = this.tbar || [];
            this.tbar.push("" + this.layerSelectionLabel);
            this.tbar.push(this.sourceComboBox);
        }

        if (this.allowNewSources) {
            var grid = this;
            if (!this.newSourceWindow) {
                this.newSourceWindow = new gxp.NewSourceWindow({
                    modal: true,
                    metaStore: this.metaStore,
                    addSource: function() { 
                        grid.addSource.apply(grid, arguments); 
                    }
                });
            }

            this.tbar.push(new Ext.Button({
                iconCls: "gxp-icon-addserver",
                text: this.layerAdditionLabel,
                handler: function() {
                    this.newSourceWindow.show();
                },
                scope: this
            }));
        }

        gxp.grid.CapabilitiesGrid.superclass.initComponent.call(this);       
    },

    /** api: config[addSource]
     * A callback method that will be called when a url is entered into this 
     * grid's NewLayerWindow. It should expect the following parameters:
     *
     * .. list-table::
     *     :widths: 20 80
     *
     *     * - ``url`` 
     *       - the URL that the user entered
     *     * - ``success`` 
     *       - a callback to call after the successful addition of a source
     *     * - ``failure``
     *       - a callback to call after a failure to add a source
     *     * - ``scope`` 
     *       - the scope in which to run the callbacks
     *
     * If this is not provided, a default implementation will be used.  It is 
     * recommended that client code use handlers for the 'add' event on the 
     * metaStore rather than overriding this method.
     */
    addSource: function(url, success, failure, scope) {
        scope = scope || this;
        var layerStore = new GeoExt.data.WMSCapabilitiesStore({url:url, autoLoad: true});
        this.metaStore.add(new this.metaStore.recordType({
            url: url,
            store: layerStore,
            identifier: url,
            name: url
        }));
        success.apply(scope);
    },

    /** api: method[addLayers]
     * :param: base: a boolean indicating whether or not to make the new layer
     *     a base layer.
     *
     * Adds a layer to the :class:`GeoExt.MapPanel` of this instance.
     */
    addLayers : function(base){
        var sm = this.getSelectionModel();

        //for now just use the first selected record
        //TODO: force single selection (until we allow
        //adding group layers)
        var records = sm.getSelections();

        var record, layer, newRecords = [];
        for(var i = 0; i < records.length; i++){
            Ext.data.Record.AUTO_ID++;
            record = records[i].copy(Ext.data.Record.AUTO_ID);

            /*
             * TODO: deal with srs and maxExtent
             * At this point, we need to think about SRS if we want the layer to
             * have a maxExtent.  For our app, we are dealing with EPSG:4326
             * only.  This will have to be made more generic for apps that use
             * other srs.
             */
            if (this.alignToGrid) {
                layer = record.getLayer().clone();
                layer.maxExtent = new OpenLayers.Bounds(-180, -90, 180, 90);
            } else {
                layer = record.getLayer();
                /**
                 * TODO: The WMSCapabilitiesReader should allow for creation
                 * of layers in different SRS.
                 */
                if (layer instanceof OpenLayers.Layer.WMS) {
                    layer = new OpenLayers.Layer.WMS(
                        layer.name, layer.url,
                        {layers: layer.params["LAYERS"]},
                        {
                            attribution: layer.attribution,
                            maxExtent: OpenLayers.Bounds.fromArray(
                                record.get("llbbox")
                            ).transform(
                                new OpenLayers.Projection("EPSG:4326"),
                                this.mapPanel.map.getProjectionObject()
                            )
                        }
                    );
                }
            }

            record.data["layer"] = layer;
            record.commit(true);
            
            newRecords.push(record);
        }

        /**
         * The new layer records are ready to be added to the store.  The
         * store may contain temporary layers used for drawing at this
         * point (MeasureControl or other).  There are a number of ways
         * to decide where the new records should be inserted.  For the
         * sake of simplicity, lets assume they goes under the first vector
         * layer found.
         */
        if(newRecords.length) {
            var index = this.mapPanel.layers.findBy(function(r) {
                return r.getLayer() instanceof OpenLayers.Layer.Vector;
            });
            if(index !== -1) {
                this.mapPanel.layers.insert(index, newRecords);
            } else {
                this.mapPanel.layers.add(newRecords);
            }
        }
    }
});

/** api: xtype = gxp_capabilitiesgrid */
Ext.reg('gxp_capabilitiesgrid', gxp.grid.CapabilitiesGrid); 

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires GeoExt/widgets/grid/FeatureSelectionModel.js
 * @requires GeoExt/data/FeatureStore.js
 */

/** api: (define)
 *  module = gxp.grid
 *  class = FeatureGrid
 *  base_link = `Ext.grid.GridPanel <http://extjs.com/deploy/dev/docs/?class=Ext.grid.GridPanel>`_
 */
Ext.namespace("gxp.grid");

/** api: constructor
 *  .. class:: FeatureGrid(config)
 *
 *      Create a new grid displaying the contents of a 
 *      ``GeoExt.data.FeatureStore`` .
 */
gxp.grid.FeatureGrid = Ext.extend(Ext.grid.GridPanel, {

    /** api: config[map]
     *  ``OpenLayers.Map`` If provided, a layer with the features from this
     *  grid will be added to the map.
     */
    map: null,

    /** api: config[ignoreFields]
     *  ``Array`` of field names from the store's records that should not be
     *  displayed in the grid.
     */
    ignoreFields: null,

    /** api: config[includeFields]
     * ``Array`` of field names from the store's records that should be 
     * displayed in the grid. All other fields will be ignored.
     */
    includeFields: null,

    /** api: config[fieldVisibility]
     * ``Object`` Property name/visibility name pairs. Optional. If specified,
     * only columns with a value of true will be initially shown.
     */
    
    /** api: config[propertyNames]
     *  ``Object`` Property name/display name pairs. If specified, the display
     *  name will be shown as column header instead of the property name.
     */
    
    /** api: config[customRenderers]
     *  ``Object`` Property name/renderer pairs. If specified for a field name,
     *  the custom renderer will be used instead of the type specific one.
     */

    /** api: config[customEditors]
     *  ``Object`` Property name/editor pairs. If specified for a field name,
     *  the custom editor will be used instead of the standard textfield.
     */

    /** api: config[columnConfig]
     *  ``Object`` Property name/config pairs. Any additional config that
     *  should be used on the column, such as making a column non-editable
     *  by specifying editable: false
     */

    /** api: config[layer]
     *  ``OpenLayers.Layer.Vector``
     *  The vector layer that will be synchronized with the layer store.
     *  If the ``map`` config property is provided, this value will be ignored.
     */
    
    /** api: config[schema]
     *  ``GeoExt.data.AttributeStore``
     *  Optional schema for the grid. If provided, appropriate field
     *  renderers (e.g. for date or boolean fields) will be used.
     */

    /** api: config[dateFormat]
     *  ``String`` Date format. Default is the value of
     *  ``Ext.form.DateField.prototype.format``.
     */

    /** api: config[timeFormat]
     *  ``String`` Time format. Default is the value of
     *  ``Ext.form.TimeField.prototype.format``.
     */

    /** private: property[layer]
     *  ``OpenLayers.Layer.Vector`` layer displaying features from this grid's
     *  store
     */
    layer: null,
    
    /** api: config[columnsSortable]
     *  ``Boolean`` Should fields in the grid be sortable? Default is true.
     */
    columnsSortable: true,
    
    /** api: config[columnmenuDisabled]
     *  ``Boolean`` Should the column menu be disabled? Default is false.
     */
    columnMenuDisabled: false,
    
    /** api: method[initComponent]
     *  Initializes the FeatureGrid.
     */
    initComponent: function(){
        this.ignoreFields = ["feature", "state", "fid"].concat(this.ignoreFields);
        if(this.store) {
            this.cm = this.createColumnModel(this.store);
            // layer automatically added if map provided, otherwise check for
            // layer in config
            if(this.map) {
                this.layer = new OpenLayers.Layer.Vector(this.id + "_layer");
                this.map.addLayer(this.layer);
            }
        } else {
            this.store = new Ext.data.Store();
            this.cm = new Ext.grid.ColumnModel({
                columns: []
            });
        }
        if(this.layer) {
            this.sm = this.sm || new GeoExt.grid.FeatureSelectionModel({
                layerFromStore: false,
                layer: this.layer
            });
            if(this.store instanceof GeoExt.data.FeatureStore) {
                this.store.bind(this.layer);
            }
        }
        if (!this.dateFormat) {
            this.dateFormat = Ext.form.DateField.prototype.format;
        }
        if (!this.timeFormat) {
            this.timeFormat = Ext.form.TimeField.prototype.format;
        }

        gxp.grid.FeatureGrid.superclass.initComponent.call(this);       
    },
    
    /** private: method[onDestroy]
     *  Clean up anything created here before calling super onDestroy.
     */
    onDestroy: function() {
        if(this.initialConfig && this.initialConfig.map &&
           !this.initialConfig.layer) {
            // we created the layer, let's destroy it
            this.layer.destroy();
            delete this.layer;
        }
        gxp.grid.FeatureGrid.superclass.onDestroy.apply(this, arguments);
    },
    
    /** api: method[setStore]
     *  :arg store: ``GeoExt.data.FeatureStore``
     *  :arg schema: ``GeoExt.data.AttributeStore`` Optional schema to
     *      determine appropriate field renderers for the grid.
     *  
     *  Sets the store for this grid, reconfiguring the column model
     */
    setStore: function(store, schema) {
        if (schema) {
            this.schema = schema;
        }
        if (store) {
            if(this.store instanceof GeoExt.data.FeatureStore) {
                this.store.unbind();
            }
            if(this.layer) {
                this.layer.destroyFeatures();
                store.bind(this.layer);
            }
            this.reconfigure(store, this.createColumnModel(store));
        } else {
            this.reconfigure(
                new Ext.data.Store(),
                new Ext.grid.ColumnModel({columns: []}));
        }
    },

    /** api: method[getColumns]
     *  :arg store: ``GeoExt.data.FeatureStore``
     *  :return: ``Array``
     *  
     *  Gets the configuration for the column model.
     */
    getColumns: function(store) {
        function getRenderer(format) {
            return function(value) {
                //TODO When http://trac.osgeo.org/openlayers/ticket/3131
                // is resolved, change the 5 lines below to
                // return value.format(format);
                var date = value;
                if (typeof value == "string") {
                     date = Date.parseDate(value.replace(/Z$/, ""), "c");
                }
                return date ? date.format(format) : value;
            };
        }
        var columns = [],
            customEditors = this.customEditors || {},
            customRenderers = this.customRenderers || {},
            name, type, xtype, format, renderer;
        (this.schema || store.fields).each(function(f) {
            if (this.schema) {
                name = f.get("name");
                type = f.get("type").split(":").pop();
                format = null;
                switch (type) {
                    case "date":
                        format = this.dateFormat;
                        break;
                    case "datetime":
                        format = format ? format : this.dateFormat + " " + this.timeFormat;
                        xtype = undefined;
                        renderer = getRenderer(format);
                        break;
                    case "boolean":
                        xtype = "booleancolumn";
                        break;
                    case "string":
                        xtype = "gridcolumn";
                        break;
                    default:
                        xtype = "numbercolumn";
                        break;
                }
            } else {
                name = f.name;
            }
            if (this.ignoreFields.indexOf(name) === -1 &&
               (this.includeFields === null || this.includeFields.indexOf(name) >= 0)) {
                var columnConfig = this.columnConfig ? this.columnConfig[name] : null;
                columns.push(Ext.apply({
                    dataIndex: name,
                    hidden: this.fieldVisibility ?
                        (!this.fieldVisibility[name]) : false,
                    header: this.propertyNames ?
                        (this.propertyNames[name] || name) : name,
                    sortable: this.columnsSortable,
                    menuDisabled: this.columnMenuDisabled,
                    xtype: xtype,
                    editor: customEditors[name] || {
                        xtype: 'textfield'
                    },
                    format: format,
                    renderer: customRenderers[name] ||
                        (xtype ? undefined : renderer)
                }, columnConfig));
            }
        }, this);
        return columns;
    },
    
    /** private: method[createColumnModel]
     *  :arg store: ``GeoExt.data.FeatureStore``
     *  :return: ``Ext.grid.ColumnModel``
     */
    createColumnModel: function(store) {
        var columns = this.getColumns(store);
        return new Ext.grid.ColumnModel(columns);
    }
});

/** api: xtype = gxp_featuregrid */
Ext.reg('gxp_featuregrid', gxp.grid.FeatureGrid); 

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp
 *  class = GoogleEarthPanel
 *  base_link = `Ext.Panel <http://extjs.com/deploy/dev/docs/?class=Ext.Panel>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: GoogleEarthPanel(config)
 *   
 *      Create a panel for showing a 3D visualization of
 *      a map with the Google Earth plugin.  
 *      See http://code.google.com/apis/earth/ for plugin api
 *      documentation.
 */
gxp.GoogleEarthPanel = Ext.extend(Ext.Panel, {

    /**
     * Google Earth's horizontal field of view, in radians. (30 degrees)
     * This was not pulled from any documentation; it was chosen simply 
     * by it's nice, even number, as well as its appearance to actually
     * work.
     */
    HORIZONTAL_FIELD_OF_VIEW: (30 * Math.PI) / 180,

    /** api: config[flyToSpeed]
     *  ``Number``
     *  Specifies the speed (0.0 to 5.0) at which the camera moves to the
     *  target extent. Set to null to use the Google Earth default. By default
     *  we show the target extent immediately, without flying to it.
     */

    /** private: property[map]
     *  ``OpenLayers.Map``
     *  The OpenLayers map associated with this panel.  Defaults
     *  to the map of the configured MapPanel
     */
    map: null,

    /** api: config[mapPanel]
     *  ``GeoExt.MapPanel | String``
     *  The map panel associated with this panel.  If a MapPanel instance is 
     *  not provided, a MapPanel id must be provided.
     */
    mapPanel: null,

    /** private: property[layers]
     *  :class:`GeoExt.data.LayerStore`  A store containing
     *  :class:`GeoExt.data.LayerRecord` objects.
     */
    layers: null,

    /** private: property[earth]
     * The Google Earth object.
     */
    earth: null,

    //currently always set to 4326?
    projection: null,

    
    layerCache: null,

    /** private: method[initComponent]
     *  Initializes the Google Earth panel. 
     */
    initComponent: function() {

        this.addEvents(
            /** api: event[beforeadd]
             *  Fires before a layer is added to the 3D view.  If a listener
             *  returns ``false``, the layer will not be added.  Listeners
             *  will be called with a single argument: the layer record.
             */
            "beforeadd",
            /** api: event[pluginfailure]
             *  Fires when there is a failure creating the instance.  Listeners
             *  will receive two arguments: this plugin and the failure code
             *  (see the Google Earth API docs for details on the failure codes).
             */
            "pluginfailure",
            /** api: event[pluginready]
             *  Fires when the instance is ready.  Listeners will receive one
             *  argument: the GEPlugin instance.
             */
            "pluginready"
        );

        gxp.GoogleEarthPanel.superclass.initComponent.call(this);

        var mapPanel = this.mapPanel;
        if (mapPanel && !(mapPanel instanceof GeoExt.MapPanel)) {
            mapPanel = Ext.getCmp(mapPanel);
        }
        if (!mapPanel) {
            throw new Error("Could not get map panel from config: " + this.mapPanel);
        }
        this.map = mapPanel.map;
        this.layers = mapPanel.layers;

        this.projection = new OpenLayers.Projection("EPSG:4326");

        this.on("render", this.onRenderEvent, this);
        this.on("show", this.onShowEvent, this);
        
        this.on("hide", function() {
            if (this.earth != null) {
                this.updateMap();
            }
            // Remove the plugin from the dom.
            this.body.dom.innerHTML = "";
            this.earth = null;
        }, this);
    },

    /** private: method[onEarthReady]
     *  Runs when Google Earth instance is ready.  Adds layer
     *  store handlers. 
     */
    onEarthReady: function(object){
        this.earth = object;
        
        if (this.flyToSpeed === undefined) {
            // We don't want to fly. Just go to the right spot immediately.
            this.earth.getOptions().setFlyToSpeed(this.earth.SPEED_TELEPORT);
        } else if (this.flyToSpeed !== null) {
            this.earth.getOptions().setFlyToSpeed(this.flyToSpeed);
        }
        
        // Set the extent of the earth to be that shown in OpenLayers.
        this.resetCamera();
        this.setExtent(this.map.getExtent());
        
        // Show the navigation control, and make it so it is on the left.
        // Not actually sure how the second to fourth lines make that happen,
        // but hey -- it works. :)
        this.earth.getNavigationControl().setVisibility(this.earth.VISIBILITY_SHOW);
        var screenXY = this.earth.getNavigationControl().getScreenXY();
        screenXY.setXUnits(this.earth.UNITS_PIXELS);
        screenXY.setYUnits(this.earth.UNITS_INSET_PIXELS);
        
        // Show the plugin.
        this.earth.getWindow().setVisibility(true);

        this.layers.each(function(record) {
            this.addLayer(record);
        }, this);

        this.layers.on("remove", this.updateLayers, this);

        this.layers.on("update", this.updateLayers, this);
        
        this.layers.on("add", this.updateLayers, this);

        this.fireEvent("pluginready", this.earth);

        // Set up events. Notice global google namespace.
        // google.earth.addEventListener(this.earth.getView(), 
            // "viewchangeend", 
            // this.updateMap.createDelegate(this));
    },

    /** private: method[onRenderEvent]
     *  Unfortunately, Ext does not call show() if the component is initally
     *  displayed, so we need to fake it.
     *  We can't call this method onRender because Ext has already stolen
     *  the name for internal use :-(
     */

    onRenderEvent: function() {
        var isCard = this.ownerCt && this.ownerCt.layout instanceof Ext.layout.CardLayout;
        if (!this.hidden && !isCard) {
            this.onShowEvent();
        }
    },

    /** private: method[onShowEvent]
     *  Unfortunately, the Google Earth plugin does not like to be hidden.
     *  No matter whether you hide it through CSS visibility, CSS offsets,
     *  or CSS display = none, the Google Earth plugin will show an error
     *  message when it is re-enabled. To counteract this, we delete
     *  the instance and create a new one each time.
     *  We can't call this method onShow because Ext has already stolen
     *  the name for internal use :-(
     */

    onShowEvent: function() {
        if (this.rendered) {
            this.layerCache = {};
            google.earth.createInstance(
                this.body.dom,
                this.onEarthReady.createDelegate(this),
                (function(code) {
                    this.fireEvent("pluginfailure", this, code);
                }).createDelegate(this)
            );
        }
    },

    /**
     */
    beforeDestroy: function() {
        this.layers.un("remove", this.updateLayers, this);
        this.layers.un("update", this.updateLayers, this);
        this.layers.un("add", this.updateLayers, this);
        gxp.GoogleEarthPanel.superclass.beforeDestroy.call(this);
    },

    /** private: method[updateLayers]
     *  Synchronizes the 3D visualization with the
     *  configured layer store.
     */

    updateLayers: function() {
        if (!this.earth) return;

        var features = this.earth.getFeatures();
        var f = features.getFirstChild();

        while (f != null) {
            features.removeChild(f);
            f = features.getFirstChild();
        }

        this.layers.each(function(record) {
            this.addLayer(record);
        }, this);
    },

    /** private: method[addLayer]
     *  Adds a layer to the 3D visualization.
     */
    
    addLayer: function(layer, order) {
        var lyr = layer.getLayer();
        var ows = (lyr && lyr.url);
        if (this.earth && lyr instanceof OpenLayers.Layer.WMS && typeof ows == "string") {
            var add = this.fireEvent("beforeadd", layer);
            if (add !== false) {
                var name = lyr.id;
                var networkLink;
                if (this.layerCache[name]) {
                    networkLink = this.layerCache[name];
                } else {
                    var link = this.earth.createLink('kl_' + name);
                    ows = ows.replace(/\?.*/, '');
                    var params = lyr.params;
                    var kmlPath = '/kml?mode=refresh&layers=' + params.LAYERS +
                        "&styles=" + params.STYLES;
                    link.setHref(ows + kmlPath);
                    networkLink = this.earth.createNetworkLink('nl_' + name);
                    networkLink.setName(name);
                    networkLink.set(link, false, false);
                    this.layerCache[name] = networkLink;
                }

                networkLink.setVisibility(lyr.getVisibility());

                if (order !== undefined && order < this.earth.getFeatures().getChildNodes().getLength()) {
                    this.earth.getFeatures().
                        insertBefore(this.earth.getFeatures().getChildNodes().item(order));
                } else { 
                    this.earth.getFeatures().appendChild(networkLink);
                }
            }
        }
    },

    /** private: method[setExtent]
     *  Sets the view of the 3D visualization to approximate an OpenLayers extent.
     */
    setExtent: function(extent) {
        extent = extent.transform(this.map.getProjectionObject(), this.projection);
        var center = extent.getCenterLonLat();
        
        var width = this.getExtentWidth(extent);
        
        // Calculate height of the camera from the ground, in meters.
        var height = width / (2 * Math.tan(this.HORIZONTAL_FIELD_OF_VIEW));
        
        var lookAt = this.earth.getView().copyAsLookAt(this.earth.ALTITUDE_RELATIVE_TO_GROUND);
        lookAt.setLatitude(center.lat);
        lookAt.setLongitude(center.lon);
        lookAt.setRange(height);
        this.earth.getView().setAbstractView(lookAt);
    },
    
    resetCamera: function() {
        var camera = this.earth.getView().copyAsCamera(this.earth.ALTITUDE_RELATIVE_TO_GROUND);
        camera.setRoll(0);
        camera.setHeading(0);
        camera.setTilt(0);
        this.earth.getView().setAbstractView(camera);
    },

    /** private: method[getExtent]
     *  Gets an OpenLayers.Bounds that approximates the visable area of
     *  3D visualization.
     */ 
    getExtent: function() {
        var geBounds = this.earth.getView().getViewportGlobeBounds();
        var olBounds = new OpenLayers.Bounds(
            geBounds.getWest(), geBounds.getSouth(), geBounds.getEast(), geBounds.getNorth()
        );
        return olBounds;
    },


    /** private: method[updateMap]
     */
    updateMap: function() {
        // Get the center of the map from GE. We let GE get the center (as opposed to getting
        // the extent and then finding the center) because it'll find the correct visual
        // center represented by the globe, taking into account spherical calculations.
        var lookAt = this.earth.getView().copyAsLookAt(this.earth.ALTITUDE_RELATIVE_TO_GROUND);
        
        var center = this.reprojectToMap(
            new OpenLayers.LonLat(lookAt.getLongitude(), lookAt.getLatitude())
        );
        
        // Zoom to the closest zoom level for the extent given by GE's getViewPortGlobeBounds().
        // Then recenter based on the visual center shown in GE.
        var geExtent = this.reprojectToMap(this.getExtent());
        this.map.zoomToExtent(geExtent, true);
        this.map.setCenter(center);
        
        // Slight dirty hack --
        
        // GE's getViewPortGlobeBounds() function gives us an extent larger than what OL
        // should show, sometimes with more data. This extent works most of the time when OL
        // tries to find the closest zoom level, but on some edge cases it zooms out 
        // one zoom level too far. To counteract this, we calculate the geodetic width that
        // we expect GE to show (note: this is the opposite of the setExtent() calculations),
        // and then compare that width to that of the current zoom level and one zoom level
        // closer. If the next zoom level shows a geodetic width that's nearer to the width
        // we expect, then we zoom to that zoom level.
        //
        // Big note: This expects a map that has fractional zoom disabled!
        var height = lookAt.getRange();
        
        var width = 2 * height * Math.tan(this.HORIZONTAL_FIELD_OF_VIEW);
        
        var nextResolution = this.map.getResolutionForZoom(this.map.getZoom() + 1);
        
        var currentExtent = this.map.getExtent();
        var nextExtent = new OpenLayers.Bounds(
            center.lon - (this.map.getSize().w / 2 * nextResolution),
            center.lat + (this.map.getSize().h / 2 * nextResolution),
            center.lon + (this.map.getSize().w / 2 * nextResolution),
            center.lat - (this.map.getSize().h / 2 * nextResolution)
        );
        
        var currentWidthDiff = Math.abs(this.getExtentWidth(currentExtent) - width);
        var nextWidthDiff = Math.abs(this.getExtentWidth(nextExtent) - width);

        if (nextWidthDiff < currentWidthDiff) {
            this.map.zoomTo(this.map.getZoom() + 1);
        }
    },


    /** private: method[getExentWidth]
     */
    getExtentWidth: function(extent) {
        var center = extent.getCenterLonLat();
        
        var middleLeft = new OpenLayers.LonLat(extent.left, center.lat);
        var middleRight = new OpenLayers.LonLat(extent.right, center.lat);
        
        return OpenLayers.Util.distVincenty(middleLeft, middleRight) * 1000;
    },
    

    /** private: method[reprojectToGE]
     */
    reprojectToGE: function(data) {
        return data.clone().transform(this.map.getProjectionObject(), this.projection);
    },
    

    /** private: method[reprojectToMap]
     */
    reprojectToMap: function(data) {
        return data.clone().transform(this.projection, this.map.getProjectionObject());
    }
});


/** api: xtype = gxp_googleearthpanel */
Ext.reg("gxp_googleearthpanel", gxp.GoogleEarthPanel);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp
 *  class = GoogleStreetViewPanel
 *  base_link = `Ext.Panel <http://dev.sencha.com/deploy/dev/docs/?class=Ext.Panel>`_
 */
Ext.namespace("gxp");

gxp.GoogleStreetViewPanel = Ext.extend(Ext.Panel, {

    /** private: property[panorama]
     *  ``google.maps.StreetViewPanorama``  The panorama object.
     */
    panorama: null,

    /** api: config[heading]
     *  ``Number``  The camera heading in degrees relative to true north. True north 
     *  is 0 degrees, east is 90 degrees, south is 180 degrees, west is 270 
     *  degrees.
     */
    /** private: property[heading]
     *  ``Number``  Camera heading.
     */
    heading: 0,

    /** api: config[pitch]
     *  ``Number``  The camera pitch in degrees, relative to the street view 
     *  vehicle. Ranges from 90 degrees (directly upwards) to -90 degrees 
     *  (directly downwards).
     */
    /** private: property[pitch]
     *  ``Number``  Camery pitch
     */
    pitch: 0,

    /** api: config[zoom]
     *  ``Number``  The zoom level. Fully zoomed-out is level 0, zooming in 
     *  increases the zoom level.
     */
    /** private: property[zoom]
     *  ``Number``  Panorama zoom level
     */
    zoom: 0,

    /** api: config[location]
     *  ``OpenLayers.LonLat``  The panorama location
     */
    /** private: property[location]
     *  ``OpenLayers.LonLat``  Panorama location
     */
    location: null,

    /** private: method[initComponent]
     *  Private initComponent override.
     */
    initComponent : function() {
        var defConfig = {
            plain: true,
            border: false
        };

        Ext.applyIf(this, defConfig);
        return gxp.GoogleStreetViewPanel.superclass.initComponent.call(this);
    },

    /** private: method[afterRender]
     *  Private afterRender override.
     */
    afterRender : function() {
        var owner = this.ownerCt;
        if (owner) {
            var size = owner.getSize();
            Ext.applyIf(this, size);
            if (!this.location) {
                // try to derive location from owner (e.g. popup)
                if (GeoExt.Popup) {
                    this.bubble(function(cmp) {
                        if (cmp instanceof GeoExt.Popup) {
                            this.location = cmp.location.clone().transform(
                                cmp.map.getProjectionObject(),
                                new OpenLayers.Projection("EPSG:4326")
                            );
                            return false;
                        }
                    }, this);
                }
            }
        }
        gxp.GoogleStreetViewPanel.superclass.afterRender.call(this);
        
        // Configure panorama and associate methods and parameters to it
        var options = {
            position: new google.maps.LatLng(this.location.lat, this.location.lon),
            pov: {
                heading: this.heading,
                pitch: this.pitch,
                zoom: this.zoom
            }
        };
        this.panorama = new google.maps.StreetViewPanorama(
            this.body.dom, options
        );

    },

    /** private: method[beforeDestroy]
     *  Destroy Street View Panorama instance and navigation tools
     *
     */
    beforeDestroy: function() {
        delete this.panorama;
        gxp.GoogleStreetViewPanel.superclass.beforeDestroy.apply(this, arguments);
    },

    /** private: method[onResize]
     *  Resize Street View Panorama
     *  :param w: ``Number`` Width
     *  :param h: ``Number`` Height
     */
    onResize : function(w, h) {
        gxp.GoogleStreetViewPanel.superclass.onResize.apply(this, arguments);
        if (this.panorama) {
            if (typeof this.panorama == "object") {
                google.maps.event.trigger(this.panorama, "resize");
            }
        }
    },

    /** private: method[setSize]
     *  Set size of Street View Panorama
     */
    setSize : function(width, height, animate) {
        gxp.GoogleStreetViewPanel.superclass.setSize.apply(this, arguments);
        if (this.panorama) {
            if (typeof this.panorama == "object") {
                google.maps.event.trigger(this.panorama, "resize");
            }
        }
    }
});

/** api: xtype = gxp_googlestreetviewpanel */
Ext.reg("gxp_googlestreetviewpanel", gxp.GoogleStreetViewPanel);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp
 *  class = Histogram
 *  base_link = `Ext.BoxComponent <http://extjs.com/deploy/dev/docs/?class=Ext.BoxComponent>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: Histogram(config)
 *   
 *      A component for displaying a simple histogram. Quantities will always
 *      be stretched so the highest quantity takes up 100% of the available
 *      height.
 *
 *      .. code-block:: javascript
 *
 *          new gxp.Histogram({
 *              quantities: [1,2,3,4,5,4,3,2,1],
 *              renderTo: document.body
 *          });
 */
gxp.Histogram = Ext.extend(Ext.BoxComponent, {
    
    /** api: config[quantities]
     *  ``Array(Number)`` Array of quantities for the histogram.
     */
        
    /** private: method[onRender]
     */
    onRender: function(ct, position) {
        if (!this.el) {
            var el = document.createElement("div");
            el.id = this.getId();
            this.el = Ext.get(el);
        }
        this.el.addClass("gxp-histogram");
        if (this.quantities) {
            this.setQuantities(this.quantities);
        }
        gxp.Histogram.superclass.onRender.apply(this, arguments);
    },
    
    /** api: method[setQuantities]
     *  :arg quantities: ``Array(Number)`` Array of quantities for the
     *      histogram.
     *
     *  Updates the quantities that were originally configured with
     *  :obj:`quantities`.
     */
    setQuantities: function(quantities) {
        this.quantities = quantities;

        while (this.el.dom.firstChild) {
            this.el.dom.removeChild(this.el.dom.firstChild);
        }
        
        var quantity,
            max = 0, min = Number.POSITIVE_INFINITY,
            i, ii = quantities.length;
        for (i=0; i<ii; ++i) {
            quantity = quantities[i];
            if (quantity < min) {
                min = quantity;
            }
            if (quantity > max) {
                max = quantity;
            }
        }
        
        var bar, factor = 100 / max,
            style, height, width = (100 / ii);
        for (i=0; i<ii; ++i) {
            bar = document.createElement("div");
            bar.className = "bar";
            style = bar.style;
            style.width = width + "%";
            style.left = (i * width) + "%";
            style.top = (100 - (quantities[i] - min) * factor) + "%";
            this.el.dom.appendChild(bar);
        }
    }

});

/** api: xtype = gxp_histogram */
Ext.reg("gxp_histogram", gxp.Histogram);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp.slider
 *  class = Tip
 *  base_link = `Ext.slider.Tip <http://extjs.com/deploy/dev/docs/?class=Ext.slider.Tip>`_
 */
Ext.namespace("gxp.slider");

/** api: constructor
 *  .. class:: gxp.slider.Tip(config)
 *
 *    See http://trac.geoext.org/ticket/262
 *
 *    This tip matches the Ext.slider.Tip but addes the hover functionality.
 */
gxp.slider.Tip = Ext.extend(Ext.slider.Tip, {

    /** api: config[hover]
     *  ``Boolean`` Display the tip when hovering over a thumb.  If false, tip
     *     will only be displayed while dragging.  Default is true.
     */
    hover: true,
    
    /** private: property[dragging]
     * ``Boolean`` A thumb is currently being dragged.
     */
    dragging: false,

    /** private: method[init]
     *  :arg slider: ``Object``
     */
    init: function(slider) {
        if(this.hover) {
            slider.on("render", this.registerThumbListeners, this);
        }
        this.slider = slider;
        gxp.slider.Tip.superclass.init.apply(this, arguments);
    },
    
    /** private: method[registerThumbListeners]
     */
    registerThumbListeners: function() {
        for(var i=0, len=this.slider.thumbs.length; i<len; ++i) {
            this.slider.thumbs[i].el.on({
                "mouseover": this.createHoverListener(i),
                "mouseout": function() {
                    if(!this.dragging) {
                        this.hide.apply(this, arguments);
                    }
                },
                scope: this
            });
        }
    },
    
    /** private: method[createHoverListener]
     */
    createHoverListener: function(index) {
        return (function() {
            this.onSlide(this.slider, {}, this.slider.thumbs[index]);
            this.dragging = false;
        }).createDelegate(this);
    },

    /** private: method[onSlide]
     */
    onSlide: function(slider, e, thumb) {
        this.dragging = true;
        gxp.slider.Tip.superclass.onSlide.apply(this, arguments);
    }

});

/**
 * Copyright (c) 2008-2012 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 * @requires OpenLayers/Control/DimensionManager.js
 * @requires OpenLayers/Dimension/Agent.js
 * @requires OpenLayers/Dimension/Model.js
 */
 
/** api: (define)
 *  module = gxp.slider
 *  class = TimeSlider
 *  base_link = `Ext.slider.MultiSlider <http://extjs.com/deploy/dev/docs/?class=Ext.slider.MultiSlider>`_
 */
Ext.ns("gxp.slider");

gxp.slider.TimeSlider = Ext.extend(Ext.slider.MultiSlider, {
    ref : 'slider',
    cls : 'gx_timeslider',
    indexMap : null,
    width : 200,
    animate : false,
    timeFormat : "l, F d, Y g:i:s A",
    timeManager : null,
    playbackMode : 'track',
    autoPlay : false,
    aggressive: false,
    changeBuffer: 10,
    map: null,
    initComponent : function() {
        if(!this.timeManager) {
            this.timeManager = new OpenLayers.Control.DimensionManager();
            this.map.addControl(this.timeManager);
        }
                
        if(!this.model){
            this.model = this.timeManager.model;
        }

        if(this.timeManager.agents) {
            if(!this.timeManager.timeUnits && !this.timeManager.snapToList) {
                if(this.model.values && !this.model.resolution && this.timeManager.snapToList !== false){
                    this.timeManager.snapToList = true;
                }
                if(this.model.resolution && !this.model.values && this.model.timeUnits){
                    this.timeManager.timeUnits = this.model.timeUnits;
                    this.timeManager.timeStep = this.model.timeStep;
                }
                if(this.model.values && this.model.resolution){
                    //this.manageConflict();
                }
            }
            if(this.playbackMode && this.playbackMode != 'track') {
                if(this.timeManager.timeUnits) {
                    this.timeManager.incrementTimeValue(this.timeManager.rangeInterval);
                }
            }
        }
        
        var sliderInfo = this.buildSliderValues();
        if(sliderInfo) {
            if(!this.timeManager.snapToList && !this.timeManager.timeUnits){
            this.timeManager.guessPlaybackRate();
            }
            var initialSettings = {
                maxValue: sliderInfo.maxValue,
                minValue: sliderInfo.minValue,
                increment : sliderInfo.interval,
                keyIncrement : sliderInfo.interval,
                indexMap : sliderInfo.map,
                values: sliderInfo.values
            };
            //set an appropiate time format if one was not specified
            if(!this.initialConfig.timeFormat){
                if (sliderInfo.interval) {
                    var interval = sliderInfo.interval*OpenLayers.TimeStep[this.timeManager.timeUnits];
                    this.setTimeFormat(gxp.PlaybackToolbar.guessTimeFormat(interval));
                } else if (this.model.values) {
                    var allUnits = ['Seconds', 'Minutes', 'Hours', 'Days', 'Months', 'Years'];
                    var units = {};
                    for (var i = 1, ii = this.model.values.length; i<ii; ++i) {
                        diff = this.model.values[i] - this.model.values[i-1];
                        info = gxp.PlaybackToolbar.smartIntervalFormat(diff);
                        units[info.units] = true;
                    }
                    var unit = null;
                    for (i = 0, ii = allUnits.length; i < ii; ++i) {
                        if (units[allUnits[i]] === true) {
                            unit = allUnits[i];
                            break;
                        }
                    }
                    if (unit !== null) {
                        var format = gxp.PlaybackToolbar.timeFormats[unit];
                        if (format) {
                            this.setTimeFormat(format);
                        }
                    }
                }
            }
            //modify initialConfig so that it properly
            //reflects the initial state of this component
            Ext.applyIf(this.initialConfig,initialSettings);
            Ext.apply(this,this.initialConfig);
        }
        
        this.timeManager.events.on({
            'rangemodified': this.onRangeModified,
            'tick': this.onTimeTick,
            scope: this
        });
        
        this.plugins = (this.plugins || []).concat(
            [new Ext.slider.Tip({cls: 'gxp-timeslider-tip', getText:this.getThumbText})]);

        this.listeners = Ext.applyIf(this.listeners || {}, {
            'dragstart' : function() {
                if(this.timeManager.timer) {
                    this.timeManager.stop();
                    this._restartPlayback = true;
                }
            },
            'beforechange' : function(slider, newVal, oldVal, thumb) {
                var allow = true;
                if(!(this.timeManager.timeUnits || this.timeManager.snapToList)) {
                    allow = false;
                }
                else if(this.playbackMode == 'cumulative' && slider.indexMap[thumb.index] == 'tail') {
                    allow = false;
                }
                return allow;
            },
            'afterrender' : function(slider) {
                this.sliderTip = slider.plugins[0];
                if(this.timeManager.units && slider.thumbs.length > 1) {
                    slider.setThumbStyles();
                }
                //start playing after everything is rendered when autoPlay is true
                if(this.autoPlay) {
                    this.timeManager.play();
                }
            },
            scope : this
        });
        if (this.aggressive === true) {
            this.listeners['change'] = {fn: this.onSliderChangeComplete, buffer: this.changeBuffer};
        } else {
            this.listeners['changecomplete'] = this.onSliderChangeComplete;
        }
        gxp.slider.TimeSlider.superclass.initComponent.call(this);
        this.addEvents(
            /**
             * @event sliderclick
             * Fires when somebody clicks in the slider to change its position.
             * @param {Ext.slider.MultiSlider} slider The slider
             */
            'sliderclick'
        );
    },

    onClickChange : function(local) {
        this.fireEvent('sliderclick', this);
        gxp.slider.TimeSlider.superclass.onClickChange.apply(this, arguments);
    },

    beforeDestroy : function(){
        this.map = null;
        gxp.slider.TimeSlider.superclass.beforeDestroy.call(this);
    },

    /** api: method[setPlaybackMode]
     * :arg mode: {String} one of 'track',
     * 'cumulative', or 'ranged'
     *  
     *  Set the playback mode of the control.
     */
    setPlaybackMode: function(mode){
        this.playbackMode = mode;
        var sliderInfo = this.buildSliderValues();
        this.reconfigureSlider(sliderInfo);
        if (this.playbackMode != 'track') {
            if(this.timeManager.rangeInterval){ 
                this.timeManager.incrementTimeValue(this.timeManager.rangeInterval); 
                this.setValue(0,this.timeManager.currentValue);
            }
        }
        this.setThumbStyles();
    },
    
    setTimeFormat : function(format){
        if(format){
            this.timeFormat = format;
        }
    },
    
    onRangeModified : function(evt) {
        var ctl = this.timeManager;
        if(!ctl.agents || !ctl.agents.length) {
            //we don't have any time agents which means we should get rid of the time manager control
            //we will automattically add the control back when a time layer is added via handlers on the
            //playback plugin or the application code if the playback toolbar was not build via the plugin
            ctl.map.removeControl(this.ctl);
            ctl.destroy();
            ctl = null;
        }
        else {
            var oldvals = {
                start : ctl.animationRange[0],
                end : ctl.animationRange[1],
                resolution : {
                    units : ctl.units,
                    step : ctl.step
                }
            };
            ctl.guessPlaybackRate();
            if(ctl.animationRange[0] != oldvals.start || ctl.animationRange[1] != oldvals.end ||
                 ctl.units != oldvals.units || ctl.step != oldvals.step) {
                this.reconfigureSlider(this.buildSliderValues());
                /*
                 if (this.playbackMode == 'ranged') {
                 this.timeManager.incrementTime(this.control.rangeInterval, this.control.units);
                 }
                 */
                this.setThumbStyles();
                this.fireEvent('rangemodified', this, ctl.animationRange);
            }
        }
    },
    
    onTimeTick : function(evt) {
        var currentValue = evt.currentValue;
        if (currentValue) {
            var toolbar = this.refOwner; //TODO use relay event instead
            var tailIndex = this.indexMap ? this.indexMap.indexOf('tail') : -1;
            var offset = (tailIndex > -1) ? currentValue - this.thumbs[0].value : 0;
            this.setValue(0, currentValue);
            if(tailIndex > -1) {
                this.setValue(tailIndex, this.thumbs[tailIndex].value + offset);
            }
            this.updateTimeDisplay();
            //TODO use relay event instead, fire this directly from the slider
            toolbar.fireEvent('timechange', toolbar, currentValue);
        }
    },
    
    updateTimeDisplay: function(){
        this.sliderTip.onSlide(this,null,this.thumbs[0]);
        this.sliderTip.el.alignTo(this.el, 'b-t?', this.offsets);
    },
    
    buildSliderValues : function() {
        var mngr = this.timeManager;
        if(!mngr.step && !mngr.snapToList){
            //timeManager is essentially empty if both of these are false/null
            return false;
        }
        else{
            var indexMap = ['primary'], 
                values = [mngr.currentValue],
                min = mngr.animationRange[0],
                max = mngr.animationRange[1],
                interval = false;

            if(this.dynamicRange) {
                var rangeAdj = (min - max) * 0.1;
                values.push( min = min - rangeAdj, max = max + rangeAdj);
                indexMap[1] = 'minTime';
                indexMap[2] = 'maxTime';
            }
            if(this.playbackMode != 'track') {
                values.push(min);
                indexMap[indexMap.length] = 'tail';
            }
            //set slider interval based on the step value
            if(!mngr.snapToList){
                // OpenLayers.Control.DimensionManger.step should
                // always be a real numeric value, even if timeUnits & timeStep are set
                interval = mngr.step;
            }

            return {
                'values' : values,
                'map' : indexMap,
                'maxValue' : max,
                'minValue' : min,
                'interval' : interval
            };
        }
    },

    reconfigureSlider : function(sliderInfo) {
        var slider = this;
        slider.setMaxValue(sliderInfo.maxValue);
        slider.setMinValue(sliderInfo.minValue);
        Ext.apply(slider, {
            increment : sliderInfo.interval,
            keyIncrement : sliderInfo.interval,
            indexMap : sliderInfo.map
        });
        for(var i = 0; i < sliderInfo.values.length; i++) {
            if(slider.thumbs[i]) {
                slider.setValue(i, sliderInfo.values[i]);
            }
            else {
                slider.addThumb(sliderInfo.values[i]);
            }
        }
        //set format of slider based on the interval steps
        if(!sliderInfo.interval && slider.timeManager.modelCache.values) {
            sliderInfo.interval = Math.round((sliderInfo.maxValue - sliderInfo.minValue) / this.timeManager.modelCache.values.length);
        }
        this.setTimeFormat(gxp.PlaybackToolbar.guessTimeFormat(sliderInfo.interval));
    },

    setThumbStyles : function() {
        var slider = this;
        var tailIndex = slider.indexMap.indexOf('tail');
        if(slider.indexMap[1] == 'min') {
            slider.thumbs[1].el.addClass('x-slider-min-thumb');
            slider.thumbs[2].el.addClass('x-slider-max-thumb');
        }
        if(tailIndex > -1) {
            var tailThumb = slider.thumbs[tailIndex];
            var headThumb = slider.thumbs[0];
            tailThumb.el.addClass('x-slider-tail-thumb');
            tailThumb.constrain = false;
            headThumb.constrain = false;
        }
    },    

    getThumbText: function(thumb) {
        if(thumb.slider.indexMap[thumb.index] != 'tail') {
            var d = new Date(thumb.value);
            d.setTime( d.getTime() + d.getTimezoneOffset()*60*1000 );
            return (d.format(thumb.slider.timeFormat));
        }
        else {
            var formatInfo = gxp.PlaybackToolbar.smartIntervalFormat.call(thumb, thumb.slider.thumbs[0].value - thumb.value);
            return formatInfo.value + ' ' + formatInfo.units;
        }
    },

    onSliderChangeComplete: function(slider, value, thumb, silent){
        var timeManager = slider.timeManager;
        if (value === timeManager.currentValue) {
            return;
        }
        //test if this is the main time slider
        switch (slider.indexMap[thumb.index]) {
            case 'primary':
                //if we have a tail slider, then the range interval should be updated first
                var tailIndex = slider.indexMap.indexOf('tail'); 
                if (tailIndex>-1){
                    slider.onSliderChangeComplete(slider,slider.thumbs[tailIndex].value,slider.thumbs[tailIndex],true);
                }
                if (!timeManager.snapToList && timeManager.timeUnits) {
                    //this will make the value actually be modified by the exact time unit
                    var op = value > timeManager.currentValue ? 'ceil' : 'floor';
                    var steps = Math[op]((value-timeManager.currentValue)/OpenLayers.TimeStep[timeManager.timeUnits]);
                    timeManager.setCurrentValue(timeManager.incrementTimeValue(steps));
                            } else {
                    timeManager.setCurrentValue(value);
                }
                break;
            case 'min':
                    timeManager.setAnimationStart(value);
                break;
            case 'max':
                    timeManager.seAnimantionEnd(value);
                break;
            case 'tail':
                for (var i = 0, len = timeManager.agents.length; i < len; i++) {
                    if(timeManager.agents[i].tickMode == 'range'){
                        timeManager.agents[i].rangeInterval = (slider.thumbs[0].value - value);
                    }
                }
                if(!silent){
                    timeManager.setCurrentValue(slider.thumbs[0].value);
                }
        }
        if (this._restartPlayback) {
            delete this._restartPlayback;
            timeManager.play();
        }
    },

    // override to add pre buffer progress
    onRender : function() {
        this.autoEl = {
            cls: 'x-slider ' + (this.vertical ? 'x-slider-vert' : 'x-slider-horz'),
            cn : [{
                cls: 'x-slider-end',
                cn : {
                    cls:'x-slider-inner',
                    cn : [{tag:'a', cls:'x-slider-focus', href:"#", tabIndex: '-1', hidefocus:'on'}]
                }
            }, {cls: 'x-slider-progress'}]
        };

        Ext.slider.MultiSlider.superclass.onRender.apply(this, arguments);

        this.endEl   = this.el.first();
        this.progressEl = this.el.child('.x-slider-progress');
        this.innerEl = this.endEl.first();
        this.focusEl = this.innerEl.child('.x-slider-focus');

        //render each thumb
        for (var i=0; i < this.thumbs.length; i++) {
            this.thumbs[i].render();
        }

        //calculate the size of half a thumb
        var thumb      = this.innerEl.child('.x-slider-thumb');
        this.halfThumb = (this.vertical ? thumb.getHeight() : thumb.getWidth()) / 2;

        this.initEvents();
    }

});

Ext.reg('gxp_timeslider', gxp.slider.TimeSlider);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires OpenLayers/Control/DimensionManager.js
 * @requires OpenLayers/Dimension/Agent.js
 * @requires OpenLayers/Dimension/Agent/WMS.js
 * @requires widgets/slider/TimeSlider.js
 */

/** api: (define)
 *  module = gxp
 *  class = PlaybackToolbar
 *  base_link = `Ext.Toolbar <http://dev.sencha.com/deploy/dev/docs/?class=Ext.Toolbar>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: PlaybackToolbar(config)
 *   
 *      Create a toolbar for showing a series of playback controls.
 */
gxp.PlaybackToolbar = Ext.extend(Ext.Toolbar, {
    
    /** api: config[control]
     *  ``OpenLayers.Control`` or :class:`OpenLayers.Control.DimensionManager`
     *  The control to configure the playback panel with.
     */
    control: null,
    dimModel: null,
    mapPanel: null,
    initialTime:null,
    timeFormat:"l, F d, Y g:i:s A",
    toolbarCls:'x-toolbar gx-overlay-playback', //must use toolbarCls since it is used instead of baseCls in toolbars
    ctCls: 'gx-playback-wrap',
    slider:true,
    dynamicRange:false,
    //api config
    //playback mode is one of: "track","cumulative","ranged"
    playbackMode:"track",
    showIntervals:false,
    labelButtons:false,
    settingsButton:true,
    rateAdjuster:false,
    looped:false,
    autoPlay:false,
    /* should the time slider be aggressive or not */
    aggressive: null,
    /* should we prebuffer the time series or not */
    prebuffer: null,
    /* how many frames should we prebuffer at maximum */
    maxframes: null,
    //api config ->timeDisplayConfig:null,
    //api property
    optionsWindow:null,
    /** api: property[playing]
     * ``Boolean``
     * Boolean flag indicating the control is currently playing or not.
     * Read-only
     */
    playing: false,
    // api config
    //playbackActions, default: ["settings","reset","play","fastforward","next","loop"]; also available are "pause" and "end"
    
    //i18n
    /** api: config[playLabel]
     *  ``String``
     *  Text for play button label (i18n).
     */
    playLabel:'Play',
    /** api: config[playTooltip]
     *  ``String``
     *  Text for play button tooltip (i18n).
     */
    playTooltip:'Play',
    stopLabel:'Stop',
    stopTooltip:'Stop',
    fastforwardLabel:'FFWD',
    fastforwardTooltip:'Double Speed Playback',
    nextLabel:'Next',
    nextTooltip:'Advance One Frame',
    resetLabel:'Reset',
    resetTooltip:'Reset to the start',
    loopLabel:'Loop',
    loopTooltip:'Continously loop the animation',
    normalTooltip:'Return to normal playback',
    pauseLabel:'Pause',
    pauseTooltip:'Pause',

    /** private: method[initComponent]
     *  Initialize the component.
     */
    initComponent: function() {
        if(!this.playbackActions){
            this.playbackActions = ["settings","slider","reset","play","fastforward","next","loop"];
        }
        if(!this.control){
            this.controlConfig = Ext.applyIf(this.controlConfig || {}, {
                dimension: 'time',
                prebuffer: this.prebuffer,
                maxframes: this.maxframes,
                autoSync: true
            });
            this.control = this.buildTimeManager();
        }
        this.control.events.on({
            'play':function(evt){
                this.playing = true;
            },
            'stop':function(evt){
                this.playing = false;
            },
            scope: this
        });
        if(!this.dimModel){
            this.dimModel = new OpenLayers.Dimension.Model({
                dimension: 'time',
                map: this.mapPanel.map
            });
        }
        this.mapPanel.map.events.on({
            'zoomend': function() {
                if (this._prebuffer === true && this.mapPanel.map.zoom !== this.previousZoom) {
                    this._stopPrebuffer = true;
                    this.slider.progressEl.hide();
                    this.mapPanel.map.events.un({'zoomend': arguments.callee, scope: this});
                }
                this.previousZoom = this.mapPanel.map.zoom;
            }, scope: this
        });
        this.control.events.on({
            'prebuffer': function(evt) {
                this._prebuffer = true;
                if (this._stopPrebuffer === true) {
                    this.slider.progressEl.hide();
                }
                this.slider.progressEl.setWidth(evt.progress*100 + '%');
                return (this._stopPrebuffer !== true);
            },
            scope: this
        });

        this.availableTools = Ext.applyIf(this.availableTools || {}, this.getAvailableTools());
        
        Ext.applyIf(this,{
            defaults:{xtype:'button',flex:1,scale:'small'},
            items:this.buildPlaybackItems(),
            border:false,
            frame:false,
            unstyled:true,
            shadow:false,
            timeDisplayConfig:{'xtype':'tip',format:this.timeFormat,height:'auto',closeable:false,title:false,width:210}
        });
        this.addEvents(
            /**
             * Event: timechange
             * Fires when the current time represented changes.
             *
             * Listener arguments:
             * toolbar - {gxp.plugin.PlaybackToolbar} This playback toolbar
             * currentValue - {Number} The current time value represented in the DimensionManager control
             *      attached to this toolbar
             */
            "timechange",
            /**
             * Event: rangemodified
             * Fires when the start and/or end times of the slider change
             *
             * Listener arguments:
             * toolbar - {gxp.plugin.PlaybackToolbar} This playback toolbar
             * range - {Array(Date)} The current time range for playback allowed in the
             *      TimeManager control attached to this toolbar
             */
            "rangemodified"
        );
        gxp.PlaybackToolbar.superclass.initComponent.call(this);
    },
    /** private: method[destroy]
     *  Destory the component.
     */
    destroy: function(){
        //kill the control but only if we created the control
        if(this.control && !this.initialConfig.control){
            this.control.map && this.control.map.removeControl(this.control);
            this.control.destroy();
            this.control = null;
        }
        this.mapPanel = null;
        gxp.PlaybackToolbar.superclass.destroy.call(this);
    },
    /** api: method[setTime]
     *  :arg time: {Date}
     *  :return: {Boolean} - true if the time could be set to the supplied value
     *          false if the time is outside the current range of the TimeManager
     *          control.
     *
     *  Set the time represented by the playback toolbar programatically
     */
    setTime: function(time){
        var timeVal = time.getTime();
        if(timeVal<this.slider.minValue || timeVal>this.slider.maxValue){
            return false;
        }else{
            this.control.setCurrentValue(timeVal);
            return true;
        }
    },
    /** api: method[setTimeFormat]
     *  :arg format: {String}
     *
     *  Set the format string used by the time slider tooltip
     */
    setTimeFormat: function(format){
        if(format){
            this.timeFormat = format;
            this.slider.setTimeFormat(format);
        }
    },
    /** api: method[setPlaybackMode]
     * :arg mode: {String} one of 'track',
     * 'cumulative', or 'ranged'
     *
     *  Set the playback mode of the control.
     */
    setPlaybackMode: function(mode){
        if(mode){
            this.playbackMode = mode;
            if(this.slider){ this.slider.setPlaybackMode(mode); }
        }
    },

    /** private: method[buildPlaybackItems] */
    buildPlaybackItems: function(){
        var tools = this.playbackActions;
        var items =[];
        for(var i=0,len=tools.length;i<len;i++){
            var key = tools[i];
            var tool = this.availableTools[key];
            if(tool){
                items.push(tool);
            } else {
                if(['|',' ','->'].indexOf(key)>-1){
                    items.push(key);
                }
            }
        }
        return items;
    },

    getAvailableTools: function(){
        var tools = {
            'slider': {
                xtype: 'gxp_timeslider',
                ref: 'slider',
                listeners: {
                    'sliderclick': {
                        fn: function() {
                            this._stopPrebuffer = true;
                        },
                        scope: this
                    },
                    'dragstart': {
                        fn: function() {
                            this._stopPrebuffer = true;
                        },
                        scope: this
                    }
                },
                map: this.mapPanel.map,
                timeManager: this.control,
                model: this.dimModel,
                playbackMode: this.playbackMode,
                aggressive: this.aggressive
            },
            'reset': {
                iconCls: 'gxp-icon-reset',
                ref:'btnReset',
                handler: this.control.reset,
                scope: this.control,
                tooltip: this.resetTooltip,
                menuText: this.resetLabel,
                text: (this.labelButtons) ? this.resetLabel : false
            },
            'pause': {
                iconCls: 'gxp-icon-pause',
                ref:'btnPause',
                handler: this.control.stop,
                scope: this.control,
                tooltip: this.stopTooltip,
                menuText: this.stopLabel,
                text: (this.labelButtons) ? this.stopLabel : false,
                toggleGroup: 'timecontrol',
                enableToggle: true,
                allowDepress: false
            },
            'play': {
                iconCls: 'gxp-icon-play',
                ref:'btnPlay',
                toggleHandler: this.toggleAnimation,
                scope: this,
                toggleGroup: 'timecontrol',
                enableToggle: true,
                allowDepress: true,
                tooltip: this.playTooltip,
                menuText: this.playLabel,
                text: (this.labelButtons) ? this.playLabel : false
            },
            'next': {
                iconCls: 'gxp-icon-next',
                ref:'btnNext',
                handler: function(){
                    this.stop();
                    this.tick();
                },
                scope: this.control,
                tooltip: this.nextTooltip,
                menuText: this.nextLabel,
                text: (this.labelButtons) ? this.nextLabel : false
            },
            'end': {
                iconCls: 'gxp-icon-last',
                ref:'btnEnd',
                handler: this.forwardToEnd,
                scope: this,
                tooltip: this.endTooltip,
                menuText: this.endLabel,
                text: (this.labelButtons) ? this.endLabel : false
            },
            'loop': {
                iconCls: 'gxp-icon-loop',
                ref:'btnLoop',
                tooltip: this.loopTooltip,
                enableToggle: true,
                allowDepress: true,
                pressed: this.looped,
                toggleHandler: this.toggleLoopMode,
                scope: this,
                menuText: this.loopLabel,
                text: (this.labelButtons) ? this.loopLabel : false
            },
            'fastforward': {
                iconCls: 'gxp-icon-ffwd',
                ref:'btnFastforward',
                tooltip: this.fastforwardTooltip,
                enableToggle: true,
                //allowDepress: true,
                toggleGroup: 'fastforward',
                toggleHandler: this.toggleDoubleSpeed,
                scope: this,
                disabled:true,
                menuText: this.fastforwardLabel,
                text: (this.labelButtons) ? this.fastforwardLabel : false
            },
            'settings': {
                iconCls: 'gxp-icon-settings',
                ref:'btnSettings',
                scope: this,
                handler:this.toggleOptionsWindow,
                enableToggle:false,
                tooltip: this.settingsTooltip,
                menuText: this.settingsLabel,
                text: (this.labelButtons) ? this.settingsLabel : false
            }
        };
        return tools;
    },

    buildTimeManager:function() {
        this.controlConfig || (this.controlConfig = {});
        // Test for and deal with pre-configured timeAgents & layers
        if(this.controlConfig.timeAgents) {
            //handle deprecated timeAgents property
            this.controlConfig.agents = this.controlConfig.timeAgents;
            delete this.controlConfig.timeAgents;
        }
        if(this.controlConfig.agents){
            for(var i = 0; i < this.controlConfig.agents.length; i++) {
                var config = this.controlConfig.agents[i];
                var agentClass = config.type;
                var layers = [];
                //put real layers, not references here
                Ext.each(config.layers, function(lyrJson) {
                    //source & name identify different layers, but title & styles
                    //are required to distinguish the same layer added multiple times with a different
                    //style or presentation
                    var ndx = this.mapPanel.layers.findBy(function(rec) {
                        return rec.json &&
                        rec.json.source == lyrJson.source &&
                        rec.json.title == lyrJson.title &&
                        rec.json.name == lyrJson.name &&
                        (rec.json.styles == lyrJson.styles ||
                            !!rec.json.styles == false && !!lyrJson.styles == false);
                    });

                    if(ndx > -1) {
                        layers.push(this.mapPanel.layers.getAt(ndx).getLayer());
                    }
                }, this);

                config.layers = layers;
                if(config.rangeMode){
                    //handle deprecated rangeMode property
                    config.tickMode = config.rangeMode;
                    delete config.rangeMode;
                }
                delete config.type;
                if(!config.dimension){ config.dimension = 'time'; }
                //TODO handle other subclasses of Dimension Agent subclasses
                var agent = agentClass && OpenLayers.Dimension.Agent[agentClass] ?
                    new OpenLayers.Dimension.Agent[agentClass](config) : new OpenLayers.Dimension.Agent(config);
                this.controlConfig.agents[i] = agent;
            }
        }
        else {
            if(this.playbackMode == 'ranged') {
                Ext.apply(this.controlConfig, {
                    agentOptions : {
                        'WMS' : {
                            tickMode : 'range',
                            rangeInterval : this.controlConfig.rangeInterval || undefined
                        },
                        'Vector' : {
                            tickMode : 'range',
                            rangeInterval : this.controlConfig.rangeInterval || undefined
                        }
                    }
                });
            }
            else if(this.playbackMode == 'cumulative') {
                Ext.apply(this.controlConfig, {
                    agentOptions : {
                        'WMS' : {
                            tickMode : 'cumulative'
                        },
                        'Vector' : {
                            tickMode : 'cumulative'
                        }
                    }
                });
            }
        }
        //DON'T DROP FRAMES
        //this.controlConfig.maxFrameDelay = NaN;
        if(!this.controlConfig.dimension){ this.controlConfig.dimension = 'time'; }
        var ctl = this.control = new OpenLayers.Control.DimensionManager(this.controlConfig);
        ctl.loop = this.looped;
        this.mapPanel.map.addControl(ctl);
        if(ctl.layers) {
            this.fireEvent('rangemodified', this, ctl.range);
        }
        return ctl;
    },

/** BUTTON HANDLERS **/
    forwardToEnd: function(btn){
        var ctl = this.control;
        ctl.setCurrentValue(ctl.animationRange[(ctl.step < 0) ? 0 : 1]);
    },
    toggleAnimation:function(btn,pressed){
        if(!btn.bound && pressed){
            this.control.events.on({
                'stop':function(evt){
                    btn.toggle(false);
                    if(evt.rangeExceeded){
                        this._resetOnPlay = true;
                    }
                },
                'play':function(evt){
                    btn.toggle(true);
                    if(this._resetOnPlay){
                        this.reset();
                        delete this._resetOnPlay;
                    }
                }
            });
            btn.bound=true;
        }

        if(pressed){
            if(!this.playing){
                //don't start playing again if it is already playing
                this.control.play();
            }
            btn.btnEl.removeClass('gxp-icon-play');
            btn.btnEl.addClass('gxp-icon-pause');
            btn.setTooltip(this.pauseTooltip);
        } else {
            if(this.playing){
                //don't stop playing again if it is already stopped
                this.control.stop();
            }
            btn.btnEl.addClass('gxp-icon-play');
            btn.btnEl.removeClass('gxp-icon-pause');
            btn.setTooltip(this.playTooltip);
        }

        btn.el.removeClass('x-btn-pressed');
        btn.refOwner.btnFastforward.setDisabled(!pressed);
        if(this.labelButtons && btn.text){
            btn.setText(pressed?this.pauseLabel:this.playLabel);
        }
    },
    toggleLoopMode:function(btn,pressed){
        this.control.loop=pressed;
        btn.setTooltip(pressed?this.normalTooltip:this.loopTooltip);
        if(this.labelButtons && btn.text){
            btn.setText(pressed?this.normalLabel:this.loopLabel);
        }
    },
    toggleDoubleSpeed:function(btn,pressed){
        var framerate = this.control.frameRate * ((pressed) ? 2 : 0.5);
        this.control.setFrameRate(framerate);
        btn.setTooltip((pressed) ? this.normalTooltip : this.fastforwardTooltip);
    },
    toggleOptionsWindow:function(btn,pressed){
        if(pressed && this.optionsWindow.hidden){
            if(!this.optionsWindow.optionsPanel.timeManager){
                this.optionsWindow.optionsPanel.timeManager = this.control;
                this.optionsWindow.optionsPanel.playbackToolbar = this;
            }
            this.optionsWindow.show();
        }
        else if(!pressed && !this.optionsWindow.hidden){
            this.optionsWindow.hide();
        }
    }
});


gxp.PlaybackToolbar.timeFormats = {
   'Minutes': 'l, F d, Y g:i A',
   'Hours': 'l, F d, Y g A',
   'Days': 'l, F d, Y',
   'Months': 'F, Y',
   'Years': 'Y'
};

/**
 * Static Methods
 */
gxp.PlaybackToolbar.guessTimeFormat = function(increment){
    if (increment) {
        var resolution = gxp.PlaybackToolbar.smartIntervalFormat(increment).units;
        var format = this.timeFormat;
        if (gxp.PlaybackToolbar.timeFormats[resolution]) {
            format = gxp.PlaybackToolbar.timeFormats[resolution];
        }
        return format;
    }
};
gxp.PlaybackToolbar.smartIntervalFormat = function(diff){
    var unitText, diffValue, absDiff=Math.abs(diff);
    if(absDiff<5e3){
        unitText='Seconds';
        diffValue=(Math.round(diff/1e2))/10;
    }
    else if(absDiff<35e5){
        unitText='Minutes';
        diffValue=(Math.round(diff/6e2))/10;
    }
    else if(absDiff<828e5){
        unitText='Hours';
        diffValue=(Math.round(diff/36e4))/10;
    }
    else if(absDiff<250e7){
        unitText='Days';
        diffValue=(Math.round(diff/864e4))/10;
    }
    else if(absDiff<311e8){
        unitText='Months';
        diffValue=(Math.round(diff/2628e5))/10;
    }else{
        unitText='Years';
        diffValue=(Math.round(diff/31536e5))/10;
    }
    return {units:unitText,value:diffValue};
};

/** api: xtype = gxp_playbacktoolbar */
Ext.reg('gxp_playbacktoolbar', gxp.PlaybackToolbar);

/**
 * Copyright (c) 2008-2012 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp.form
 *  class = PlaybackModeComboBox
 *  base_link = `Ext.form.ComboBox <http://extjs.com/deploy/dev/docs/?class=Ext.form.ComboBox>`_
 */
Ext.namespace("gxp.form");    

/** api: constructor
 *  .. class:: PalybackModeComboBox(config)
 *   
 *      A combo box for selecting the playback mode of temporal layer(s).
 */
gxp.form.PlaybackModeComboBox = Ext.extend(Ext.form.ComboBox, {
    
    /** i18n */
    modeFieldText: 'Playback Mode',
    normalOptText: 'Normal',
    cumulativeOptText: 'Cumulative',
    rangedOptText: 'Ranged',
    
    
    /** private: property[modes]
     *  ``Array``
     *  List of playback mode options to choose from.
     */
    modes: [], //purposefully adding this to prototype
    
    /** api: property[defaultMode]
     *  ``String``
     *  The value of ``modes`` item to select by default.
     *  Default is ``track`` ('Normal' mode)
     */
    defaultMode: 'track',
    
    /** api: property[agents]
     *  ``Array``(``OpenLayers.TimeAgent``)
     *  The array of time agents that this combo box will modify
     */
    agents: null,

    allowBlank: false,

    mode: "local",

    triggerAction: "all",

    editable: false,
    
    constructor: function(config){
        this.addEvents(
            "beforemodechange",

            /** api: event[modechange]
             *  Fired when the playback mode changes.
             *
             *  Listener arguments:
             *
             *  * field - :class:`gxp.form.PlaybackModeComboBox` This field.
             *  * mode - :``String`` The selected mode value
             *  * agents - :class:`OpenLayers.TimeAgent` An array of the time agents effected
             */
            "modechange"
        );
        //initialize the default modes
        if(!config.modes && !this.modes.length){
            this.modes.push(['track', this.normalOptText], ['cumulative', this.cumulativeOptText], ['ranged', this.rangedOptText]);
        }
        gxp.form.PlaybackModeComboBox.superclass.constructor.call(this,config);
  },
    initComponent: function() {
        var modes = this.modes; 
        var defaultMode = this.defaultMode;
        
        var defConfig = {
            displayField : "field2",
            valueField : "field1",
            store : modes,
            value : defaultMode,
            listeners : {
                'select' : this.setPlaybackMode,
                scope : this
            }
        };

        Ext.applyIf(this, defConfig);
        
        gxp.form.PlaybackModeComboBox.superclass.initComponent.call(this);
    },
    
    setPlaybackMode: function(combo, record, index){
        this.fireEvent('beforemodechange');
        if(!this.agents && window.console){
            window.console.warn("No agents configured for playback mode combobox");
            return;
        }
        var mode = record.get('field1');
        Ext.each(this.agents,function(agent){
            agent.tickMode = mode;
            if(mode == 'range') {
                if(!agent.rangeInterval) {
                    agent.rangeInterval = 1;
                }
            }
        });
        this.fireEvent('modechange',this,mode,this.agents);
    }
    
});

/** api: xtype = gxp_fontcombo */
Ext.reg("gxp_playbackmodecombo", gxp.form.PlaybackModeComboBox);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires widgets/PlaybackToolbar.js
 * @requires widgets/form/PlaybackModeComboBox.js
 * @requires OpenLayers/Control/DimensionManager.js
 */

/** api: (define)
 *  module = gxp
 *  class = PlaybackOptionsPanel
 *  base_link = `Ext.Panel <http://extjs.com/deploy/dev/docs/?class=Ext.Panel>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: PlaybackOptionsPanel(config)
 *   
 *      A panel for displaying and modifiying the configuration options for the PlaybackToolbar.
 */
gxp.PlaybackOptionsPanel = Ext.extend(Ext.Panel, {
    
    /** api: config[viewer]
     *  ``gxp.Viewer``
     */

    /** api: config[playbackToolbar]
     *  ``gxp.PlaybackToolbar``
     */
    
    /** api: config[timeManager]
     *  ``OpenLayers.Control.DimensionalManager``
     */
    
    layout: "fit",

    /** i18n */
    titleText: "Date & Time Options",
    rangeFieldsetText: "Time Range",
    animationFieldsetText: "Animation Options",
    startText:'Start',
    endText:'End',
    listOnlyText:'Use Exact List Values Only',
    stepText:'Animation Step',
    unitsText:'Animation Units',
    noUnitsText:'Snap To Time List',
    loopText:'Loop Animation',
    reverseText:'Reverse Animation',
    rangeChoiceText:'Choose the range for the time control',
    rangedPlayChoiceText:'Playback Mode',
    
    /** private: method[initComponent]
     */
    initComponent: function() {
        var config = Ext.applyIf(this.initialConfig,{
            minHeight:400,
            minWidth:275,
            ref:'optionsPanel',
            items:[
            {
                xtype: 'form',
                layout: 'form',
                autoScroll: true,
                ref:'form',
                labelWidth:10,
                defaultType: 'textfield',
                items: [{
                    xtype: 'fieldset',
                    title: this.rangeFieldsetText,
                    defaultType: 'datefield',
                    labelWidth: 60,
                    items: [{
                        xtype: 'displayfield',
                        text: this.rangeChoiceText
                    }, {
                        fieldLabel: this.startText,
                        listeners: {
                            'select': this.setStartTime,
                            'change': this.setStartTime,
                            scope: this
                        },
                        ref: '../../rangeStartField'
                    }, {
                        fieldLabel: this.endText,
                        listeners: {
                            'select': this.setEndTime,
                            'change': this.setEndTime,
                            scope: this
                        },
                        ref: '../../rangeEndField'
                    }]
                }, {
                    xtype: 'fieldset',
                    title: this.animationFieldsetText,
                    labelWidth:100,
                    items: [
                    {
                      boxLabel:this.listOnlyText,
                      hideLabel:true,
                      xtype:'checkbox',
                      handler:this.toggleListMode,
                      scope:this,
                      ref:'../../listOnlyCheck'
                    },
                    {
                        fieldLabel: this.stepText,
                        xtype: 'numberfield',
                        anchor:'-25',
                        enableKeyEvents:true,
                        listeners: {
                            'change': this.setStep,
                            scope: this
                        },
                        ref: '../../stepValueField'
                    }, {
                        fieldLabel: this.unitsText,
                        xtype: 'combo',
                        anchor:'-5',
                        //TODO: i18n these time units
                        store: [
                            [OpenLayers.TimeUnit.SECONDS,'Seconds'], 
                            [OpenLayers.TimeUnit.MINUTES,'Minutes'], 
                            [OpenLayers.TimeUnit.HOURS,'Hours'], 
                            [OpenLayers.TimeUnit.DAYS,'Days'], 
                            [OpenLayers.TimeUnit.MONTHS,"Months"], 
                            [OpenLayers.TimeUnit.YEARS,'Years']
                        ],
                        valueNotFoundText:this.noUnitsText,
                        mode:'local',
                        forceSelection:true,
                        autoSelect:false,
                        editable:false,
                        triggerAction:'all',
                        listeners: {
                            'select': this.setUnits,
                            scope: this
                        },
                        ref: '../../stepUnitsField'
                    },{
                        //TODO: provide user information about these modes (Change to radio group?)
                        fieldLabel:this.rangedPlayChoiceText,
                        xtype:'gxp_playbackmodecombo',
                        agents: this.timeManager && this.timeManager.agents,
                        anchor:'-5',
                        listeners:{
                            'modechange':this.setPlaybackMode,
                            scope:this
                        },
                        ref:'../../playbackModeField'
                    }]
                },
                {
                    xtype:'checkbox',
                    boxLabel:this.loopText,
                    handler:this.setLoopMode,
                    scope:this,
                    ref:'../loopModeCheck'
                },
                {
                    xtype:'checkbox',
                    boxLabel:this.reverseText,
                    handler:this.setReverseMode,
                    scope:this,
                    ref:'../reverseModeCheck'
                }]
            }
            ],
            bbar: [{text: "Save", ref: '../saveBtn', hidden: this.readOnly, handler: function() { this.fireEvent('save', this); }, scope: this}]
        });
        Ext.apply(this,config);
        this.on('show', this.populateForm, this);
        gxp.PlaybackOptionsPanel.superclass.initComponent.call(this);
    },
    destroy:function(){
        this.timeManager = null;
        this.playbackToolbar = null;
        this.un('show',this,this.populateForm);
        gxp.PlaybackOptionsPanel.superclass.destroy.call(this);
    },
    setStartTime: function(cmp, date){
        this.timeManager.setAnimationStart(date.getTime());
        this.timeManager.fixedRange=true;
    },
    setEndTime:function(cmp,date){
        this.timeManager.setAnimationEnd(date.getTime());
        this.timeManager.fixedRange=true;
    },
    toggleListMode: function(cmp, checked){
        this.stepValueField.setDisabled(checked);
        this.stepUnitsField.setDisabled(checked);
        this.timeManager.snapToList = checked;
    },
    setUnits:function(cmp,record,index){
        var units = record.get('field1');
        if(this.timeManager.timeUnits != units){
            this.timeManager.timeUnits = units;
            this.timeManager.step = cmp.refOwner.stepValueField.value * OpenLayers.TimeStep[units];
            if(this.playbackToolbar.playbackMode != 'track'){
                this.timeManager.incrementValue();
            }
        }
    },
    setStep:function(cmp,newVal,oldVal){
        if(cmp.validate() && newVal){
            this.timeManager.step = newVal * OpenLayers.TimeStep[this.timeManager.timeUnits];
            this.timeManager.timeStep = newVal;
            if(this.playbackToolbar.playbackMode == 'ranged' && 
                this.timeManager.rangeInterval != newVal){
                    this.timeManager.rangeInterval = newVal;
                    this.timeManager.incrementTimeValue(newVal);
            }
        }
    },
    setPlaybackMode:function(cmp,mode,agents){
        var origMode = cmp.startValue;

        //adjust any time agents which had the same playback mode as the toolbar
        Ext.each(agents, function(agent){
            if(agent.tickMode == origMode){
                agent.tickMode = mode;
        }
        });

        this.disableListMode(mode=='ranged');
        this.playbackToolbar.setPlaybackMode(mode);
    },
    disableListMode:function(state){
        var disable = state!==false;
        if (disable) {
            this.listOnlyCheck.setValue(!disable);
        }
        this.listOnlyCheck.setDisabled(disable);
    },
    setLoopMode:function(cmp,checked){
        this.timeManager.loop=checked;
    },
    setReverseMode:function(cmp,checked){
        this.timeManager.step *= -1;
    },
    populateForm: function(cmp){
        this.readOnly ? this.saveBtn.hide() : this.saveBtn.show();
        this.doLayout();
        if (this.timeManager) {
            var start = new Date(this.timeManager.animationRange[0]),
            end = new Date(this.timeManager.animationRange[1]),
            step = this.timeManager.timeStep,
            unit = this.timeManager.timeUnit,
            snap = this.timeManager.snapToList,
            mode = (this.playbackToolbar) ? this.playbackToolbar.playbackMode : this.timeManager.agents[0].tickMode,
            loop = this.timeManager.loop,
            reverse = this.timeManager.step < 0;
            this.rangeStartField.setValue(start);
            this.rangeStartField.originalValue = start;
            this.rangeEndField.setValue(end);
            this.rangeEndField.originalValue = end;
            this.stepValueField.originalValue = this.stepValueField.setValue(step);
            this.stepUnitsField.originalValue = this.stepUnitsField.setValue(unit);
            this.listOnlyCheck.setValue(snap);
            this.listOnlyCheck.originalValue = snap;
            if(!this.playbackModeField.agents || !this.playbackModeField.agents.length){
                this.playbackModeField.agents = this.timeManager.agents;
            }
            this.playbackModeField.setValue(mode);
            this.playbackModeField.originalValue = mode;
            this.loopModeCheck.setValue(loop);
            this.loopModeCheck.originalValue = loop;
            this.reverseModeCheck.setValue(reverse);
            this.reverseModeCheck.originalValue=reverse;
        }
    },
    close: function(btn){
        if(this.ownerCt && this.ownerCt.close){
            this.ownerCt[this.ownerCt.closeAction]();
        }
    }
});

/** api: xtype = gxp_playbackoptions */
Ext.reg('gxp_playbackoptions', gxp.PlaybackOptionsPanel);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */
 
/** api: (define)
 *  module = gxp.slider
 *  class = ClassBreakSlider
 *  base_link = `Ext.slider.MultiSlider <http://extjs.com/deploy/dev/docs/?class=Ext.slider.MultiSlider>`_
 */
Ext.namespace("gxp.slider");

/** api: constructor
 *  .. class:: ClassBreakSlider(config)
 *   
 *      Slider to adjust class breaks in a ColorMap or a set of filtered rules.
 */
gxp.slider.ClassBreakSlider = Ext.extend(Ext.slider.MultiSlider, {
    
    /** api: config[store]
     *  ``Ext.data.Store``
     *  A (filtered) store containing records with a ``filter``
     *  (``OpenLayers.Filter.Comparison``|``Number``) field. Usually records
     *  are created with a :class:`gxp.data.GroupStyleReader`. Comparison
     *  filters are expected to be ``PropertyIsLessThan``,
     *  ``PropertyIsBetween`` or ``PropertyIsGreaterThanOrEqualTo``.
     */
    store: null,
    
    /** api: config[values]
     *  ``Array(Number)`` Will be ignored. Configure :attr:`store` instead.
     */
    
    /** api: config[constrainThumbs]
     *  ``false`` to allow thumbs to overlap one another. Defaults to ``true``
     *  when the store contains rules, and ``false`` when it contains color
     *  map entries.
     */
    
    /** private: method[initComponent]
     */
    initComponent: function() {
        this.store = Ext.StoreMgr.lookup(this.store);
        if (!("constrainThumbs" in this.initialConfig)) {
            this.constrainThumbs = this.store.reader.raw instanceof OpenLayers.Style;
        }
        this.values = this.storeToValues();
        this.on("changecomplete", this.valuesToStore);
        this.store.on("update", this.storeToValues, this);
        gxp.slider.ClassBreakSlider.superclass.initComponent.call(this);        
    },
    
    /** private: method[storeToValues]
     *  :returns: ``Array(Number)`` The thumb values. If the slider has thumbs
     *  already, the thumb values will be updated.
     *
     *  Calculates the thumb values from the filters in the store's records.
     */
    storeToValues: function() {
        var values = [];
        this.store.each(function(rec) {
            var filter = rec.get("filter");
            if (filter instanceof OpenLayers.Filter) {
                if (filter.type === OpenLayers.Filter.Comparison.BETWEEN) {
                    if (this.store.indexOf(rec) === 0) {
                        values.push(filter.lowerBoundary);
                    }
                    values.push(filter.upperBoundary);
                } else if (filter.type === OpenLayers.Filter.Comparison.LESS_THAN) {
                    values.push(filter.value);
                }
            } else {
                values.push(filter);
            }
        }, this);
        if (this.thumbs) {
            for (var i=values.length-1; i>=0; --i) {
                this.setValue(i, values[i]);
            }
        }
        return values;
    },
    
    /** private: method[valuesToStore]
     *  Update the filter boundaries in the store with the slider values.
     */
    valuesToStore: function() {
        var values = this.getValues(),
            store = this.store;
        store.un("update", this.storeToValues, this);
        store.each(function(rec) {
            var filter = rec.get("filter"),
            value = values.shift();
            if (filter instanceof OpenLayers.Filter) {
                filter = filter.clone();
                if (filter.type === OpenLayers.Filter.Comparison.BETWEEN) {
                    filter.upperBoundary = value;
                } else if (filter.type === OpenLayers.Filter.Comparison.LESS_THAN) {
                    filter.value = value;
                }
                if (rec.get("filter").toString() !== filter.toString()) {
                    rec.set("filter", filter);
                }
            } else if (filter != value) {
                rec.set("filter", value);
            }
        }, this);
        store.on("update", this.storeToValues, this);
    }
    
});

/** api: xtype = gxp_classbreakslider */
Ext.reg('gxp_classbreakslider', gxp.slider.ClassBreakSlider);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires util.js
 * @requires OpenLayers/Renderer/SVG.js
 * @requires OpenLayers/Renderer/VML.js
 * @requires OpenLayers/Renderer/Canvas.js
 * @requires OpenLayers/Layer/Vector.js
 * @requires OpenLayers/BaseTypes/Date.js
 * @requires OpenLayers/BaseTypes/LonLat.js
 */

/** api: (define)
 *  module = gxp
 *  class = TimelinePanel
 *  base_link = `Ext.Panel <http://extjs.com/deploy/dev/docs/?class=Ext.Panel>`_
 */
Ext.namespace("gxp");

// showBy does not allow offsets
Ext.override(Ext.Tip, {
    showBy: function(el, pos, offsets){
        if (Ext.isEmpty(pos)) {
            pos = this.defaultAlign;
        }
        var offsetX = offsets[0];
        var offsetY = offsets[1];
        if (pos.charAt(0) === 'b') {
            offsetY = -offsetY;
        }
        if (pos.charAt(0) === 'r' || pos.charAt(1) === 'r') {
            offsetX = -offsetX;
        }
        if (pos.charAt(0) === 'c') {
            offsetX = 0;
            offsetY = 0;
        }
        if (pos.charAt(0) === 'l' || pos.charAt(0) === 'r') {
            offsetY = 0;
        }
        if(!this.rendered){
            this.render(Ext.getBody());
        }
        var position = this.el.getAlignToXY(el, pos || this.defaultAlign, [offsetX, offsetY]);
        if (document.body.scrollTop > 0 && document.body.scrollTop > el.getTop()) {
            position[1] += (el.getTop() - document.body.scrollTop);
        }
        if (!this.isVisible()) {
            this.showAt(position);
        } else {
            this.setPagePosition(position[0], position[1]);
        }
    }   
});

// TODO use from GeoExt eventually
GeoExt.FeatureTip = Ext.extend(Ext.Tip, {

    /** api: config[map]
     *  ``OpenLayers.Map``
     */
    map: null,

    /** api: config[location]
     *  ``OpenLayers.Feature.Vector``
     */
    location: null,

    /** api: config[shouldBeVisible]
     *  ``Function``
     *  Optional function to run to determine if the FeatureTip
     *  should be visible, this can e.g. be used to add another
     *  dimension such as time.
     */
    shouldBeVisible: null,

    /** private: method[initComponent]
     *  Initializes the feature tip.
     */
    initComponent: function() {
        var centroid = this.location.geometry.getCentroid();
        this.location = new OpenLayers.LonLat(centroid.x, centroid.y);
        this.map.events.on({
            "move" : this.show,
            scope : this
        });
        GeoExt.FeatureTip.superclass.initComponent.call(this);
    },

    /** private: method[beforeDestroy]
     *  Cleanup events before destroying the feature tip.
     */
    beforeDestroy: function() {
        for (var key in this.youtubePlayers) {
            this.youtubePlayers[key].destroy();
            delete this.youtubePlayers[key]; 
        }
        this.map.events.un({
            "move" : this.show,
            scope : this
        });
        GeoExt.FeatureTip.superclass.beforeDestroy.call(this);
    },

    /** private: method[getPosition]
     *  Get the position of the feature in pixel space.
     *
     *  :returns: ``Array`` The position of the feature in pixel space or
     *  null if the feature is not visible in the map.
     */
    getPosition: function() {
        if (this.map.getExtent().containsLonLat(this.location)) {
            var locationPx = this.map.getPixelFromLonLat(this.location),
                mapBox = Ext.fly(this.map.div).getBox(true),
                top = locationPx.y + mapBox.y,
               left = locationPx.x + mapBox.x;
            return [left, top];
        } else {
            return null;
        }
    },

    /** api: method[show]
     *  Show the feature tip.
     */
    show: function() {
        var position = this.getPosition();
        if (position !== null && (this.shouldBeVisible === null || this.shouldBeVisible.call(this))) {
            if (!this.isVisible()) {
                this.showAt(position);
            } else {
                this.setPagePosition(position[0], position[1]);
            }
        } else {
            this.hide();
        }
    }

});

// http://code.google.com/p/simile-widgets/issues/detail?id=3
window.Timeline && window.SimileAjax && (function() {
    SimileAjax.History.enabled = false;

    Timeline._Band.prototype._onDblClick = Ext.emptyFn;

    Timeline.DefaultEventSource.prototype.remove = function(id) {
        this._events.remove(id);
    };
    SimileAjax.EventIndex.prototype.remove = function(id) {
        var evt = this._idToEvent[id];
        this._events.remove(evt);
        delete this._idToEvent[id];
    };
    Timeline._Band.prototype.zoom = function(zoomIn, x, y, target) {
        if (!this._zoomSteps) {
            // zoom disabled
            return;
        }
        var center = this.getCenterVisibleDate();
        var netIntervalChange = this._ether.zoom(zoomIn);
        this._etherPainter.zoom(netIntervalChange);
        this.setCenterVisibleDate(center);
    };
})();

/** api: constructor
 *  .. class:: TimelinePanel(config)
 *   
 *      A panel for displaying a Similie Timeline.
 */
gxp.TimelinePanel = Ext.extend(Ext.Panel, {

    youtubePlayers: {},

    /** api: config[scrollInterval]
     *  ``Integer`` The Simile scroll event listener will only be handled
     *  upon every scrollInterval milliseconds. Defaults to 500.
     */
    scrollInterval: 500,

    /** private: property[annotationsStore]
     *  ``GeoExt.data.FeatureStore``
     */

    /** api: config[annotationConfig]
     *  ``Object`` Configuration object for the integration of annotations
     *  with the timeline.
     */
    annotationConfig: {
        timeAttr: 'start_time',
        endTimeAttr: 'end_time',
        filterAttr: 'in_timeline',
        mapFilterAttr: 'in_map'
    },
    
    /** api: config[viewer]
     *  ``gxp.Viewer``
     */

    /** api: config[playbackTool]
     *  ``gxp.plugins.Playback``
     */

    /** private: property[timeline]
     *  ``Timeline``
     */
    
    /** private: property[timelineContainer]
     *  ``Ext.Container``
     */
    
    /** private: property[eventSource]
     *  ``Object``
     *  Timeline event source.
     */

    /** api: property[layerLookup]
     *  ``Object``
     *  Mapping of store/layer names (e.g. "local/foo") to objects storing data
     *  related to layers.  The values of each member are objects with the 
     *  following properties:
     *
     *   * layer - {OpenLayers.Layer.Vector}
     *   * titleAttr - {String}
     *   * timeAttr - {String}
     *   * endTimeAttr - {String}
     *   * filterAttr - {String}
     *   * visible - {Boolean}
     *   * timeFilter - {OpenLayers.Filter}
     *   * sldFilter - {OpenLayers.Filter}
     *   * clientSideFilter - {OpenLayers.Filter}
     *  
     */
    
    layout: "border",

    /** private: method[initComponent]
     */
    initComponent: function() {

        // handler for clicking on an event in the timeline
        Timeline.OriginalEventPainter.prototype._showBubble = 
            this.handleEventClick.createDelegate(this);

        this.timelineContainer = new Ext.Container({
            region: "center"
        });

        this.eventSource = new Timeline.DefaultEventSource(0);

        this.items = [this.timelineContainer];

        // we are binding with viewer to get updates on new layers        
        if (this.initialConfig.viewer) {
            delete this.viewer;
            this.bindViewer(this.initialConfig.viewer);
        }

        // bind to the annotations store for notes
        if (this.initialConfig.annotationsStore) {
            this.bindAnnotationsStore(this.initialConfig.annotationsStore);
        }

        // we are binding with the playback tool to get updates on ranges
        // and current times
        if (this.initialConfig.playbackTool) {
            delete this.playbackTool;
            this.bindPlaybackTool(this.initialConfig.playbackTool);
        }

        if (this.ownerCt) {
            this.ownerCt.on("beforecollapse", function() {
                this._silentMapMove = true;
            }, this);
            this.ownerCt.on("beforeexpand", function() {
                delete this._silentMapMove;
            }, this);
            this.ownerCt.on("afterlayout", function() {
                delete this._silent;
            }, this);
        }

        gxp.TimelinePanel.superclass.initComponent.call(this); 
    },

    /**
     * private: method[handleEventClick]
     *  :arg x: ``Integer``
     *  :arg y: ``Integer``
     *  :arg evt: ``Object``
     *  
     *  Handler for when an event in the timeline gets clicked. Show a popup
     *  for a feature and the feature editor for a note/annotation.
     */
    handleEventClick: function(x, y, evt) {
        this.fireEvent("click", evt.getProperty('fid'));
    },

    /**
     * private: method[bindAnnotationsStore]
     *  :arg store: ``GeoExt.data.FeatureStore``
     *  
     *  Bind with a feature store to have notes show up in the timeline.
     */
    bindAnnotationsStore: function(store) {
        this.annotationsStore = store;
        store.on('load', function(store, rs, options) {
            var key = 'annotations';
            this.layerLookup[key] = Ext.apply({
                titleAttr: 'title',
                icon: Timeline.urlPrefix + "/images/note.png",
                layer: store.layer,
                visible: true
            }, this.annotationConfig);
            var features = [];
            store.each(function(record) {
                features.push(record.getFeature());
            });
            this.addFeatures(key, features);
            if (rs.length > 0) {
                this.ownerCt.expand();
            }
            this.showAnnotations();
        }, this, {single: true});
        store.on('write', this.onSave, this);
    },

    unbindAnnotationsStore: function() {
        if (this.annotationsStore) {
            this.annotationsStore.un('write', this.onSave, this);
        }
    },

    /** private: method[clearEventsForFid]
     *  :arg key: ``String``
     *  :arg fid:  ``String``
     *
     *  Clear the events from the timeline for a certain feature.
     */
    clearEventsForFid: function(key, fid) {
        var iterator = this.eventSource.getAllEventIterator();
        var eventIds = [];
        while (iterator.hasNext()) {
            var evt = iterator.next();
            if (evt.getProperty('key') === key && evt.getProperty('fid') === fid) {
                eventIds.push(evt.getID());
            }
        }   
        for (var i=0, len=eventIds.length; i<len; ++i) {
            this.eventSource.remove(eventIds[i]);
        }
        this.timeline && this.timeline.layout();
    },

    onSave: function(store, action, data) {
        var key = 'annotations';
        var features = [];
        for (var i=0, ii=data.length; i<ii; i++) {
            var feature = data[i].feature;
            features.push(feature);
            var fid = feature.fid;
            this.clearEventsForFid(key, fid);
            if (this.tooltips && this.tooltips[fid]) {
                this.tooltips[fid].destroy();
                this.tooltips[fid] = null;
            }
        }
        if (action !== Ext.data.Api.actions.destroy) {
            this.addFeatures(key, features);
        }
        this.showAnnotations();
    },

    /**
     * private: method[bindPlaybackTool]
     *  :arg playbackTool: ``gxp.plugins.Playback``
     *
     *  Bind with the playback tool so we get updates on when we have to move
     *  the timeline and when we have to change the range.
     */
    bindPlaybackTool: function(playbackTool) {
        this.playbackTool = playbackTool;
        this.playbackTool.on("timechange", this.onTimeChange, this);
        this.playbackTool.on("rangemodified", this.onRangeModify, this);
    },

    /**
     * private: method[unbindPlaybackTool]
     *
     *  Unbind with the playback tool
     */
    unbindPlaybackTool: function() {
        if (this.playbackTool) {
            this.playbackTool.un("timechange", this.onTimeChange, this);
            this.playbackTool.un("rangemodified", this.onRangeModify, this);
            this.playbackTool = null;
        }
    },

    /**
     * private: method[onTimeChange]
     *  :arg toolbar: ``gxp.plugin.PlaybackToolbar``
     *  :arg currentValue: ``Number``
     *
     *  Listener for when the playback tool fires timechange.
     */
    onTimeChange: function(toolbar, currentValue) {
        this._silent = true;
        this._ignoreTimeChange !== true && this.setCenterDate(currentValue);
        delete this._silent;
    },

    /** private: method[onRangeModify]
     *  :arg toolbar: ``gxp.plugin.PlaybackToolbar``
     *  :arg range: ``Array(Date)``
     *
     *  Listener for when the playback tool fires rangemodified
     */
    onRangeModify: function(toolbar, range) {
        this._silent = true;
        this.setRange(range);
        delete this._silent;
    },

    /** private: method[createTimeline]
     *  :arg range:  ``Array``
     *
     *  Create the Simile timeline object.
     */
    createTimeline: function(range) {
        if (!this.rendered || (this.timelineContainer.el.getSize().width === 0 && this.timelineContainer.el.getSize().height === 0)) {
            return;
        }
        var theme = Timeline.ClassicTheme.create();
        var span = range[1] - range[0];
        var years  = ((((span/1000)/60)/60)/24)/365;
        var intervalUnits = [];
        if (years >= 50) {
            intervalUnits.push(Timeline.DateTime.DECADE);
            intervalUnits.push(Timeline.DateTime.CENTURY);
        } else {
            intervalUnits.push(Timeline.DateTime.YEAR);
            intervalUnits.push(Timeline.DateTime.DECADE);
        }
        var d = new Date(range[0] + span/2);
        var bandInfos = [
            Timeline.createBandInfo({
                width: "80%", 
                intervalUnit: intervalUnits[0], 
                intervalPixels: 200,
                eventSource: this.eventSource,
                date: d,
                theme: theme,
                layout: "original",
                zoomIndex: 7,
                zoomSteps: [
                    {pixelsPerInterval: 25,  unit: intervalUnits[0]},
                    {pixelsPerInterval: 50,  unit: intervalUnits[0]},
                    {pixelsPerInterval: 75,  unit: intervalUnits[0]},
                    {pixelsPerInterval: 100,  unit: intervalUnits[0]},
                    {pixelsPerInterval: 125,  unit: intervalUnits[0]},
                    {pixelsPerInterval: 150,  unit: intervalUnits[0]},
                    {pixelsPerInterval: 175,  unit: intervalUnits[0]},
                    {pixelsPerInterval: 200,  unit: intervalUnits[0]},
                    {pixelsPerInterval: 225,  unit: intervalUnits[0]},
                    {pixelsPerInterval: 250,  unit: intervalUnits[0]},
                    {pixelsPerInterval: 275,  unit: intervalUnits[0]},
                    {pixelsPerInterval: 300,  unit: intervalUnits[0]},
                    {pixelsPerInterval: 325,  unit: intervalUnits[0]},
                    {pixelsPerInterval: 350,  unit: intervalUnits[0]},
                    {pixelsPerInterval: 375,  unit: intervalUnits[0]}
                ]
            }),
            Timeline.createBandInfo({
                width: "20%", 
                intervalUnit: intervalUnits[1], 
                intervalPixels: 200,
                eventSource: this.eventSource,
                date: d,
                theme: theme,
                layout: "overview"
            })
        ];
        bandInfos[1].syncWith = 0;
        bandInfos[1].highlight = true;

        bandInfos[0].decorators = [
            new Timeline.PointHighlightDecorator({
                date: d,
                theme: theme
            })
        ];
        this.timeline = Timeline.create(
            this.timelineContainer.el.dom, 
            bandInfos, 
            Timeline.HORIZONTAL
        );
        // since the bands are linked we need to listen to one band only
        this._silent = true;
        this.timeline.getBand(0).addOnScrollListener(
            gxp.util.throttle(this.setPlaybackCenter.createDelegate(this), this.scrollInterval)
        );
        
    },

    /** private: method[setPlaybackCenter]
     *  :arg band:  ``Object``
     *
     *  When the timeline is moved, update the playback tool.
     */
    setPlaybackCenter: function(band) {
        var time = band.getCenterVisibleDate();
        if (this._silent !== true && this.playbackTool && this.playbackTool.playbackToolbar.playing !== true) {
            this._ignoreTimeChange = true;
            this.playbackTool.setTime(time);
            this.timeline.getBand(0)._decorators[0]._date = this.playbackTool.playbackToolbar.control.currentValue;
            this.timeline.getBand(0)._decorators[0].paint();
            delete this._ignoreTimeChange;
            this.showAnnotations();
        }
    },
    
    /** private: method[bindViewer]
     *  :arg viewer: ``gxp.Viewer``
     *
     *  Bind the timeline with the viewer, so we get updates on layer changes.
     */
    bindViewer: function(viewer) {
        if (this.viewer) {
            this.unbindViewer();
        }
        this.viewer = viewer;
        if (!this.layerLookup) {
            this.layerLookup = {};
        }
    },
    
    /** private: method[unbindViewer]
     *
     *  Unbind this timeline from the current viewer.
     */
    unbindViewer: function() {
        delete this.viewer;
        delete this.layerLookup;
    },

    /** private: method[onLayout]
     *
     *  Fired by Ext, create the timeline.
     */
    onLayout: function() {
        gxp.TimelinePanel.superclass.onLayout.call(this, arguments);
        if (!this.timeline) {
            if (this.playbackTool && this.playbackTool.playbackToolbar) {
                this.setRange(this.playbackTool.playbackToolbar.control.animationRange);
                this.setCenterDate(this.playbackTool.playbackToolbar.control.currentValue);
            }
        }
    },

    /** private: method[setRange]
     *  :arg range: ``Array``
     *
     *  Set the range for the bands of this timeline.
     */
    setRange: function(range) {
        this.originalRange = range;
        if (!this.timeline) {
            this.createTimeline(range);
        }
        // if we were not rendered, the above will not have created the timeline
        if (this.timeline) {
            var firstBand = this.timeline.getBand(0);
            firstBand.setMinVisibleDate(range[0]);
            firstBand.setMaxVisibleDate(range[1]);
            var secondBand = this.timeline.getBand(1);
            secondBand.getEtherPainter().setHighlight(range[0], range[1]);
        }
    },

    buildHTML: function(record) {
        var content = record.get('content');
        var start = content ? content.indexOf('[youtube=') : -1;
        if (start !== -1) {
            var header = content.substr(0, start);
            var end = content.indexOf(']', start);
            var footer  = content.substr(end+1);
            var url = content.substr(start+9, end-9);
            var params = OpenLayers.Util.getParameters(url);
            var width = params.w || 250;
            var height = params.h || 250;
            var v = params.v;
            if (v === undefined) {
                v = url.substr(url.lastIndexOf('/')+1, (url.indexOf('?') !== -1 ? (url.indexOf('?') - (url.lastIndexOf('/')+1)) : undefined));
            }
            url = 'http://www.youtube.com/embed/' + v;
            var fid = record.getFeature().fid;
            var id = 'player_' + fid;
            return header + '<br/>' + '<iframe id="' + id + 
                '" type="text/html" width="' + width + '" height="' + 
                height + '" ' + 'src="' + url + '?enablejsapi=1&origin=' + 
                window.location.origin + '" frameborder="0"></iframe>' + 
                '<br/>' + footer;
        } else {
            return content;
        }
    },

    /** private: method[displayTooltip]
     *  :arg record: ``GeoExt.data.FeatureRecord``
     *
     *  Create and show the tooltip for a record.
     */
    displayTooltip: function(record) {
        var hasGeometry = (record.getFeature().geometry !== null);
        if (!this.tooltips) {
            this.tooltips = {};
        }
        var fid = record.getFeature().fid;
        var content = record.get('content') || '';
        var youtubeContent = content.indexOf('[youtube=') !== -1;
        var listeners = {
            'hide': function(cmp) {
                if (youtubeContent === true) {
                    this.youtubePlayers[fid].stopVideo();
                }
            },
            'show': function(cmp) {
                if (youtubeContent === true) {
                    if (this.youtubePlayers[fid]._ready && 
                        this.playbackTool.playbackToolbar.playing) {
                            this.youtubePlayers[fid].playVideo();
                    }
                }
            },
            'afterrender': function() {
                if (youtubeContent === true) {
                    if (!this.youtubePlayers[fid]) {
                        var me = this;
                        // stop immediately, if we wait for PLAYING we might be too late already
                        if (me.playbackTool.playbackToolbar.playing) {
                            me.playbackTool.playbackToolbar._weStopped = true;
                            window.setTimeout(function() { me.playbackTool.playbackToolbar.control.stop(); }, 0);
                        }
                        var id = 'player_' + fid;
                        this.youtubePlayers[fid] = new YT.Player(id, {
                            events: {
                                'onReady': function(evt) {
                                    evt.target._ready = true;
                                    if (me.playbackTool.playbackToolbar.playing || 
                                        me.playbackTool.playbackToolbar._weStopped) {
                                            evt.target.playVideo();
                                    }
                                },
                                'onStateChange': function(evt) {
                                    if (evt.data === YT.PlayerState.PLAYING) {
                                        if (!me.playbackTool.playbackToolbar._weStopped && 
                                            me.playbackTool.playbackToolbar.playing) {
                                                me.playbackTool.playbackToolbar._weStopped = true;
                                                me.playbackTool.playbackToolbar.control.stop();
                                        }
                                    } else if (evt.data == YT.PlayerState.ENDED) {
                                        if (me.playbackTool.playbackToolbar._weStopped) {
                                            me.playbackTool.playbackToolbar.control.play();
                                            delete me.playbackTool.playbackToolbar._weStopped;
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
            },
            scope: this
        };
        if (!this.tooltips[fid]) {
            if (!hasGeometry || (hasGeometry && record.get('appearance') !== 'geom' && !Ext.isEmpty(record.get('appearance')))) {
                this.tooltips[fid] = new Ext.Tip({
                    cls: 'gxp-annotations-tip',
                    maxWidth: 500,
                    bodyCssClass: 'gxp-annotations-tip-body',
                    listeners: listeners,
                    title: record.get("title"),
                    html: this.buildHTML(record)
                });
            } else {
                this.tooltips[fid] = new GeoExt.FeatureTip({
                    map: this.viewer.mapPanel.map,
                    location: record.getFeature(),
                    shouldBeVisible: function() {
                        return (this._inTimeRange === true);
                    },
                    cls: 'gxp-annotations-tip',
                    bodyCssClass: 'gxp-annotations-tip-body',
                    maxWidth: 500,
                    title: record.get("title"),
                    listeners: listeners,
                    html: this.buildHTML(record)
                });
            }
        }
        var tooltip = this.tooltips[fid];
        tooltip._inTimeRange = true;
        if (!hasGeometry || (hasGeometry && record.get('appearance') !== 'geom' && !Ext.isEmpty(record.get('appearance')))) {
            // http://www.sencha.com/forum/showthread.php?101593-OPEN-1054-Tooltip-anchoring-problem
            tooltip.showBy(this.viewer.mapPanel.body, record.get("appearance"), [10, 10]);
            tooltip.showBy(this.viewer.mapPanel.body, record.get("appearance"), [10, 10]);
        } else {
            if (!tooltip.isVisible()) {
                tooltip.show();
            }
        }
        if (hasGeometry) {
            this.annotationsLayer.addFeatures([record.getFeature()]);
        }
    },

    /** private: method[hideTooltip]
     *  :arg record: ``GeoExt.data.FeatureRecord``
     *
     *  Hide the tooltip associated with the record.
     */
    hideTooltip: function(record) {
        var fid = record.getFeature().fid;
        var hasGeometry = (record.getFeature().geometry !== null);
        if (this.tooltips && this.tooltips[fid]) {
            this.tooltips[fid]._inTimeRange = false;
            this.tooltips[fid].hide();
            if (hasGeometry) {
                this.annotationsLayer.removeFeatures([record.getFeature()]);
            }
        }
    },

    /** private: method[showAnnotations]
     *
     *  Show annotations in the map.
     */
    showAnnotations: function() {
        if (!this.annotationsLayer) {
            this.annotationsLayer = new OpenLayers.Layer.Vector(null, {
                displayInLayerSwitcher: false
            });
            this.viewer && this.viewer.mapPanel.map.addLayer(this.annotationsLayer);
        }
        var d = new Date(this.playbackTool.playbackToolbar.control.currentValue);
        var compare = d.getTime()/1000;
        if (this.annotationsStore) {
            this.annotationsStore.each(function(record) {
                var mapFilterAttr = this.annotationConfig.mapFilterAttr;
                if (Ext.isBoolean(record.get(mapFilterAttr)) ? record.get(mapFilterAttr) : (record.get(mapFilterAttr) === "true")) {
                    var startTime = parseFloat(record.get(this.annotationConfig.timeAttr));
                    var endTime = record.get(this.annotationConfig.endTimeAttr);
                    var ranged = (endTime != startTime);
                    if (endTime == "" || endTime == null) {
                        endTime = this.playbackTool.playbackToolbar.control.animationRange[1];
                    }
                    if (ranged === true) {
                        if (compare <= parseFloat(endTime) && compare >= startTime) {
                            this.displayTooltip(record);
                        } else {
                            this.hideTooltip(record);
                        }
                    } else {
                        var diff = (startTime-compare);
                        if (diff === 0) {
                            this.displayTooltip(record);
                        } else {
                            this.hideTooltip(record);
                        }
                    }
                }
            }, this);
        }
    },

    /** private: method[setCenterDate]
     *  :arg time: ``Date``
     *      
     *  Set the center datetime on the bands of this timeline.
     */
    setCenterDate: function(time) {
        if (!(time instanceof Date)) {
            time = new Date(time);
        }
        if (this.timeline) {
            this.timeline.getBand(0)._decorators[0]._date = time;
            this.timeline.getBand(0)._decorators[0].paint();
            this.timeline.getBand(0).setCenterVisibleDate(time);
        }
        this.showAnnotations();
    },

    /** private: method[addFeatures]
     *  :arg key: ``String``
     *  :arg features: ``Array``
     *
     *  Add some features to the timeline.
     */    
    addFeatures: function(key, features) {
        var hasFeature = function(fid) {
            var iterator = this.eventSource.getAllEventIterator();
            while (iterator.hasNext()) {
                var evt = iterator.next();
                if (evt.getProperty('key') === key && evt.getProperty('fid') === fid) {
                    return true;
                }
            }
            return false;
        };
        var isDuration = false;
        var titleAttr = this.layerLookup[key].titleAttr;
        var timeAttr = this.layerLookup[key].timeAttr;
        var endTimeAttr = this.layerLookup[key].endTimeAttr;
        var filterAttr = this.layerLookup[key].filterAttr;
        if (endTimeAttr) {
            isDuration = true;
        }
        var num = features.length;
        var events = [];
        var attributes, str;
        for (var i=0; i<num; ++i) {
            // prevent duplicates
            if (hasFeature.call(this, features[i].fid) === false) {
                attributes = features[i].attributes;
                if (isDuration === false) {
                    events.push({
                        start: OpenLayers.Date.parse(attributes[timeAttr]),
                        title: attributes[titleAttr],
                        durationEvent: false,
                        key: key,
                        icon: this.layerLookup[key].icon,
                        fid: features[i].fid
                    });
                } else if (Ext.isBoolean(attributes[filterAttr]) ? attributes[filterAttr] : (attributes[filterAttr] === "true")) {
                    var start = attributes[timeAttr];
                    var end = attributes[endTimeAttr];
                    // end is optional
                    var durationEvent = (start != end);
                    if (!Ext.isEmpty(start)) {
                        start = parseFloat(start);
                        if (Ext.isNumber(start)) {
                            start = new Date(start*1000);
                        } else {
                            start = OpenLayers.Date.parse(start);
                        }
                    }
                    if (!Ext.isEmpty(end)) {
                        end = parseFloat(end);
                        if (Ext.isNumber(end)) {
                            end = new Date(end*1000);
                        } else {
                            end = OpenLayers.Date.parse(end);
                        }
                    }
                    if (durationEvent === false) {
                        end = undefined;
                    } else {
                        if (end == "" || end == null) {
                            // Simile does not deal with unlimited ranges, so let's
                            // take the range from the playback control
                            end = new Date(this.playbackTool.playbackToolbar.control.animationRange[1]);
                        }
                    }
                    if(start != null){
                        events.push({
                            start: start,
                            end: end,
                            icon: this.layerLookup[key].icon,
                            title: attributes[titleAttr],
                            durationEvent: durationEvent,
                            key: key,
                            fid: features[i].fid
                        });
                    }
                }
            }
        }
        var feed = {
            dateTimeFormat: "javascriptnative", //"iso8601",
            events: events
        };
        // do not use a real URL here, since this will mess up relative URLs
        this.eventSource.loadJSON(feed, "mapstory.org");
    },

    /** private: method[onResize]
     *  Private method called after the panel has been resized.
     */
    onResize: function() {
        gxp.TimelinePanel.superclass.onResize.apply(this, arguments);
        this.timeline && this.timeline.layout();
    },

    /** private: method[beforeDestroy]
     *  Cleanup.
     */
    beforeDestroy : function(){
        gxp.TimelinePanel.superclass.beforeDestroy.call(this);
        this.annotationsLayer = null;
        this.unbindViewer();
        this.unbindAnnotationsStore();
        this.unbindPlaybackTool();
        this.eventSource = null;
        if (this.timeline) {
            this.timeline.dispose();
            this.timeline = null;
        }
    }

});

/** api: xtype = gxp_timelinepanel */
Ext.reg("gxp_timelinepanel", gxp.TimelinePanel);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp.form
 *  class = CSWFilterField
 *  base_link = `Ext.form.CompositeField <http://extjs.com/deploy/dev/docs/?class=Ext.form.CompositeField>`_
 */
Ext.namespace("gxp.form");

/** api: constructor
 *  .. class:: CSWFilterField(config)
 *   
 *      A composite form field which uses a combobox to select values
 *      for a certain filter, and adds a button to the right of the combobox
 *      to remove the filter.
 */
gxp.form.CSWFilterField = Ext.extend(Ext.form.CompositeField, {

    /** i18n */
    clearTooltip: "Clear the filter for this category",
    emptyText: 'Select filter',    
    /* end i18n */

    /** api: config[property]
     *  ``String`` Optional, the PropertyName to use in the Filter
     */
    property: null,

    /** api: config[map]
     *  ``OpenLayers.Map``
     */
    map: null,

    /** api: config[type]
     *  ``String`` Optional type to use in the comparison filter.
     *  Defaults to '=='.
     */
    type: OpenLayers.Filter.Comparison.EQUAL_TO,

    /** api:config[name]
     *  ``String`` Name of the filter property.
     */
    name: null,

    /** api:config[comboFieldLabel]
     *  ``String`` fieldLabel to use for the combobox.
     */
    comboFieldLabel: null,

    /** api:config[comboStoreData]
     *  ``Array`` The data for the combo store.
     */
    comboStoreData: null,

    /** api:config[target]
     *  ``gxp.CatalogueSearchPanel`` The target on which to apply the filters.
     */
    target: null,

    getFilter: function() {
        if (this.property === 'BoundingBox') {
            return new OpenLayers.Filter.Spatial({
                type: OpenLayers.Filter.Spatial.BBOX,
                property: this.property,
                projection: "EPSG:4326",
                value: this.map.getExtent().transform(
                    this.map.getProjectionObject(),
                    new OpenLayers.Projection("EPSG:4326")
                )
            });
        } else { 
            return new OpenLayers.Filter.Comparison({
                type: this.type,
                property: this.property,
                value: this.combo.getValue()
            });
        } 
    },

    /** private: method[initComponent]
     *  Initializes the CSW filter field.
     */
    initComponent: function() {
        this.items = [{
            ref: 'combo',
            xtype: "combo",
            fieldLabel: this.comboFieldLabel,
            store: new Ext.data.ArrayStore({
                fields: ['id', 'value'],
                data: this.comboStoreData
            }),
            displayField: 'value',
            valueField: 'id',
            mode: 'local',
            listeners: {
                'select': function(cmb, record) {
                    if (this.filter) {
                        this.target.removeFilter(this.filter);
                    }
                    this.filter = this.getFilter();
                    this.target.addFilter(this.filter);
                    return false;
                },
                scope: this
            },
            emptyText: this.emptyText,
            triggerAction: 'all'
        }, {
            xtype: 'button',
            iconCls: 'gxp-icon-removelayers',
            tooltip: this.clearTooltip,
            handler: function(btn) {
                this.target.removeFilter(this.filter);
                this.hide();
            },
            scope: this
        }];
        this.hidden = true;
        gxp.form.CSWFilterField.superclass.initComponent.apply(this, arguments);
    },

    /** private: method[destroy]
     *  Clean up.
     */
    destroy: function() {
        this.filter = null;
        this.target = null;
        this.map = null;
        gxp.form.CSWFilterField.superclass.destroy.call(this);
    }

});

/** api: xtype = gxp_cswfilterfield */
Ext.reg('gxp_cswfilterfield', gxp.form.CSWFilterField);

/**
 * Copyright (c) 2008-2012 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires widgets/form/CSWFilterField.js
 */

/** api: (define)
 *  module = gxp
 *  class = CatalogueSearchPanel
 *  base_link = `Ext.Panel <http://extjs.com/deploy/dev/docs/?class=Ext.Panel>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: CatalogueSearchPanel(config)
 *   
 *      Create a panel for searching a CS-W.
 */
gxp.CatalogueSearchPanel = Ext.extend(Ext.Panel, {

    /** private: property[border]
     *  ``Boolean``
     */
    border: false,

    /** api: config[maxRecords]
     *  ``Integer`` The maximum number of records to retrieve in one batch.
     *  Defaults to 10.
     */
    maxRecords: 10,

    /** api: config[map]
     *  ``OpenLayers.Map``
     */
    map: null,

    /** api: config[selectedSource]
     *  ``String`` The key of the catalogue source to use on startup.
     */
    selectedSource: null,

    /** api: config[sources]
     *  ``Object`` The set of catalogue sources for which the user will be
     *  able to query on.
     */
    sources: null,

    /* i18n */
    searchFieldEmptyText: "Search",
    searchButtonText: "Search",
    addTooltip: "Create filter",
    addMapTooltip: "Add to map",
    advancedTitle: "Advanced",
    datatypeLabel: "Data type",
    extentLabel: "Spatial extent",
    categoryLabel: "Category",
    datasourceLabel: "Data source",
    filterLabel: "Filter search by",
    removeSourceTooltip: "Switch back to original source",
    /* end i18n */

    /** private: method[initComponent]
     *  Initializes the catalogue search panel.
     */
    initComponent: function() {
        var me = this;
        this.addEvents(
            /** api: event[addlayer]
             *  Fires when a layer needs to be added to the map.
             *
             *  Listener arguments:
             *
             *  * :class:`gxp.CatalogueSearchPanel` this component
             *  * ``String`` the key of the catalogue source to use
             *  * ``Object`` config object for the WMS layer to create.
             */
            "addlayer"
        );
        this.filters = [];
        var sourceComboData = [];
        for (var key in this.sources) {
            sourceComboData.push([key, this.sources[key].title]);
        }
        if (sourceComboData.length >= 1) {
            this.selectedSource = sourceComboData[0][0];
        }
        var filterOptions = [['datatype', 'data type'], ['extent', 'spatial extent'], ['category', 'category']];
        if (sourceComboData.length > 1) {
            filterOptions.push(['csw', 'data source']);
        }
        this.sources[this.selectedSource].store.on('loadexception', function(proxy, o, response, e) {
            if (response.success()) {
                Ext.Msg.show({
                    title: e.message,
                    msg: gxp.util.getOGCExceptionText(e.arg.exceptionReport),
                    icon: Ext.MessageBox.ERROR,
                    buttons: Ext.MessageBox.OK
                });
            }
        });
        this.items = [{
            xtype: 'form',
            border: false,
            ref: 'form',
            hideLabels: true,
            autoHeight: true,
            style: "margin-left: 5px; margin-right: 5px; margin-bottom: 5px; margin-top: 5px",
            items: [{
                xtype: "compositefield",
                items: [{
                    xtype: "textfield",
                    emptyText: this.searchFieldEmptyText,
                    ref: "../../search",
                    name: "search",
                    listeners: {
                         specialkey: function(field, e) {
                             if (e.getKey() == e.ENTER) {
                                 this.performQuery();
                             }
                         },
                         scope: this
                    },
                    width: 250
                }, {
                    xtype: "button",
                    text: this.searchButtonText,
                    handler: this.performQuery,
                    scope: this
                }]
            }, {
                xtype: "fieldset",
                collapsible: true,
                collapsed: true,
                hideLabels: false,
                hidden: true,
                title: this.advancedTitle,
                items: [{
                    xtype: 'gxp_cswfilterfield',
                    name: 'datatype',
                    property: 'apiso:Type',
                    comboFieldLabel: this.datatypeLabel,
                    comboStoreData: [
                        ['dataset', 'Dataset'],
                        ['datasetcollection', 'Dataset collection'],
                        ['application', 'Application'],
                        ['service', 'Service']
                    ],
                    target: this
                }, {
                    xtype: 'gxp_cswfilterfield',
                    name: 'extent',
                    property: 'BoundingBox',
                    map: this.map,
                    comboFieldLabel: this.extentLabel,
                    comboStoreData: [
                        ['map', 'spatial extent of the map']
                    ],
                    target: this
                }, {
                    xtype: 'gxp_cswfilterfield',
                    name: 'category',
                    property: 'apiso:TopicCategory',
                    comboFieldLabel: this.categoryLabel,
                    comboStoreData: [
                        ['farming', 'Farming'],
                        ['biota', 'Biota'],
                        ['boundaries', 'Boundaries'],
                        ['climatologyMeteorologyAtmosphere', 'Climatology/Meteorology/Atmosphere'],
                        ['economy', 'Economy'],
                        ['elevation', 'Elevation'],
                        ['environment', 'Environment'],
                        ['geoscientificinformation', 'Geoscientific Information'],
                        ['health', 'Health'],
                        ['imageryBaseMapsEarthCover', 'Imagery/Base Maps/Earth Cover'],
                        ['intelligenceMilitary', 'Intelligence/Military'],
                        ['inlandWaters', 'Inland Waters'],
                        ['location', 'Location'],
                        ['oceans', 'Oceans'],
                        ['planningCadastre', 'Planning Cadastre'],
                        ['society', 'Society'],
                        ['structure', 'Structure'],
                        ['transportation', 'Transportation'],
                        ['utilitiesCommunications', 'Utilities/Communications']
                    ],
                    target: this
                }, {
                    xtype: "compositefield",
                    id: "csw",
                    ref: "../../cswCompositeField",
                    hidden: true,
                    items: [{
                        xtype: "combo",
                        ref: "../../../sourceCombo",
                        fieldLabel: this.datasourceLabel,
                        store: new Ext.data.ArrayStore({
                            fields: ['id', 'value'],
                            data: sourceComboData
                        }),
                        displayField: 'value',
                        valueField: 'id',
                        mode: 'local',
                        listeners: {
                            'select': function(cmb, record) {
                                this.setSource(cmb.getValue());
                            },
                            'render': function() { 
                                this.sourceCombo.setValue(this.selectedSource);
                            },
                            scope: this
                        },
                        triggerAction: 'all'
                    }, {
                        xtype: 'button',
                        iconCls: 'gxp-icon-removelayers',
                        tooltip: this.removeSourceTooltip,
                        handler: function(btn) {
                            this.setSource(this.initialConfig.selectedSource);
                            this.sourceCombo.setValue(this.initialConfig.selectedSource);
                            this.cswCompositeField.hide();
                        },
                        scope: this
                    }]
                }, {
                    xtype: 'compositefield',
                    items: [{
                        xtype: "combo",
                        fieldLabel: this.filterLabel,
                        store: new Ext.data.ArrayStore({
                            fields: ['id', 'value'],
                            data: filterOptions
                        }),
                        displayField: 'value',
                        valueField: 'id',
                        mode: 'local',
                        triggerAction: 'all'
                    }, {
                        xtype: 'button',
                        iconCls: 'gxp-icon-addlayers',
                        tooltip: this.addTooltip,
                        handler: function(btn) {
                            btn.ownerCt.items.each(function(item) {
                                if (item.getXType() === "combo") {
                                    var id = item.getValue();
                                    item.clearValue();
                                    var field = this.form.getForm().findField(id);
                                    if (field) {
                                        field.show();
                                    }
                                }
                            }, this);
                        },
                        scope: this
                    }]
                }]
            }, {
                xtype: "grid",
                width: '100%', 
                anchor: '99%',
                viewConfig: {
                    scrollOffset: 0,
                    forceFit: true
                },
                border: false,
                ref: "../grid",
                bbar: new Ext.PagingToolbar({
                    listeners: {
                        'beforechange': function(tb, params) {
                            var delta = me.sources[me.selectedSource].getPagingStart();
                            if (params.startPosition) {
                                params.startPosition += delta;
                            }
                        }
                    },
                    /* override to support having a different value than 0 for the start */
                    onLoad : function(store, r, o) {
                        var delta = me.sources[me.selectedSource].getPagingStart();
                        if(!this.rendered){
                            this.dsLoaded = [store, r, o];
                            return;
                        }
                        var p = this.getParams();
                        this.cursor = (o.params && o.params[p.start]) ? o.params[p.start]-delta : 0;
                        var d = this.getPageData(), ap = d.activePage, ps = d.pages;
                        this.afterTextItem.setText(String.format(this.afterPageText, d.pages));
                        this.inputItem.setValue(ap);
                        this.first.setDisabled(ap == 1);
                        this.prev.setDisabled(ap == 1);
                        this.next.setDisabled(ap == ps);
                        this.last.setDisabled(ap == ps);
                        this.refresh.enable();
                        this.updateInfo();
                        this.fireEvent('change', this, d);
                    },
                    paramNames: this.sources[this.selectedSource].getPagingParamNames(),
                    store: this.sources[this.selectedSource].store,
                    pageSize: this.maxRecords
                }),
                loadMask: true,
                hideHeaders: true,
                store: this.sources[this.selectedSource].store,
                columns: [{
                    id: 'title',
                    xtype: "templatecolumn", 
                    tpl: new Ext.XTemplate('<b>{title}</b><br/>{abstract}'), 
                    sortable: true
                }, {
                    xtype: "actioncolumn",
                    width: 30,
                    items: [{
                        getClass: function(v, meta, rec) {
                            if (this.findWMS(rec.get("URI")) !== false || 
                                this.findWMS(rec.get("references")) !== false) {
                                    return "gxp-icon-addlayers";
                            }
                        },
                        tooltip: this.addMapTooltip,
                        handler: function(grid, rowIndex, colIndex) {
                            var rec = this.grid.store.getAt(rowIndex);
                            this.addLayer(rec);
                        },
                        scope: this
                    }]
                }],
                autoExpandColumn: 'title',
                autoHeight: true
            }] 
        }];
        gxp.CatalogueSearchPanel.superclass.initComponent.apply(this, arguments);
    },

    /** private: method[destroy]
     *  Clean up.
     */
    destroy: function() {
        this.sources = null;
        this.map = null;
        gxp.CatalogueSearchPanel.superclass.destroy.call(this);
    },

    /** private: method[setSource]
     *  :arg key: ``String`` The key of the source to search on.
     *
     *  Change the CS-W this panel will search on.
     */
    setSource: function(key) {
        this.selectedSource = key;
        var store = this.sources[key].store;
        this.grid.reconfigure(store, this.grid.getColumnModel());
        this.grid.getBottomToolbar().bindStore(store);
    },

    /** private: method[performQuery]
     *  Query the Catalogue and show the results.
     */
    performQuery: function() {
        var plugin = this.sources[this.selectedSource];
        plugin.filter({
            queryString: this.search.getValue(),
            limit: this.maxRecords,
            filters: this.filters
        });
    },

    /** private: method[addFilter]
     *  :arg filter: ``OpenLayers.Filter`` The filter to add.
     *
     *  Add the filter to the list of filters to use in the CS-W query.
     */
    addFilter: function(filter) {
        this.filters.push(filter);
    },

    /** private: method[removeFilter]
     *  :arg filter: ``OpenLayers.Filter`` The filter to remove.
     *
     *  Remove the filter from the list of filters to use in the CS-W query.
     */
    removeFilter: function(filter) {
        this.filters.remove(filter);
    },

    /** private: method[findWMS]
     *  :arg links: ``Array`` The links to search for a GetMap URL.
     *  :returns: ``Object`` A config object with the url and the layer name.
     *
     *  Look up the WMS url in a set of hyperlinks.
     *  TODO: find a more solid way to do this, without using GetCapabilities
     *  preferably.
     */
    findWMS: function(links) {
        var protocols = [
            'OGC:WMS-1.1.1-HTTP-GET-MAP',
            'OGC:WMS'
        ];
        var url = null, name = null, i, ii, link;
        // search for a protocol that matches WMS
        for (i=0, ii=links.length; i<ii; ++i) {
            link = links[i];
            if (link.protocol && protocols.indexOf(link.protocol.toUpperCase()) !== -1 && link.value && link.name) {
                url = link.value;
                name = link.name;
                break;
            }
        }
        // if not found by protocol, try by inspecting the url
        if (url === null) {
            for (i=0, ii=links.length; i<ii; ++i) {
                link = links[i];
                var value = link.value ? link.value : link;
                if (value.toLowerCase().indexOf('service=wms') > 0) {
                    var obj = OpenLayers.Util.createUrlObject(value);
                    url = obj.protocol + "//" + obj.host + ":" + obj.port + obj.pathname;
                    name = obj.args.layers;
                    break;
                }
            }
        }
        if (url !== null && name !== null) {
            return {
                url: url,
                name: name
            };
        } else {
            return false;
        }
    },

    /** private: method[addLayer]
     *  :arg record: ``GeoExt.data.LayerRecord`` The layer record to add.
     *      
     *  Add a WMS layer coming from a catalogue search.
     */
    addLayer: function(record) {
        var uri = record.get("URI");
        var bounds = record.get("bounds");
        var bLeft = bounds.left,
            bRight = bounds.right,
            bBottom = bounds.bottom,
            bTop = bounds.top;
        var left = Math.min(bLeft, bRight),
            right = Math.max(bLeft, bRight),
            bottom = Math.min(bBottom, bTop),
            top = Math.max(bBottom, bTop);
        var wmsInfo = this.findWMS(uri);
        if (wmsInfo === false) {
            // fallback to dct:references
            var references = record.get("references");
            wmsInfo = this.findWMS(references);
        }
        if (wmsInfo !== false) {
            this.fireEvent("addlayer", this, this.selectedSource, Ext.apply({
                title: record.get('title')[0],
                bbox: [left, bottom, right, top],
                srs: "EPSG:4326",
                projection: record.get('projection')
            }, wmsInfo));
        }
    }

});

/** api: xtype = gxp_cataloguesearchpanel */
Ext.reg('gxp_cataloguesearchpanel', gxp.CatalogueSearchPanel);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires OpenLayers/Control/ScaleLine.js
 * @requires GeoExt/data/ScaleStore.js
 */

/** api: (define)
 *  module = gxp
 *  class = ScaleOverlay
 *  base_link = `Ext.Panel <http://dev.sencha.com/deploy/dev/docs/?class=Ext.Panel>`_
 */
Ext.namespace("gxp");

/** api: constructor
 *  .. class:: ScaleOverlay(config)
 *   
 *      Create a panel for showing a ScaleLine control and a combobox for 
 *      selecting the map scale.
 */
gxp.ScaleOverlay = Ext.extend(Ext.Panel, {
    
    /** api: config[map]
     *  ``OpenLayers.Map`` or :class:`GeoExt.MapPanel`
     *  The map for which to show the scale info.
     */
    map: null,

    /** i18n */
    zoomLevelText: "Zoom level",

    /** private: method[initComponent]
     *  Initialize the component.
     */
    initComponent: function() {
        gxp.ScaleOverlay.superclass.initComponent.call(this);
        this.cls = 'map-overlay';
        if(this.map) {
            if(this.map instanceof GeoExt.MapPanel) {
                this.map = this.map.map;
            }
            this.bind(this.map);
        }
        this.on("beforedestroy", this.unbind, this);        
    },
    
    /** private: method[addToMapPanel]
     *  :param panel: :class:`GeoExt.MapPanel`
     *  
     *  Called by a MapPanel if this component is one of the items in the panel.
     */
    addToMapPanel: function(panel) {
        this.on({
            afterrender: function() {
                this.bind(panel.map);
            },
            scope: this
        });
    },
    
    /** private: method[stopMouseEvents]
     *  :param e: ``Object``
     */
    stopMouseEvents: function(e) {
        e.stopEvent();
    },
    
    /** private: method[removeFromMapPanel]
     *  :param panel: :class:`GeoExt.MapPanel`
     *  
     *  Called by a MapPanel if this component is one of the items in the panel.
     */
    removeFromMapPanel: function(panel) {
        var el = this.getEl();
        el.un("mousedown", this.stopMouseEvents, this);
        el.un("click", this.stopMouseEvents, this);
        this.unbind();
    },

    /** private: method[addScaleLine]
     *  
     *  Create the scale line control and add it to the panel.
     */
    addScaleLine: function() {
        var scaleLinePanel = new Ext.BoxComponent({
            autoEl: {
                tag: "div",
                cls: "olControlScaleLine overlay-element overlay-scaleline"
            }
        });
        this.on("afterlayout", function(){
            scaleLinePanel.getEl().dom.style.position = 'relative';
            scaleLinePanel.getEl().dom.style.display = 'inline';

            this.getEl().on("click", this.stopMouseEvents, this);
            this.getEl().on("mousedown", this.stopMouseEvents, this);
        }, this);
        scaleLinePanel.on('render', function(){
            var scaleLine = new OpenLayers.Control.ScaleLine({
                geodesic: true,
                div: scaleLinePanel.getEl().dom
            });

            this.map.addControl(scaleLine);
            scaleLine.activate();
        }, this);
        this.add(scaleLinePanel);
    },

    /** private: method[handleZoomEnd]
     *
     * Set the correct value in the scale combo box.
     */
    handleZoomEnd: function() {
        var scale = this.zoomStore.queryBy(function(record) { 
            return this.map.getZoom() == record.data.level;
        }, this);
        if (scale.length > 0) {
            scale = scale.items[0];
            this.zoomSelector.setValue("1 : " + parseInt(scale.data.scale, 10));
        } else {
            if (!this.zoomSelector.rendered) {
                return;
            }
            this.zoomSelector.clearValue();
        }
    },

    /** private: method[addScaleCombo]
     *  
     *  Create the scale combo and add it to the panel.
     */
    addScaleCombo: function() {
        this.zoomStore = new GeoExt.data.ScaleStore({
            map: this.map
        });
        this.zoomSelector = new Ext.form.ComboBox({
            emptyText: this.zoomLevelText,
            tpl: '<tpl for="."><div class="x-combo-list-item">1 : {[parseInt(values.scale)]}</div></tpl>',
            editable: false,
            triggerAction: 'all',
            mode: 'local',
            store: this.zoomStore,
            width: 110
        });
        this.zoomSelector.on({
            click: this.stopMouseEvents,
            mousedown: this.stopMouseEvents,
            select: function(combo, record, index) {
                this.map.zoomTo(record.data.level);
            },
            scope: this
        });
        this.map.events.register('zoomend', this, this.handleZoomEnd);
        var zoomSelectorWrapper = new Ext.Panel({
            items: [this.zoomSelector],
            cls: 'overlay-element overlay-scalechooser',
            border: false
        });
        this.add(zoomSelectorWrapper);
    },

    /** private: method[bind]
     *  :param map: ``OpenLayers.Map``
     */
    bind: function(map) {
        this.map = map;
        this.addScaleLine();
        this.addScaleCombo();
        this.doLayout();
    },
    
    /** private: method[unbind]
     */
    unbind: function() {
        if(this.map && this.map.events) {
            this.map.events.unregister('zoomend', this, this.handleZoomEnd);
        }
        this.zoomStore = null;
        this.zoomSelector = null;
    }

});

/** api: xtype = gxp_scaleoverlay */
Ext.reg('gxp_scaleoverlay', gxp.ScaleOverlay);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = LayerSource
 *  base_link = `Ext.util.Observable <http://extjs.com/deploy/dev/docs/?class=Ext.util.Observable>`_
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: LayerSource(config)
 *
 *    Base class for layer sources to plug into a :class:`gxp.Viewer`. A source
 *    is created by adding it to the ``sources`` object of the viewer. Once
 *    there, the viewer will create layers from it by looking at objects in
 *    the ``layers`` array of its ``map`` config option, calling the source's
 *    ``createLayerRecord`` method.
 */   
gxp.plugins.LayerSource = Ext.extend(Ext.util.Observable, {
    
    /** api: property[store]
     *  ``GeoExt.data.LayerStore``
     */
    store: null,

    /** private: property[target]
     *  ``Object``
     *  The object that this plugin is plugged into.
     */
    
    /** api: property[lazy]
     *  ``Boolean``. true when the source is ready, but its store hasn't
     *  been loaded yet (i.e. lazy source). Read-only.
     */
    lazy: false,

    /** api: property[hidden]
     *  ``Boolean`` Set to true if you don't want this LayerSource to show
     *  up in the AddLayers dialog. Defaults to false.
     */
    hidden: false,
     
    /** api: property[title]
     *  ``String``
     *  A descriptive title for this layer source.
     */
    title: "",
    
    /** private: method[constructor]
     */
    constructor: function(config) {
        this.initialConfig = config;
        Ext.apply(this, config);
        
        this.addEvents(
            /** api: event[ready]
             *  Fires when the layer source is ready for action.
             */
            "ready",
            /** api: event[failure]
             *  Fires if the layer source fails to load.
             */
            "failure"
        );
        gxp.plugins.LayerSource.superclass.constructor.apply(this, arguments);
    },
    
    /** api: method[init]
     *  :arg target: ``Object`` The object initializing this plugin.
     *
     *  Calls :meth:`createStore` with a callback that fires the 'ready' event.
     */
    init: function(target) {
        this.target = target;
        this.createStore();
    },
    
    /** private: method[getMapProjection]
     *  :returns: ``OpenLayers.Projection``
     */
    getMapProjection: function() {
        var projConfig = this.target.mapPanel.map.projection;
        return this.target.mapPanel.map.getProjectionObject() ||
            (projConfig && new OpenLayers.Projection(projConfig)) ||
            new OpenLayers.Projection("EPSG:4326");
    },
    
    /** api: method[getProjection]
     *  :arg layerRecord: ``GeoExt.data.LayerRecord`` a record from this
     *      source's store
     *  :returns: ``OpenLayers.Projection`` A suitable projection for the
     *      ``layerRecord``. If the layer is available in the map projection,
     *      the map projection will be returned. Otherwise an equal projection,
     *      or null if none is available.
     *
     *  Get the projection that the source will use for the layer created in
     *  ``createLayerRecord``. If the layer is not available in a projection
     *  that fits the map projection, null will be returned.
     */
    getProjection: function(layerRecord) {
        // to be overridden by subclasses
        var layer = layerRecord.getLayer();
        var mapProj = this.getMapProjection();
        var proj = layer.projection ?
            layer.projection instanceof OpenLayers.Projection ?
                layer.projection :
                new OpenLayers.Projection(layer.projection) :
            mapProj;
        return proj.equals(mapProj) ? mapProj : null;
    },
    
    /** api: method[createStore]
     *
     *  Creates a store of layer records.  Fires "ready" when store is loaded.
     */
    createStore: function() {
        this.fireEvent("ready", this);
    },

    /** api: method[createLayerRecord]
     *  :arg config:  ``Object``  The application config for this layer.
     *  :returns: ``GeoExt.data.LayerRecord``
     *
     *  Create a layer record given the config.
     */
    createLayerRecord: function(config) {
    },

    /** api: method[getConfigForRecord]
     *  :arg record: :class:`GeoExt.data.LayerRecord`
     *  :returns: ``Object``
     *
     *  Create a config object that can be used to recreate the given record.
     */
    getConfigForRecord: function(record) {
        var layer = record.getLayer();
        return {
            source: record.get("source"),
            name: record.get("name"),
            title: record.get("title"),
            visibility: layer.getVisibility(),
            opacity: layer.opacity || undefined,
            group: record.get("group"),
            fixed: record.get("fixed"),
            selected: record.get("selected")
        };
    },
    
    /** api: method[getState]
     *  :returns: ``Object``
     *
     *  Gets the configured source state.
     */
    getState: function() {
        //  Overwrite in subclasses to return anything other than a copy
        // of the initialConfig property.
        return Ext.apply({}, this.initialConfig);
    }
});

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/LayerSource.js
 * @requires OpenLayers/Layer/Bing.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = BingSource
 */

/** api: (extends)
 *  plugins/LayerSource.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: BingSource(config)
 *
 *    Plugin for using Bing layers with :class:`gxp.Viewer` instances.
 *
 *    Available layer names are "Road", "Aerial" and "AerialWithLabels"
 */
/** api: example
 *  The configuration in the ``sources`` property of the :class:`gxp.Viewer` is
 *  straightforward:
 *
 *  .. code-block:: javascript
 *
 *    "bing": {
 *        ptype: "gxp_bingsource"
 *    }
 *
 *  A typical configuration for a layer from this source (in the ``layers``
 *  array of the viewer's ``map`` config option would look like this:
 *
 *  .. code-block:: javascript
 *
 *    {
 *        source: "bing",
 *        title: "Bing Road Map",
 *        name: "Road"
 *    }
 *
 */
gxp.plugins.BingSource = Ext.extend(gxp.plugins.LayerSource, {
    
    /** api: ptype = gxp_bingsource */
    ptype: "gxp_bingsource",

    /** api: property[store]
     *  ``GeoExt.data.LayerStore``. Will contain records with "Road" and
     *  "Aerial" as name field values.
     */
    
    /** api: config[title]
     *  ``String``
     *  A descriptive title for this layer source (i18n).
     */
    title: "Bing Layers",
    
    /** api: config[roadTitle]
     *  ``String``
     *  A descriptive title for the Road layer (i18n).
     */
    roadTitle: "Bing Roads",

    /** api: config[aerialTitle]
     *  ``String``
     *  A descriptive title for the Aerial layer (i18n).
     */
    aerialTitle: "Bing Aerial",

    /** api: config[labeledAerialTitle]
     *  ``String``
     *  A descriptive title for the AerialWithLabels layer (i18n).
     */
    labeledAerialTitle: "Bing Aerial With Labels",
    
    /** api: config[apiKey]
     *  ``String``
     *  API key generated from http://bingmapsportal.com/ for your domain.
     */
    apiKey: "AqTGBsziZHIJYYxgivLBf0hVdrAk9mWO5cQcb8Yux8sW5M8c8opEC2lZqKR1ZZXf",
    
    /** api: method[createStore]
     *
     *  Creates a store of layer records.  Fires "ready" when store is loaded.
     */
    createStore: function() {
        
        var layers = [
            new OpenLayers.Layer.Bing({
                key: this.apiKey,
                name: this.roadTitle,
                type: "Road",
                buffer: 1,
                transitionEffect: "resize"
            }),
            new OpenLayers.Layer.Bing({
                key: this.apiKey,
                name: this.aerialTitle,
                type: "Aerial",
                buffer: 1,
                transitionEffect: "resize"
            }),
            new OpenLayers.Layer.Bing({
                key: this.apiKey,
                name: this.labeledAerialTitle,
                type: "AerialWithLabels",
                buffer: 1,
                transitionEffect: "resize"
            })
        ];
        
        this.store = new GeoExt.data.LayerStore({
            layers: layers,
            fields: [
                {name: "source", type: "string"},
                {name: "name", type: "string", mapping: "type"},
                {name: "abstract", type: "string", mapping: "attribution"},
                {name: "group", type: "string", defaultValue: "background"},
                {name: "fixed", type: "boolean", defaultValue: true},
                {name: "selected", type: "boolean"}
            ]
        });
        this.store.each(function(l) {
            l.set("group", "background");
        });
        this.fireEvent("ready", this);

    },
    
    /** api: method[createLayerRecord]
     *  :arg config:  ``Object``  The application config for this layer.
     *  :returns: ``GeoExt.data.LayerRecord``
     *
     *  Create a layer record given the config.
     */
    createLayerRecord: function(config) {
        var record;
        var index = this.store.findExact("name", config.name);
        if (index > -1) {

            record = this.store.getAt(index).copy(Ext.data.Record.id({}));
            var layer = record.getLayer().clone();
 
            // set layer title from config
            if (config.title) {
                /**
                 * Because the layer title data is duplicated, we have
                 * to set it in both places.  After records have been
                 * added to the store, the store handles this
                 * synchronization.
                 */
                layer.setName(config.title);
                record.set("title", config.title);
            }

            // set visibility from config
            if ("visibility" in config) {
                layer.visibility = config.visibility;
            }
            
            record.set("selected", config.selected || false);
            record.set("source", config.source);
            record.set("name", config.name);
            if ("group" in config) {
                record.set("group", config.group);
            }

            record.data.layer = layer;
            record.commit();
        }
        return record;
    }

});

Ext.preg(gxp.plugins.BingSource.prototype.ptype, gxp.plugins.BingSource);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires util.js
 * @requires plugins/LayerSource.js
 * @requires OpenLayers/Layer/WMS.js
 * @requires OpenLayers/Format/WMSCapabilities/v1_1_0.js
 * @requires OpenLayers/Format/WMSCapabilities/v1_1_1.js
 * @requires OpenLayers/Format/WMSCapabilities/v1_3_0.js
 * @requires OpenLayers/Protocol/WFS/v1_1_0.js
 * @requires GeoExt/data/WMSCapabilitiesReader.js
 * @requires GeoExt/data/WMSCapabilitiesStore.js
 * @requires GeoExt/data/WMSDescribeLayerStore.js
 * @requires GeoExt/data/AttributeReader.js
 * @requires GeoExt/data/AttributeStore.js
 */

/**
 * The WMSCapabilities and WFSDescribeFeatureType formats parse the document and
 * pass the raw data to the WMSCapabilitiesReader/AttributeReader.  There,
 * records are created from layer data.  The rest of the data is lost.  It
 * makes sense to store this raw data somewhere - either on the OpenLayers
 * format or the GeoExt reader.  Until there is a better solution, we'll
 * override the reader's readRecords method  here so that we can have access to
 * the raw data later.
 * 
 * The purpose of all of this is to get the service title, feature type and
 * namespace later.
 * TODO: push this to OpenLayers or GeoExt
 */
(function() {
    function keepRaw(data) {
        var format = this.meta.format;
        if (typeof data === "string" || data.nodeType) {
            data = format.read(data);
            // cache the data for the single read that readRecord does
            var origRead = format.read;
            format.read = function() {
                format.read = origRead;
                return data;
            };
        }
        // here is the new part
        this.raw = data;
    }
    Ext.intercept(GeoExt.data.WMSCapabilitiesReader.prototype, "readRecords", keepRaw);
    GeoExt.data.AttributeReader &&
        Ext.intercept(GeoExt.data.AttributeReader.prototype, "readRecords", keepRaw);
})();

/** api: (define)
 *  module = gxp.plugins
 *  class = WMSSource
 */

/** api: (extends)
 *  plugins/LayerSource.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: WMSSource(config)
 *
 *    Plugin for using WMS layers with :class:`gxp.Viewer` instances. The
 *    plugin issues a GetCapabilities request to create a store of the WMS's
 *    layers.
 */   
/** api: example
 *  Configuration in the  :class:`gxp.Viewer`:
 *
 *  .. code-block:: javascript
 *
 *    defaultSourceType: "gxp_wmssource",
 *    sources: {
 *        "opengeo": {
 *            url: "http://suite.opengeo.org/geoserver/wms"
 *        }
 *    }
 *
 *  A typical configuration for a layer from this source (in the ``layers``
 *  array of the viewer's ``map`` config option would look like this:
 *
 *  .. code-block:: javascript
 *
 *    {
 *        source: "opengeo",
 *        name: "world",
 *        group: "background"
 *    }
 *
 * An optional 'getFeatureInfo' property can also be passed to
 * customize the sort order, visibility, & labels for layer attributes.
 * A sample 'getFeatureInfo' configuration would look like this:
 *
 *  .. code-block:: javascript
 *
 *    {
 *        fields: ["twn_name","pop1990"]
 *        propertyNames: {"pop1990": "1990 Population",  "twn_name": "Town"}
 *    }
 *
 *  Within the 'getFeatureInfo' configuration, the 'fields' property determines sort
 *  order & visibility (any attributes not included are not displayed) and
 *  'propertyNames'  specifies the labels for the attributes.
 *
 *  For initial programmatic layer configurations, to leverage lazy loading of
 *  the Capabilities document, it is recommended to configure layers with the
 *  fields listed in :obj:`requiredProperties`.
 */
gxp.plugins.WMSSource = Ext.extend(gxp.plugins.LayerSource, {
    
    /** api: ptype = gxp_wmssource */
    ptype: "gxp_wmssource",
    
    /** api: config[url]
     *  ``String`` WMS service URL for this source
     */

    /** private: config[restUrl]
     *  ``String`` Optional URL for rest configuration endpoint.  Note that this
     *  property is being added for a specific GeoNode case and it may be 
     *  removed if an alternate solution is chosen (like a specific 
     *  GeoNodeSource).  This is used where the rest config endpoint cannot
     *  be derived from the source url (e.g. source url "/geoserver" and rest
     *  config url "/other_rest_proxy").
     */

    /** api: config[baseParams]
     *  ``Object`` Base parameters to use on the WMS GetCapabilities
     *  request.
     */
    baseParams: null,

    /** private: property[format]
     *  ``OpenLayers.Format`` Optional custom format to use on the 
     *  WMSCapabilitiesStore store instead of the default.
     */
    format: null,
    
    /** private: property[describeLayerStore]
     *  ``GeoExt.data.WMSDescribeLayerStore`` additional store of layer
     *  descriptions. Will only be available when the source is configured
     *  with ``describeLayers`` set to true.
     */
    describeLayerStore: null,
    
    /** private: property[describedLayers]
     */
    describedLayers: null,
    
    /** private: property[schemaCache]
     */
    schemaCache: null,
    
    /** private: property[ready]
     *  ``Boolean``
     */
    ready: false,
    
    /** api: config[version]
     *  ``String``
     *  If specified, the version string will be included in WMS GetCapabilities
     *  requests.  By default, no version is set.
     */
    
    /** api: config[requiredProperties]
     *  ``Array(String)`` List of config properties that are required for each
     *  layer from this source to allow lazy loading, in addition to ``name``.
     *  Default is ``["title", "bbox"]``. When the source loads layers from a
     *  WMS that does not provide layers in all projections, ``srs`` should be
     *  included in this list. Fallback values are available for ``title`` (the
     *  WMS layer name), ``bbox`` (the map's ``maxExtent`` as array), and
     *  ``srs`` (the map's ``projection``, e.g. "EPSG:4326").
     */
    
    /** api: property[requiredProperties]
     *  ``Array(String)`` List of config properties that are required for a
     *  complete layer configuration, in addition to ``name``.
     */
    requiredProperties: ["title", "bbox"],
    
    /** private: method[constructor]
     */
    constructor: function(config) {
        // deal with deprecated forceLazy config option
        //TODO remove this before we cut a release
        if (config && config.forceLazy === true) {
            config.requiredProperties = [];
            delete config.forceLazy;
            if (window.console) {
                console.warn("Deprecated config option 'forceLazy: true' for layer source '" +
                    config.id + "'. Use 'requiredProperties: []' instead.");
            }
        }
        gxp.plugins.WMSSource.superclass.constructor.apply(this, arguments);
        if (!this.format) {
            this.format = new OpenLayers.Format.WMSCapabilities({keepData: true});
        }
    },

    /** api: method[init]
     *  :arg target: ``Object`` The object initializing this plugin.
     */
    init: function(target) {
        gxp.plugins.WMSSource.superclass.init.apply(this, arguments);
        this.target.on("authorizationchange", this.onAuthorizationChange, this);
    },

    /** private: method[onAuthorizationChange]
     *  Reload the store when the authorization changes.
     */
    onAuthorizationChange: function() {
        if (this.disabled !== true && this.store && this.url.charAt(0) === "/") {
            var lastOptions = this.store.lastOptions || {params: {}};
            Ext.apply(lastOptions.params, {
                '_dc': Math.random()
            });
            this.store.reload(lastOptions);
        }
    },

    /** private: method[destroy]
     */
    destroy: function() {
        this.target.un("authorizationchange", this.onAuthorizationChange, this);
        gxp.plugins.WMSSource.superclass.destroy.apply(this, arguments);
    },

    /** private: method[isLazy]
     *  :returns: ``Boolean``
     *
     *  The store for a lazy source will not be loaded upon creation.  A source
     *  determines whether or not it is lazy given the configured layers for
     *  the target.  If the layer configs have all the information needed to 
     *  construct layer records, the source can be lazy.
     */
    isLazy: function() {
        var lazy = true;
        var mapConfig = this.target.initialConfig.map;
        if (mapConfig && mapConfig.layers) {
            var layerConfig;
            for (var i=0, ii=mapConfig.layers.length; i<ii; ++i) {
                layerConfig = mapConfig.layers[i];
                if (layerConfig.source === this.id) {
                    lazy = this.layerConfigComplete(layerConfig);
                    if (lazy === false) {
                        break;
                    }
                }
            }
        }
        return lazy;
    },
    
    /** private: method[layerConfigComplete]
     *  :returns: ``Boolean``
     *
     *  A layer configuration is considered complete if it has a title and a
     *  bbox.
     */
    layerConfigComplete: function(config) {
        var lazy = true;
        if (!Ext.isObject(config.capability)) {
            var props = this.requiredProperties;
            for (var i=props.length-1; i>=0; --i) {
                lazy = !!config[props[i]];
                if (lazy === false) {
                    break;
                }
            } 
        }
        return lazy;
    },

    /** api: method[createStore]
     *
     *  Creates a store of layer records.  Fires "ready" when store is loaded.
     */
    createStore: function() {
        var baseParams = this.baseParams || {
            SERVICE: "WMS",
            REQUEST: "GetCapabilities"
        };
        if (this.version) {
            baseParams.VERSION = this.version;
        }

        var lazy = this.isLazy();
        
        this.store = new GeoExt.data.WMSCapabilitiesStore({
            // Since we want our parameters (e.g. VERSION) to override any in the 
            // given URL, we need to remove corresponding paramters from the 
            // provided URL.  Simply setting baseParams on the store is also not
            // enough because Ext just tacks these parameters on to the URL - so
            // we get requests like ?Request=GetCapabilities&REQUEST=GetCapabilities
            // (assuming the user provides a URL with a Request parameter in it).
            url: this.trimUrl(this.url, baseParams),
            baseParams: baseParams,
            format: this.format,
            autoLoad: !lazy,
            layerParams: {exceptions: null},
            listeners: {
                load: function() {
                    // The load event is fired even if a bogus capabilities doc 
                    // is read (http://trac.geoext.org/ticket/295).
                    // Until this changes, we duck type a bad capabilities 
                    // object and fire failure if found.
                    if (!this.store.reader.raw || !this.store.reader.raw.service) {
                        this.fireEvent("failure", this, "Invalid capabilities document.");
                    } else {
                        if (!this.title) {
                            this.title = this.store.reader.raw.service.title;                        
                        }
                        if (!this.ready) {
                            this.ready = true;
                            this.fireEvent("ready", this);
                        } else {
                            this.lazy = false;
                            //TODO Here we could update all records from this
                            // source on the map that were added when the
                            // source was lazy.
                        }
                    }
                    // clean up data stored on format after parsing is complete
                    delete this.format.data;
                },
                exception: function(proxy, type, action, options, response, error) {
                    delete this.store;
                    var msg, details = "";
                    if (type === "response") {
                        if (typeof error == "string") {
                            msg = error;
                        } else {
                            msg = "Invalid response from server.";
                            // special error handling in IE
                            var data = this.format && this.format.data;
                            if (data && data.parseError) {
                                msg += "  " + data.parseError.reason + " - line: " + data.parseError.line;
                            }
                            var status = response.status;
                            if (status >= 200 && status < 300) {
                                // TODO: consider pushing this into GeoExt
                                var report = error && error.arg && error.arg.exceptionReport;
                                details = gxp.util.getOGCExceptionText(report);
                            } else {
                                details = "Status: " + status;
                            }
                        }
                    } else {
                        msg = "Trouble creating layer store from response.";
                        details = "Unable to handle response.";
                    }
                    // TODO: decide on signature for failure listeners
                    this.fireEvent("failure", this, msg, details);
                    // clean up data stored on format after parsing is complete
                    delete this.format.data;
                },
                scope: this
            }
        });
        if (lazy) {
            this.lazy = lazy;
            this.ready = true;
            this.fireEvent("ready", this);
        }
    },
    
    /** private: method[trimUrl]
     *  :arg url: ``String``
     *  :arg params: ``Object``
     *
     *  Remove all parameters from the URL's query string that have matching
     *  keys in the provided object.  Keys are compared in a case-insensitive 
     *  way.
     */
    trimUrl: function(url, params, respectCase) {
        var urlParams = OpenLayers.Util.getParameters(url);
        params = OpenLayers.Util.upperCaseObject(params);
        var keys = 0;
        for (var key in urlParams) {
            ++keys;
            if (key.toUpperCase() in params) {
                --keys;
                delete urlParams[key];
            }
        }
        return url.split("?").shift() + (keys ? 
            "?" + OpenLayers.Util.getParameterString(urlParams) :
            ""
        );
    },
    
    /** private: method[createLazyLayerRecord]
     *  :arg config: ``Object`` The application config for this layer.
     *  :returns: ``GeoExt.data.LayerRecord``
     *
     *  Create a minimal layer record
     */
    createLazyLayerRecord: function(config) {
        config = Ext.apply({}, config);
        
        var srs = config.srs || this.target.map.projection;
        config.srs = {};
        config.srs[srs] = true;
        
        var bbox = config.bbox || this.target.map.maxExtent || OpenLayers.Projection.defaults[srs].maxExtent;
        config.bbox = {};
        config.bbox[srs] = {bbox: bbox};
        
        var record;
        if (this.store && this.store instanceof GeoExt.data.WMSCapabilitiesStore) {
            record = new this.store.recordType(config);
        } else {
            record = new GeoExt.data.LayerRecord(config);
        }
        record.setLayer(new OpenLayers.Layer.WMS(
            config.title || config.name,
            config.url || this.url, {
                layers: config.name,
                transparent: "transparent" in config ? config.transparent : true,
                cql_filter: config.cql_filter,
                format: config.format
            }, {
                projection: srs,
                eventListeners: {
                  tileloaded: this.countAlive,
                  tileerror: this.countAlive,
                  scope: this
                }
            }
        ));
        record.json = config;
        return record;
    },

    countAlive: function(evt) {
        if (!('_alive' in evt.object.metadata)) {
            evt.object.metadata._alive = 0;
            evt.object.events.register('loadend', this, this.removeDeadLayer);
        }
        evt.object.metadata._alive += (evt.type == 'tileerror' ? -1 : 1);
    },

    removeDeadLayer: function(evt) {
        evt.object.events.un({
            'tileloaded': this.countAlive,
            'tileerror': this.countAlive,
            'loadend': this.removeDeadLayer,
            scope: this
        });
        if (evt.object.metadata._alive === 0) {
            this.target.mapPanel.map.removeLayer(evt.object);
            if (window.console) {
              console.debug('Unavailable layer ' + evt.object.name + ' removed.');
            }
        }
        delete evt.object.metadata._alive;
    },

    /** api: method[createLayerRecord]
     *  :arg config:  ``Object``  The application config for this layer.
     *  :returns: ``GeoExt.data.LayerRecord`` or null when the source is lazy.
     *
     *  Create a layer record given the config. Applications should check that
     *  the source is not :obj:`lazy`` or that the ``config`` is complete (i.e.
     *  configured with all fields listed in :obj:`requiredProperties` before
     *  using this method. Otherwise, it is recommended to use the asynchronous
     *  :meth:`gxp.Viewer.createLayerRecord` method on the target viewer
     *  instead, which will load the source's store to complete the
     *  configuration if necessary.
     */
    createLayerRecord: function(config) {
        var record, original;
        var index = this.store.findExact("name", config.name);
        if (index > -1) {
            original = this.store.getAt(index);
        } else if (Ext.isObject(config.capability)) {
            original = this.store.reader.readRecords({capability: {
                request: {getmap: {href: this.trimUrl(this.url, this.baseParams)}},
                layers: [config.capability]}
            }).records[0];
        } else if (this.layerConfigComplete(config)) {
            original = this.createLazyLayerRecord(config);
        }
        if (original) {

            var layer = original.getLayer().clone();

            /**
             * TODO: The WMSCapabilitiesReader should allow for creation
             * of layers in different SRS.
             */
            var projection = this.getMapProjection();
            
            // If the layer is not available in the map projection, find a
            // compatible projection that equals the map projection. This helps
            // us in dealing with the different EPSG codes for web mercator.
            var layerProjection = this.getProjection(original);
            if (layerProjection) {
                layer.addOptions({projection: layerProjection});
            }

            var projCode = (layerProjection || projection).getCode(),
                bbox = original.get("bbox"), maxExtent;

            // determine maxExtent in map projection
            if (bbox && bbox[projCode]){
                maxExtent = OpenLayers.Bounds.fromArray(bbox[projCode].bbox, layer.reverseAxisOrder());
            } else {
                var llbbox = original.get("llbbox");
                if (llbbox) {
                    llbbox[0] = Math.max(llbbox[0], -180);
                    llbbox[1] = Math.max(llbbox[1], -90);
                    llbbox[2] = Math.min(llbbox[2], 180);
                    llbbox[3] = Math.min(llbbox[3], 90);
                    maxExtent = OpenLayers.Bounds.fromArray(llbbox).transform("EPSG:4326", projection);
                }
            }
            
            // update params from config
            layer.mergeNewParams({
                STYLES: config.styles,
                FORMAT: config.format,
                TRANSPARENT: config.transparent,
                CQL_FILTER: config.cql_filter
            });
            
            var singleTile = false;
            if ("tiled" in config) {
                singleTile = !config.tiled;
            } else {
                // for now, if layer has a time dimension, use single tile
                if (original.data.dimensions && original.data.dimensions.time) {
                    singleTile = true;
                }
            }

            layer.setName(config.title || layer.name);
            layer.addOptions({
                attribution: layer.attribution || config.attribution,
                maxExtent: maxExtent,
                restrictedExtent: maxExtent,
                singleTile: singleTile,
                ratio: config.ratio || 1,
                visibility: ("visibility" in config) ? config.visibility : true,
                opacity: ("opacity" in config) ? config.opacity : 1,
                buffer: ("buffer" in config) ? config.buffer : 1,
                dimensions: original.data.dimensions,
                transitionEffect: singleTile ? 'resize' : null,
                minScale: config.minscale,
                maxScale: config.maxscale
            });
            
            // data for the new record
            var data = Ext.applyIf({
                title: layer.name,
                group: config.group,
                infoFormat: config.infoFormat,
                getFeatureInfo:  config.getFeatureInfo,
                source: config.source,
                properties: "gxp_wmslayerpanel",
                fixed: config.fixed,
                selected: "selected" in config ? config.selected : false,
                restUrl: this.restUrl,
                layer: layer
            }, original.data);
            
            // add additional fields
            var fields = [
                {name: "source", type: "string"}, 
                {name: "group", type: "string"},
                {name: "properties", type: "string"},
                {name: "fixed", type: "boolean"},
                {name: "selected", type: "boolean"},
                {name: "restUrl", type: "string"},
                {name: "infoFormat", type: "string"},
                {name: "getFeatureInfo"}
            ];
            original.fields.each(function(field) {
                fields.push(field);
            });

            var Record = GeoExt.data.LayerRecord.create(fields);
            record = new Record(data, layer.id);
            record.json = config;

        } else {
            if (window.console && this.store.getCount() > 0 && config.name !== undefined) {
                console.warn("Could not create layer record for layer '" + config.name + "'. Check if the layer is found in the WMS GetCapabilities response.");
            }
        }
        return record;
    },
    
    /** api: method[getProjection]
     *  :arg layerRecord: ``GeoExt.data.LayerRecord`` a record from this
     *      source's store
     *  :returns: ``OpenLayers.Projection`` A suitable projection for the
     *      ``layerRecord``. If the layer is available in the map projection,
     *      the map projection will be returned. Otherwise an equal projection,
     *      or null if none is available.
     *
     *  Get the projection that the source will use for the layer created in
     *  ``createLayerRecord``. If the layer is not available in a projection
     *  that fits the map projection, null will be returned.
     */
    getProjection: function(layerRecord) {
        var projection = this.getMapProjection();
        var compatibleProjection = projection;
        var availableSRS = layerRecord.get("srs");
        if (!availableSRS[projection.getCode()]) {
            compatibleProjection = null;
            var p, srs;
            for (srs in availableSRS) {
                if ((p=new OpenLayers.Projection(srs)).equals(projection)) {
                    compatibleProjection = p;
                    break;
                }
            }
        }
        return compatibleProjection;
    },
    
    /** private: method[initDescribeLayerStore]
     *  creates a WMSDescribeLayer store for layer descriptions of all layers
     *  created from this source.
     */
    initDescribeLayerStore: function() {
        var raw = this.store.reader.raw;
        if (this.lazy) {
            // When lazy, we assume that the server supports a DescribeLayer
            // request at the layer's url.
            raw = {
                capability: {
                    request: {
                        describelayer: {href: this.url}
                    }
                },
                version: this.version || "1.1.1"
            };
        }
        var req = raw.capability.request.describelayer;
        if (req) {
            var version = raw.version;
            if (parseFloat(version) > 1.1) {
                //TODO don't force 1.1.1, fall back instead
                version = "1.1.1";
            }
            var params = {
                SERVICE: "WMS",
                VERSION: version,
                REQUEST: "DescribeLayer"
            };
            this.describeLayerStore = new GeoExt.data.WMSDescribeLayerStore({
                url: this.trimUrl(req.href, params),
                baseParams: params
            });
        }
    },
    
    /** api: method[describeLayer]
     *  :arg rec: ``GeoExt.data.LayerRecord`` the layer to issue a WMS
     *      DescribeLayer request for
     *  :arg callback: ``Function`` Callback function. Will be called with
     *      an ``Ext.data.Record`` from a ``GeoExt.data.DescribeLayerStore``
     *      as first argument, or false if the WMS does not support
     *      DescribeLayer.
     *  :arg scope: ``Object`` Optional scope for the callback.
     *
     *  Get a DescribeLayer response from this source's WMS.
     */
    describeLayer: function(rec, callback, scope) {
        if (!this.describeLayerStore) {
            this.initDescribeLayerStore();
        }
        function delayedCallback(arg) {
            window.setTimeout(function() {
                callback.call(scope, arg);
            }, 0);
        }
        if (!this.describeLayerStore) {
            delayedCallback(false);
            return;
        }
        if (!this.describedLayers) {
            this.describedLayers = {};
        }
        var layerName = rec.getLayer().params.LAYERS;
        var cb = function() {
            var recs = Ext.isArray(arguments[1]) ? arguments[1] : arguments[0];
            var rec, name;
            for (var i=recs.length-1; i>=0; i--) {
                rec = recs[i];
                name = rec.get("layerName");
                if (name == layerName) {
                    this.describeLayerStore.un("load", arguments.callee, this);
                    this.describedLayers[name] = true;
                    callback.call(scope, rec);
                    return;
                } else if (typeof this.describedLayers[name] == "function") {
                    var fn = this.describedLayers[name];
                    this.describeLayerStore.un("load", fn, this);
                    fn.apply(this, arguments);
                }
            }
            // something went wrong (e.g. GeoServer does not return a valid
            // DescribeFeatureType document for group layers)
            delete describedLayers[layerName];
            callback.call(scope, false);
        };
        var describedLayers = this.describedLayers;
        var index;
        if (!describedLayers[layerName]) {
            describedLayers[layerName] = cb;
            this.describeLayerStore.load({
                params: {LAYERS: layerName},
                add: true,
                callback: cb,
                scope: this
            });
        } else if ((index = this.describeLayerStore.findExact("layerName", layerName)) == -1) {
            this.describeLayerStore.on("load", cb, this);
        } else {
            delayedCallback(this.describeLayerStore.getAt(index));
        }
    },

    /** private: method[fetchSchema]
     *  :arg url: ``String`` The url fo the WFS endpoint
     *  :arg typeName: ``String`` The typeName to use
     *  :arg callback: ``Function`` Callback function. Will be called with
     *      a ``GeoExt.data.AttributeStore`` containing the schema as first
     *      argument, or false if the WMS does not support DescribeLayer or the
     *      layer is not associated with a WFS feature type.
     *  :arg scope: ``Object`` Optional scope for the callback.
     *
     *  Helper function to fetch the schema for a layer of this source.
     */
    fetchSchema: function(url, typeName, callback, scope) {
        var schema = this.schemaCache[typeName];
        if (schema) {
            if (schema.getCount() == 0) {
                schema.on("load", function() {
                    callback.call(scope, schema);
                }, this, {single: true});
            } else {
                callback.call(scope, schema);
            }
        } else {
            schema = new GeoExt.data.AttributeStore({
                url: url,
                baseParams: {
                    SERVICE: "WFS",
                    //TODO should get version from WFS GetCapabilities
                    VERSION: "1.1.0",
                    REQUEST: "DescribeFeatureType",
                    TYPENAME: typeName
                },
                autoLoad: true,
                listeners: {
                    "load": function() {
                        callback.call(scope, schema);
                    },
                    scope: this
                }
            });
            this.schemaCache[typeName] = schema;
        }
    },
    
    /** api: method[getSchema]
     *  :arg rec: ``GeoExt.data.LayerRecord`` the WMS layer to issue a WFS
     *      DescribeFeatureType request for
     *  :arg callback: ``Function`` Callback function. Will be called with
     *      a ``GeoExt.data.AttributeStore`` containing the schema as first
     *      argument, or false if the WMS does not support DescribeLayer or the
     *      layer is not associated with a WFS feature type.
     *  :arg scope: ``Object`` Optional scope for the callback.
     *
     *  Gets the schema for a layer of this source, if the layer is a feature
     *  layer.
     */
    getSchema: function(rec, callback, scope) {
        if (!this.schemaCache) {
            this.schemaCache = {};
        }
        this.describeLayer(rec, function(r) {
            if (r && r.get("owsType") == "WFS") {
                var typeName = r.get("typeName");
                var url = r.get("owsURL");
                this.fetchSchema(url, typeName, callback, scope);
            } else if (!r) {
                // When DescribeLayer is not supported, we make the following
                // assumptions:
                // 1. URL of the WFS is the same as the URL of the WMS
                // 2. typeName is the same as the WMS Layer name
                this.fetchSchema(this.url, rec.get('name'), callback, scope);
            } else {
                callback.call(scope, false);
            }
        }, this);
    },
    
    /** api: method[getWFSProtocol]
     *  :arg record: :class:`GeoExt.data.LayerRecord`
     *  :arg callback: ``Function``
     *  :arg scope: ``Object``
     *  :returns: :class:`OpenLayers.Protocol.WFS`
     *
     *  Creates a WFS protocol for the given WMS layer record.
     */
    getWFSProtocol: function(record, callback, scope) {
        this.getSchema(record, function(schema) {
            var protocol = false;
            if (schema) {
                var geometryName;
                var geomRegex = /gml:((Multi)?(Point|Line|Polygon|Curve|Surface|Geometry)).*/;
                schema.each(function(r) {
                    var match = geomRegex.exec(r.get("type"));
                    if (match) {
                        geometryName = r.get("name");
                    }
                }, this);
                protocol = new OpenLayers.Protocol.WFS({
                    version: "1.1.0",
                    srsName: record.getLayer().projection.getCode(),
                    url: schema.url,
                    featureType: schema.reader.raw.featureTypes[0].typeName,
                    featureNS: schema.reader.raw.targetNamespace,
                    geometryName: geometryName
                });
            }
            callback.call(scope, protocol, schema, record);
        }, this);
    },

    /** api: method[getConfigForRecord]
     *  :arg record: :class:`GeoExt.data.LayerRecord`
     *  :returns: ``Object``
     *
     *  Create a config object that can be used to recreate the given record.
     */
    getConfigForRecord: function(record) {
        var config = Ext.applyIf(
                gxp.plugins.WMSSource.superclass.getConfigForRecord.apply(this, arguments),
                record.json
            ),
            layer = record.getLayer(),
            params = layer.params,
            options = layer.options;
        var name = config.name,
            raw = this.store.reader.raw;
        if (raw) {
            var capLayers = raw.capability.layers;
            for (var i=capLayers.length-1; i>=0; --i) {
                if (capLayers[i].name === name) {
                    config.capability = Ext.apply({}, capLayers[i]);
                    var srs = {};
                    srs[layer.projection.getCode()] = true;
                    // only store the map srs, because this list can be huge
                    config.capability.srs = srs;
                    break;
                }
            }
        }
        if (!config.capability) {
            if (layer.maxExtent) {
                config.bbox = layer.maxExtent.toArray();
            }
            config.srs = layer.projection.getCode();
        }
        return Ext.apply(config, {
            format: params.FORMAT,
            styles: params.STYLES,
            tiled: !options.singleTile,
            transparent: params.TRANSPARENT,
            cql_filter: params.CQL_FILTER,
            minscale: options.minScale,
            maxscale: options.maxScale,
            infoFormat: record.get("infoFormat"),
            attribution: layer.attribution
        });
    },

    disable: function() {
        this.disabled = true;
    },
    
    /** private: method[getState] */
    getState: function() {
        var state = gxp.plugins.WMSSource.superclass.getState.apply(this, arguments);
        return Ext.applyIf(state, {title: this.title});
    }
    
});

Ext.preg(gxp.plugins.WMSSource.prototype.ptype, gxp.plugins.WMSSource);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/WMSSource.js
 * @requires OpenLayers/Format/WMSCapabilities/v1_1_1_WMSC.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = WMSCSource
 */

/** api: (extends)
 *  plugins/WMSSource.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: WMSCSource(config)
 *
 *    Plugin for using WMS-C layers with :class:`gxp.Viewer` instances. The
 *    plugin issues a GetCapabilities request to create a store of the WMS's
 *    layers. If tilesets are available, it will use them.
 */   
/** api: example
 *  Configuration in the  :class:`gxp.Viewer`:
 *
 *  .. code-block:: javascript
 *
 *    defaultSourceType: "gxp_wmscsource",
 *    sources: {
 *        "opengeo": {
 *            url: "http://suite.opengeo.org/geoserver/wms"
 *        }
 *    }
 *
 *  A typical configuration for a layer from this source (in the ``layers``
 *  array of the viewer's ``map`` config option would look like this:
 *
 *  .. code-block:: javascript
 *
 *    {
 *        source: "opengeo",
 *        name: "world",
 *        group: "background"
 *    }
 *
 */
gxp.plugins.WMSCSource = Ext.extend(gxp.plugins.WMSSource, {
    
    /** api: ptype = gxp_wmscsource */
    ptype: "gxp_wmscsource",
    
    /** api: config[version]
     *  ``String``
     *  Only WMS 1.1.1 is supported at the moment.
     */
    version: "1.1.1",

    /** api: config[requiredProperties]
     *  ``Array(String)`` List of config properties that are required for each
     *  layer from this source to allow lazy loading. Default is
     *  ``["title", "bbox"]``. When the source loads layers from a WMS-C that
     *  does not use subsets of the default Web Mercator grid, not provide
     *  tiles for all default Web Mercator resolutions, and not use a tileSize
     *  of 256x256 pixels, ``tileOrigin``, ``resolutions`` and ``tileSize``
     *  should be included in this list.
     */

    /** private: method[constructor]
     */
    constructor: function(config) {
        config.baseParams = {
            SERVICE: "WMS",
            REQUEST: "GetCapabilities",
            TILED: true
        };
        if (!config.format) {
            this.format = new OpenLayers.Format.WMSCapabilities({
                keepData: true,
                profile: "WMSC",
                allowFallback: true
            });
        }
        gxp.plugins.WMSCSource.superclass.constructor.apply(this, arguments); 
    },
    
    /** private: method[createLayerRecord] */
    createLayerRecord: function(config) {
        var record = gxp.plugins.WMSCSource.superclass.createLayerRecord.apply(this, arguments);
        if (!record) {
            return;
        }
        var caps, srs;
        if (this.store.reader.raw) {
            caps = this.store.reader.raw.capability;
        }
        var tileSets = (caps && caps.vendorSpecific) ? 
            caps.vendorSpecific.tileSets : (config.capability && config.capability.tileSets);
        var layer = record.get("layer");
        if (tileSets) {
            var mapProjection = this.getProjection(record) || this.getMapProjection();
            // look for tileset with same name and equivalent projection
            for (var i=0, len=tileSets.length; i<len; i++) {
                var tileSet = tileSets[i];
                if (tileSet.layers === layer.params.LAYERS) {
                    var tileProjection;
                    for (srs in tileSet.srs) {
                        tileProjection = new OpenLayers.Projection(srs);
                        break;
                    }
                    if (mapProjection.equals(tileProjection)) {
                        var bbox = tileSet.bbox[srs].bbox;
                        layer.projection = tileProjection;
                        layer.addOptions({
                            resolutions: tileSet.resolutions,
                            tileSize: new OpenLayers.Size(tileSet.width, tileSet.height),
                            tileOrigin: new OpenLayers.LonLat(bbox[0], bbox[1])
                        });
                        break;
                    }
                }
            }
        } else if (this.lazy) {
            // lazy loading
            var tileSize = config.tileSize,
                tileOrigin = config.tileOrigin;
            layer.addOptions({
                resolutions: config.resolutions,
                tileSize: tileSize ? new OpenLayers.Size(tileSize[0], tileSize[1]) : undefined,
                tileOrigin: tileOrigin ? OpenLayers.LonLat.fromArray(tileOrigin) : undefined
            });
            if (!tileOrigin) {
                // If tileOrigin was not set, our best bet is to use the map's
                // maxExtent, because GWC's tiling scheme always aligns to the
                // default Web Mercator grid. We don't do this with addOptions
                // because we persist the config from layer.options in
                // getConfigForRecord, and we don't want to persist a guessed
                // configuration.
                var maxExtent;
                if (this.target.map.maxExtent) {
                    maxExtent = this.target.map.maxExtent;
                } else {
                    srs = config.srs || this.target.map.projection;
                    maxExtent = OpenLayers.Projection.defaults[srs].maxExtent;
                }
                if (maxExtent) {
                    layer.tileOrigin = OpenLayers.LonLat.fromArray(maxExtent);
                }
            }
        }
        // unless explicitly configured otherwise, use cached version
        layer.params.TILED = (config.cached !== false) && true;
        return record;
    },

    /** api: method[getConfigForRecord]
     *  :arg record: :class:`GeoExt.data.LayerRecord`
     *  :returns: ``Object``
     *
     *  Create a config object that can be used to recreate the given record.
     */
    getConfigForRecord: function(record) {
        var config = gxp.plugins.WMSCSource.superclass.getConfigForRecord.apply(this, arguments),
            name = config.name,
            tileSetsCap,
            layer = record.getLayer();
        if (config.capability && this.store.reader.raw) {
            var capability = this.store.reader.raw.capability;
            var tileSets = capability.vendorSpecific && capability.vendorSpecific.tileSets;
            if (tileSets) {
                for (var i=tileSets.length-1; i>=0; --i) {
                    tileSetsCap = tileSets[i];
                    if (tileSetsCap.layers === name && tileSetsCap.srs[layer.projection]) {
                        config.capability.tileSets = [tileSetsCap];
                        break;
                    }
                }
            }
        }
        if (!(config.capability && config.capability.tileSets)) {
            var tileSize = layer.options.tileSize;
            if (tileSize) {
                config.tileSize = [tileSize.w, tileSize.h];
            }
            config.tileOrigin = layer.options.tileOrigin;
            config.resolutions = layer.options.resolutions;
        }
        return Ext.applyIf(config, {
            // the "tiled" property is already used to indicate singleTile
            // the "cached" property will indicate whether to send the TILED param
            cached: !!layer.params.TILED
        });
    }
    
});

Ext.preg(gxp.plugins.WMSCSource.prototype.ptype, gxp.plugins.WMSCSource);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/LayerSource.js
 * @requires OpenLayers/Layer/OSM.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = OSMSource
 */

/** api: (extends)
 *  plugins/LayerSource.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: OSMSource(config)
 *
 *    Plugin for using OpenStreetMap layers with :class:`gxp.Viewer` instances.
 *
 *    Available layer names are "mapnik" and "osmarender"
 */
/** api: example
 *  The configuration in the ``sources`` property of the :class:`gxp.Viewer` is
 *  straightforward:
 *
 *  .. code-block:: javascript
 *
 *    "osm": {
 *        ptype: "gxp_osmsource"
 *    }
 *
 *  A typical configuration for a layer from this source (in the ``layers``
 *  array of the viewer's ``map`` config option would look like this:
 *
 *  .. code-block:: javascript
 *
 *    {
 *        source: "osm",
 *        name: "osmarander"
 *    }
 *
 */
gxp.plugins.OSMSource = Ext.extend(gxp.plugins.LayerSource, {
    
    /** api: ptype = gxp_osmsource */
    ptype: "gxp_osmsource",

    /** api: property[store]
     *  ``GeoExt.data.LayerStore``. Will contain records with "mapnik" and
     *  "osmarender" as name field values.
     */
    
    /** api: config[title]
     *  ``String``
     *  A descriptive title for this layer source (i18n).
     */
    title: "OpenStreetMap Layers",

    /** api: config[mapnikAttribution]
     *  ``String``
     *  Attribution string for mapnik generated layer (i18n).
     */
    mapnikAttribution: "&copy; <a href='http://www.openstreetmap.org/copyright'>OpenStreetMap</a> contributors",

    /** api: config[homeAttribution]
     *  ``String``
     *  Attribution string for osmarender generated layer (i18n).
     */
    osmarenderAttribution: "Data CC-By-SA by <a href='http://openstreetmap.org/' target='_blank'>OpenStreetMap</a>",

    /** api: method[createStore]
     *
     *  Creates a store of layer records.  Fires "ready" when store is loaded.
     */
    createStore: function() {
        
        var options = {
            projection: "EPSG:900913",
            maxExtent: new OpenLayers.Bounds(
                -128 * 156543.0339, -128 * 156543.0339,
                128 * 156543.0339, 128 * 156543.0339
            ),
            maxResolution: 156543.03390625,
            numZoomLevels: 19,
            units: "m",
            buffer: 1,
            transitionEffect: "resize"
        };
        
        var layers = [
            new OpenLayers.Layer.OSM(
                "OpenStreetMap",
                [
                    "http://a.tile.openstreetmap.org/${z}/${x}/${y}.png",
                    "http://b.tile.openstreetmap.org/${z}/${x}/${y}.png",
                    "http://c.tile.openstreetmap.org/${z}/${x}/${y}.png"
                ],
                OpenLayers.Util.applyDefaults({                
                    attribution: this.mapnikAttribution,
                    type: "mapnik"
                }, options)
            )
        ];
        
        this.store = new GeoExt.data.LayerStore({
            layers: layers,
            fields: [
                {name: "source", type: "string"},
                {name: "name", type: "string", mapping: "type"},
                {name: "abstract", type: "string", mapping: "attribution"},
                {name: "group", type: "string", defaultValue: "background"},
                {name: "fixed", type: "boolean", defaultValue: true},
                {name: "selected", type: "boolean"}
            ]
        });
        this.store.each(function(l) {
            l.set("group", "background");
        });
        this.fireEvent("ready", this);

    },
    
    /** api: method[createLayerRecord]
     *  :arg config:  ``Object``  The application config for this layer.
     *  :returns: ``GeoExt.data.LayerRecord``
     *
     *  Create a layer record given the config.
     */
    createLayerRecord: function(config) {
        var record;
        var index = this.store.findExact("name", config.name);
        if (index > -1) {

            record = this.store.getAt(index).copy(Ext.data.Record.id({}));
            var layer = record.getLayer().clone();
 
            // set layer title from config
            if (config.title) {
                /**
                 * Because the layer title data is duplicated, we have
                 * to set it in both places.  After records have been
                 * added to the store, the store handles this
                 * synchronization.
                 */
                layer.setName(config.title);
                record.set("title", config.title);
            }

            // set visibility from config
            if ("visibility" in config) {
                layer.visibility = config.visibility;
            }
            
            record.set("selected", config.selected || false);
            record.set("source", config.source);
            record.set("name", config.name);
            if ("group" in config) {
                record.set("group", config.group);
            }

            record.data.layer = layer;
            record.commit();
        }
        return record;
    }

});

Ext.preg(gxp.plugins.OSMSource.prototype.ptype, gxp.plugins.OSMSource);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/LayerSource.js
 * @requires OpenLayers/Layer/Google/v3.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = GoogleSource
 */

/** api: (extends)
 *  plugins/LayerSource.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: GoolgeSource(config)
 *
 *    Plugin for using Google layers with :class:`gxp.Viewer` instances. The
 *    plugin uses the GMaps v3 API and also takes care of loading the
 *    required Google resources.
 *
 *    Available layer names for this source are "ROADMAP", "SATELLITE",
 *    "HYBRID" and "TERRAIN"
 */   
/** api: example
 *  The configuration in the ``sources`` property of the :class:`gxp.Viewer` is
 *  straightforward:
 *
 *  .. code-block:: javascript
 *
 *    "google": {
 *        ptype: "gxp_google"
 *    }
 *
 *  A typical configuration for a layer from this source (in the ``layers``
 *  array of the viewer's ``map`` config option would look like this:
 *
 *  .. code-block:: javascript
 *
 *    {
 *        source: "google",
 *        name: "TERRAIN"
 *    }
 *
 */
gxp.plugins.GoogleSource = Ext.extend(gxp.plugins.LayerSource, {
    
    /** api: ptype = gxp_googlesource */
    ptype: "gxp_googlesource",
    
    /** config: config[timeout]
     *  ``Number``
     *  The time (in milliseconds) to wait before giving up on the Google Maps
     *  script loading.  This layer source will not be availble if the script
     *  does not load within the given timeout.  Default is 7000 (seven seconds).
     */
    timeout: 7000,

    /** api: property[store]
     *  ``GeoExt.data.LayerStore`` containing records with "ROADMAP",
     *  "SATELLITE", "HYBRID" and "TERRAIN" name fields.
     */
    
    /** api: config[title]
     *  ``String``
     *  A descriptive title for this layer source (i18n).
     */
    title: "Google Layers",

    /** api: config[roadmapAbstract]
     *  ``String``
     *  Description of the ROADMAP layer (i18n).
     */
    roadmapAbstract: "Show street map",

    /** api: config[satelliteAbstract]
     *  ``String``
     *  Description of the SATELLITE layer (i18n).
     */
    satelliteAbstract: "Show satellite imagery",

    /** api: config[hybridAbstract]
     *  ``String``
     *  Description of the HYBRID layer (i18n).
     */
    hybridAbstract: "Show imagery with street names",

    /** api: config[terrainAbstract]
     *  ``String``
     *  Description of the TERRAIN layer (i18n).
     */
    terrainAbstract: "Show street map with terrain",

    /** api: config[otherParams]
     *  ``String``
     *  Additional parameters to be sent to Google,
     *  default is "sensor=false"
     */
    otherParams: "sensor=false",

    constructor: function(config) {
        this.config = config;
        gxp.plugins.GoogleSource.superclass.constructor.apply(this, arguments);
    },
    
    /** api: method[createStore]
     *
     *  Creates a store of layer records.  Fires "ready" when store is loaded.
     */
    createStore: function() {
        gxp.plugins.GoogleSource.loader.onLoad({
            otherParams: this.otherParams,
            timeout: this.timeout,
            callback: this.syncCreateStore,
            errback: function() {
                delete this.store;
                this.fireEvent(
                    "failure", 
                    this,
                    "The Google Maps script failed to load within the provided timeout (" + (this.timeout / 1000) + " s)."
                );
            },
            scope: this
        });
    },
    
    /** private: method[syncCreateStore]
     *
     *  Creates a store of layers.  This requires that the API script has already
     *  loaded.  Fires the "ready" event when the store is loaded.
     */
    syncCreateStore: function() {
        // TODO: The abstracts ("alt" properties) should be derived from the
        // MapType objects themselves.  It doesn't look like there is currently
        // a way to get the default map types before creating a map object.
        // http://code.google.com/p/gmaps-api-issues/issues/detail?id=2562
        // TODO: We may also be able to determine the MAX_ZOOM_LEVEL for each
        // layer type. If not, consider setting them on the OpenLayers level.
        var mapTypes = {
            "ROADMAP": {"abstract": this.roadmapAbstract, MAX_ZOOM_LEVEL: 20},
            "SATELLITE": {"abstract": this.satelliteAbstract},
            "HYBRID": {"abstract": this.hybridAbstract},
            "TERRAIN": {"abstract": this.terrainAbstract, MAX_ZOOM_LEVEL: 15}
        };
        
        var layers = [];
        var name, mapType;
        for (name in mapTypes) {
            mapType = google.maps.MapTypeId[name];
            layers.push(new OpenLayers.Layer.Google(
                // TODO: get MapType object name
                // http://code.google.com/p/gmaps-api-issues/issues/detail?id=2562
                "Google " + mapType.replace(/\w/, function(c) {return c.toUpperCase();}), {
                    type: mapType,
                    typeName: name,
                    MAX_ZOOM_LEVEL: mapTypes[name].MAX_ZOOM_LEVEL,
                    maxExtent: new OpenLayers.Bounds(-20037508.34,-20037508.34,20037508.34,20037508.34),
                    restrictedExtent: new OpenLayers.Bounds(-20037508.34,-20037508.34,20037508.34,20037508.34),
                    projection: this.projection
                }
            ));
        }
        this.store = new GeoExt.data.LayerStore({
            layers: layers,
            fields: [
                {name: "source", type: "string"},
                {name: "name", type: "string", mapping: "typeName"},
                {name: "abstract", type: "string"},
                {name: "group", type: "string", defaultValue: "background"},
                {name: "fixed", type: "boolean", defaultValue: true},
                {name: "selected", type: "boolean"}
            ]
        });
        this.store.each(function(l) {
            l.set("abstract", mapTypes[l.get("name")]["abstract"]);
        });
        this.fireEvent("ready", this);
    },
    
    /** api: method[createLayerRecord]
     *  :arg config:  ``Object``  The application config for this layer.
     *  :returns: ``GeoExt.data.LayerRecord``
     *
     *  Create a layer record given the config.
     */
    createLayerRecord: function(config) {
        var record;
        var cmp = function(l) {
            return l.get("name") === config.name;
        };
        // only return layer if app does not have it already
        if (this.target.mapPanel.layers.findBy(cmp) == -1) {
            // records can be in only one store
            record = this.store.getAt(this.store.findBy(cmp)).clone();
            var layer = record.getLayer();
            // set layer title from config
            if (config.title) {
                /**
                 * Because the layer title data is duplicated, we have
                 * to set it in both places.  After records have been
                 * added to the store, the store handles this
                 * synchronization.
                 */
                layer.setName(config.title);
                record.set("title", config.title);
            }
            // set visibility from config
            if ("visibility" in config) {
                layer.visibility = config.visibility;
            }
            
            record.set("selected", config.selected || false);
            record.set("source", config.source);
            record.set("name", config.name);
            if ("group" in config) {
                record.set("group", config.group);
            }
            record.commit();
        }
        return record;
    }
    
});

/**
 * Create a loader singleton that all plugin instances can use.
 */
gxp.plugins.GoogleSource.loader = new (Ext.extend(Ext.util.Observable, {

    /** private: property[ready]
     *  ``Boolean``
     *  This plugin type is ready to use.
     */
    ready: !!(window.google && google.maps),

    /** private: property[loading]
     *  ``Boolean``
     *  The resources for this plugin type are loading.
     */
    loading: false,
    
    constructor: function() {
        this.addEvents(
            /** private: event[ready]
             *  Fires when this plugin type is ready.
             */
             "ready",

             /** private: event[failure]
              *  Fires when script loading fails.
              */
              "failure"
        );
        return Ext.util.Observable.prototype.constructor.apply(this, arguments);
    },
    
    /** private: method[onScriptLoad]
     *  Called when all resources required by this plugin type have loaded.
     */
    onScriptLoad: function() {
        // the google loader calls this in the window scope
        var monitor = gxp.plugins.GoogleSource.loader;
        if (!monitor.ready) {
            monitor.ready = true;
            monitor.loading = false;
            monitor.fireEvent("ready");
        }
    },
    
    /** api: method[gxp.plugins.GoogleSource.loader.onLoad]
     *  :arg options: ``Object``
     *
     *  Options:
     *
     *  * callback - ``Function`` Called when script loads.
     *  * errback - ``Function`` Called if loading fails.
     *  * timeout - ``Number`` Time to wait before deciding that loading failed
     *      (in milliseconds).
     *  * scope - ``Object`` The ``this`` object for callbacks.
     */
    onLoad: function(options) {
        if (this.ready) {
            // call this in the next turn for consistent return before callback
            window.setTimeout(function() {
                options.callback.call(options.scope);                
            }, 0);
        } else if (!this.loading) {
            this.loadScript(options);
        } else {
            this.on({
                ready: options.callback,
                failure: options.errback || Ext.emptyFn,
                scope: options.scope
            });
        }
    },

    /** private: method[onScriptLoad]
     *  Called when all resources required by this plugin type have loaded.
     */
    loadScript: function(options) {

        var params = {
            autoload: Ext.encode({
                modules: [{
                    name: "maps",
                    version: 3.3,
                    nocss: "true",
                    callback: "gxp.plugins.GoogleSource.loader.onScriptLoad",
                    other_params: options.otherParams
                }]
            })
        };
        
        var script = document.createElement("script");
        script.src = "https://www.google.com/jsapi?" + Ext.urlEncode(params);

        // cancel loading if monitor is not ready within timeout
        var errback = options.errback || Ext.emptyFn;
        var timeout = options.timeout || gxp.plugins.GoogleSource.prototype.timeout;
        window.setTimeout((function() {
            if (!gxp.plugins.GoogleSource.loader.ready) {
                this.loading = false;
                this.ready = false;
                document.getElementsByTagName("head")[0].removeChild(script);
                errback.call(options.scope);
                this.fireEvent("failure");
                this.purgeListeners();
            }
        }).createDelegate(this), timeout);
        
        // register callback for ready
        this.on({
            ready: options.callback,
            scope: options.scope
        });

        this.loading = true;

        // The google loader accesses document.body, so we don't add the loader
        // script before the document is ready.
        function append() {
            document.getElementsByTagName("head")[0].appendChild(script);
        }
        if (document.body) {
            append();
        } else {
            Ext.onReady(append);
        }

    }

}))();

Ext.preg(gxp.plugins.GoogleSource.prototype.ptype, gxp.plugins.GoogleSource);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/LayerSource.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = OLSource
 */

/** api: (extends)
 *  plugins/LayerSource.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: OLSource(config)
 *
 *    Plugin for using any ``OpenLayers.Layer`` layers with :class:`gxp.Viewer`
 *    instances.
 *
 *    Configuration for layers from a :class:`gxp.OLSource`:
 *
 *    * type: ``String`` - the CLASS_NAME of an ``OpenLayers.Layer``
 *    * args: ``Array`` - the arguments passed to the layer's constructor
 */
/** api: example
 *  The configuration in the ``sources`` property of the :class:`gxp.Viewer` is
 *  straightforward:
 *
 *  .. code-block:: javascript
 *
 *    "ol": {
 *        ptype: "gxp_olsource"
 *    }
 *
 *  A typical configuration for a layer from this source (in the ``layers``
 *  array of the viewer's ``map`` config option would look like this:
 *
 *  .. code-block:: javascript
 *
 *    {
 *        source: "ol",
 *        type: "OpenLayers.Layer.OSM"
 *        args: ["Mapnik"]
 *    }
 *
 */
gxp.plugins.OLSource = Ext.extend(gxp.plugins.LayerSource, {
    
    /** api: ptype = gxp_olsource */
    ptype: "gxp_olsource",
    
    /** api: method[createLayerRecord]
     *  :arg config:  ``Object``  The application config for this layer.
     *  :returns: ``GeoExt.data.LayerRecord``
     *
     *  Create a layer record given the config.
     */
    createLayerRecord: function(config) {

        var record;
        
        // get class based on type in config
        var Class = window;
        var parts = config.type.split(".");
        for (var i=0, ii=parts.length; i<ii; ++i) {
            Class = Class[parts[i]];
            if (!Class) {
                break;
            }
        }

        // TODO: consider static method on OL classes to construct instance with args
        if (Class && Class.prototype && Class.prototype.initialize) {
            
            // create a constructor for the given layer type
            var Constructor = function() {
                // this only works for args that can be serialized as JSON
                Class.prototype.initialize.apply(this, config.args);
            };
            Constructor.prototype = Class.prototype;

            // create a new layer given type and args
            var layer = new Constructor();

            // apply properties that may have come from saved config
            if ("visibility" in config) {
                layer.visibility = config.visibility;
            }
            
            // create a layer record for this layer
            var Record = GeoExt.data.LayerRecord.create([
                {name: "name", type: "string"},
                {name: "source", type: "string"}, 
                {name: "group", type: "string"},
                {name: "fixed", type: "boolean"},
                {name: "selected", type: "boolean"},
                {name: "type", type: "string"},
                {name: "args"},
                {name: "queryable", type: "boolean"}
            ]);
            var data = {
                layer: layer,
                title: layer.name,
                name: config.name || layer.name,
                source: config.source,
                group: config.group,
                fixed: ("fixed" in config) ? config.fixed : false,
                selected: ("selected" in config) ? config.selected : false,
                queryable: ("queryable" in config) ? config.queryable : false,
                type: config.type,
                args: config.args,
                properties: ("properties" in config) ? config.properties : undefined
            };
            record = new Record(data, layer.id);

        } else {
            throw new Error("Cannot construct OpenLayers layer from given type: " + config.type);
        }
        return record;
    },

    /** api: method[getConfigForRecord]
     *  :arg record: :class:`GeoExt.data.LayerRecord`
     *  :returns: ``Object``
     *
     *  Create a config object that can be used to recreate the given record.
     */
    getConfigForRecord: function(record) {
        // get general config
        var config = gxp.plugins.OLSource.superclass.getConfigForRecord.apply(this, arguments);
        // add config specific to this source
        var layer = record.getLayer();
        return Ext.apply(config, {
            type: record.get("type"),
            args: record.get("args")
        });
    }

});

Ext.preg(gxp.plugins.OLSource.prototype.ptype, gxp.plugins.OLSource);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/LayerSource.js
 * @requires OpenLayers/Layer/TMS.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = MapBoxSource
 */

/** api: (extends)
 *  plugins/LayerSource.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: MapBoxSource(config)
 *
 *    Plugin for using MapBox layers with :class:`gxp.Viewer` instances.
 *    Freely available for commercial and non-commercial use according to the
 *    MapBox terms of service: http://mapbox.com/tos
 *
 *    Available layer names:
 *     * blue-marble-topo-bathy-jan
 *     * blue-marble-topo-bathy-jul
 *     * blue-marble-topo-jan
 *     * blue-marble-topo-jul
 *     * control-room
 *     * geography-class
 *     * natural-earth-hypso
 *     * natural-earth-hypso-bathy
 *     * natural-earth-1
 *     * natural-earth-2
 *     * world-dark
 *     * world-light
 *     * world-print
 *
 */
/** api: example
 *  The configuration in the ``sources`` property of the :class:`gxp.Viewer` is
 *  straightforward:
 *
 *  .. code-block:: javascript
 *
 *    mapbox: {
 *        ptype: "gxp_mapboxsource"
 *    }
 *
 *  A typical configuration for a layer from this source (in the ``layers``
 *  array of the viewer's ``map`` config option would look like this:
 *
 *  .. code-block:: javascript
 *
 *    {
 *        source: "mapbox",
 *        name: "blue-marble-topo-bathy-jan"
 *    }
 *
 */
gxp.plugins.MapBoxSource = Ext.extend(gxp.plugins.LayerSource, {
    
    /** api: ptype = gxp_mapboxsource */
    ptype: "gxp_mapboxsource",

    /** api: property[store]
     *  ``GeoExt.data.LayerStore``. Will contain records with name field values
     *  matching MapBox layer names.
     */
    
    /** api: config[title]
     *  ``String``
     *  A descriptive title for this layer source (i18n).
     */
    title: "MapBox Layers",
    
    /** i18n **/
    blueMarbleTopoBathyJanTitle: "Blue Marble Topography & Bathymetry (January)",
    blueMarbleTopoBathyJulTitle: "Blue Marble Topography & Bathymetry (July)",
    blueMarbleTopoJanTitle: "Blue Marble Topography (January)",
    blueMarbleTopoJulTitle: "Blue Marble Topography (July)",
    controlRoomTitle: "Control Room",
    geographyClassTitle: "Geography Class",
    naturalEarthHypsoTitle: "Natural Earth Hypsometric",
    naturalEarthHypsoBathyTitle: "Natural Earth Hypsometric & Bathymetry",
    naturalEarth1Title: "Natural Earth I",
    naturalEarth2Title: "Natural Earth II",
    worldDarkTitle: "World Dark",
    worldLightTitle: "World Light",
    worldGlassTitle: "World Glass",
    worldPrintTitle: "World Print",

    /** api: method[createStore]
     *
     *  Creates a store of layer records.  Fires "ready" when store is loaded.
     */
    createStore: function() {
        
        var options = {
            projection: "EPSG:900913",
            numZoomLevels: 19,
            serverResolutions: [
                156543.03390625, 78271.516953125, 39135.7584765625,
                19567.87923828125, 9783.939619140625, 4891.9698095703125,
                2445.9849047851562, 1222.9924523925781, 611.4962261962891,
                305.74811309814453, 152.87405654907226, 76.43702827453613,
                38.218514137268066, 19.109257068634033, 9.554628534317017,
                4.777314267158508, 2.388657133579254, 1.194328566789627,
                0.5971642833948135
            ],
            buffer: 1
        };
        
        var configs = [
            {name: "blue-marble-topo-bathy-jan", numZoomLevels: 9},
            {name: "blue-marble-topo-bathy-jul", numZoomLevels: 9},
            {name: "blue-marble-topo-jan", numZoomLevels: 9},
            {name: "blue-marble-topo-jul", numZoomLevels: 9},
            {name: "control-room", numZoomLevels: 9},
            {name: "geography-class", numZoomLevels: 9},
            {name: "natural-earth-hypso", numZoomLevels: 7},
            {name: "natural-earth-hypso-bathy", numZoomLevels: 7},
            {name: "natural-earth-1", numZoomLevels: 7},
            {name: "natural-earth-2", numZoomLevels: 7},
            {name: "world-dark", numZoomLevels: 12},
            {name: "world-light", numZoomLevels: 12},
            {name: "world-glass", numZoomLevels: 11},
            {name: "world-print", numZoomLevels: 10}
        ];
        
        var len = configs.length;
        var layers = new Array(len);
        var config;
        for (var i=0; i<len; ++i) {
            config = configs[i];
            layers[i] = new OpenLayers.Layer.TMS(
                this[OpenLayers.String.camelize(config.name) + "Title"],
                [
                    "http://a.tiles.mapbox.com/mapbox/",
                    "http://b.tiles.mapbox.com/mapbox/",
                    "http://c.tiles.mapbox.com/mapbox/",
                    "http://d.tiles.mapbox.com/mapbox/"
                ],
                OpenLayers.Util.applyDefaults({
                    attribution: /^world/.test(name) ?
                        "<a href='http://mapbox.com'>MapBox</a> | Some Data &copy; OSM CC-BY-SA | <a href='http://mapbox.com/tos'>Terms of Service</a>" :
                        "<a href='http://mapbox.com'>MapBox</a> | <a href='http://mapbox.com/tos'>Terms of Service</a>",
                    type: "png",
                    tileOrigin: new OpenLayers.LonLat(-128 * 156543.03390625, -128 * 156543.03390625),
                    layername: config.name,
                    "abstract": '<div class="thumb-mapbox thumb-mapbox-'+config.name+'"></div>',
                    numZoomLevels: config.numZoomLevels
                }, options)
            );
        }
        
        this.store = new GeoExt.data.LayerStore({
            layers: layers,
            fields: [
                {name: "source", type: "string"},
                {name: "name", type: "string", mapping: "layername"},
                {name: "abstract", type: "string"},
                {name: "group", type: "string"},
                {name: "fixed", type: "boolean"},
                {name: "selected", type: "boolean"}
            ]
        });
        this.fireEvent("ready", this);

    },
    
    /** api: method[createLayerRecord]
     *  :arg config:  ``Object``  The application config for this layer.
     *  :returns: ``GeoExt.data.LayerRecord``
     *
     *  Create a layer record given the config.
     */
    createLayerRecord: function(config) {
        var record;
        var index = this.store.findExact("name", config.name);
        if (index > -1) {

            record = this.store.getAt(index).copy(Ext.data.Record.id({}));
            var layer = record.getLayer().clone();
 
            // set layer title from config
            if (config.title) {
                /**
                 * Because the layer title data is duplicated, we have
                 * to set it in both places.  After records have been
                 * added to the store, the store handles this
                 * synchronization.
                 */
                layer.setName(config.title);
                record.set("title", config.title);
            }

            // set visibility from config
            if ("visibility" in config) {
                layer.visibility = config.visibility;
            }
            
            record.set("selected", config.selected || false);
            record.set("source", config.source);
            record.set("name", config.name);
            if ("group" in config) {
                record.set("group", config.group);
            }

            record.data.layer = layer;
            record.commit();
        }
        return record;
    }

});

Ext.preg(gxp.plugins.MapBoxSource.prototype.ptype, gxp.plugins.MapBoxSource);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @require plugins/LayerSource.js
 * @require OpenLayers/Layer/OSM.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = MapQuestSource
 */

/** api: (extends)
 *  plugins/LayerSource.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: MapQuestSource(config)
 *
 *    Plugin for using MapQuest layers with :class:`gxp.Viewer` instances.
 *
 *    Available layer names are "osm" and "naip"
 */
/** api: example
 *  The configuration in the ``sources`` property of the :class:`gxp.Viewer` is
 *  straightforward:
 *
 *  .. code-block:: javascript
 *
 *    "mapquest": {
 *        ptype: "gxp_mapquestsource"
 *    }
 *
 *  A typical configuration for a layer from this source (in the ``layers``
 *  array of the viewer's ``map`` config option would look like this:
 *
 *  .. code-block:: javascript
 *
 *    {
 *        source: "mapquest",
 *        name: "osm"
 *    }
 *
 */
gxp.plugins.MapQuestSource = Ext.extend(gxp.plugins.LayerSource, {
    
    /** api: ptype = gxp_mapquestsource */
    ptype: "gxp_mapquestsource",

    /** api: property[store]
     *  ``GeoExt.data.LayerStore``. Will contain records with "osm" and
     *  "naip" as name field values.
     */
    
    /** api: config[title]
     *  ``String``
     *  A descriptive title for this layer source (i18n).
     */
    title: "MapQuest Layers",

    /** api: config[osmAttribution]
     *  ``String``
     *  Attribution string for OSM generated layer (i18n).
     */
    osmAttribution: "Tiles Courtesy of <a href='http://open.mapquest.co.uk/' target='_blank'>MapQuest</a> <img src='http://developer.mapquest.com/content/osm/mq_logo.png' border='0'>",

    /** api: config[osmTitle]
     *  ``String``
     *  Title for OSM generated layer (i18n).
     */
    osmTitle: "MapQuest OpenStreetMap",

    /** api: config[naipAttribution]
     *  ``String``
     *  Attribution string for NAIP generated layer (i18n).
     */
    naipAttribution: "Tiles Courtesy of <a href='http://open.mapquest.co.uk/' target='_blank'>MapQuest</a> <img src='http://developer.mapquest.com/content/osm/mq_logo.png' border='0'>",

    /** api: config[naipTitle]
     *  ``String``
     *  Title for NAIP generated layer (i18n).
     */
    naipTitle: "MapQuest Imagery",

    /** api: method[createStore]
     *
     *  Creates a store of layer records.  Fires "ready" when store is loaded.
     */
    createStore: function() {
        
        var options = {
            projection: "EPSG:900913",
            maxExtent: new OpenLayers.Bounds(
                -128 * 156543.0339, -128 * 156543.0339,
                128 * 156543.0339, 128 * 156543.0339
            ),
            maxResolution: 156543.03390625,
            numZoomLevels: 19,
            units: "m",
            buffer: 1,
            transitionEffect: "resize",
            tileOptions: {crossOriginKeyword: null}
        };
        
        var layers = [
            new OpenLayers.Layer.OSM(
                this.osmTitle,
                [
                    "http://otile1.mqcdn.com/tiles/1.0.0/map/${z}/${x}/${y}.png",
                    "http://otile2.mqcdn.com/tiles/1.0.0/map/${z}/${x}/${y}.png",
                    "http://otile3.mqcdn.com/tiles/1.0.0/map/${z}/${x}/${y}.png",
                    "http://otile4.mqcdn.com/tiles/1.0.0/map/${z}/${x}/${y}.png"
                ],
                OpenLayers.Util.applyDefaults({                
                    attribution: this.osmAttribution,
                    type: "osm"
                }, options)
            ),
            new OpenLayers.Layer.OSM(
                this.naipTitle,
                [
                    "http://otile1.mqcdn.com/tiles/1.0.0/sat/${z}/${x}/${y}.png",
                    "http://otile2.mqcdn.com/tiles/1.0.0/sat/${z}/${x}/${y}.png",
                    "http://otile3.mqcdn.com/tiles/1.0.0/sat/${z}/${x}/${y}.png",
                    "http://otile4.mqcdn.com/tiles/1.0.0/sat/${z}/${x}/${y}.png"
                ],
                OpenLayers.Util.applyDefaults({
                    attribution: this.naipAttribution,
                    type: "naip"
                }, options)
            )
        ];
        
        this.store = new GeoExt.data.LayerStore({
            layers: layers,
            fields: [
                {name: "source", type: "string"},
                {name: "name", type: "string", mapping: "type"},
                {name: "abstract", type: "string", mapping: "attribution"},
                {name: "group", type: "string", defaultValue: "background"},
                {name: "fixed", type: "boolean", defaultValue: true},
                {name: "selected", type: "boolean"}
            ]
        });
        this.store.each(function(l) {
            l.set("group", "background");
        });
        this.fireEvent("ready", this);

    },
    
    /** api: method[createLayerRecord]
     *  :arg config:  ``Object``  The application config for this layer.
     *  :returns: ``GeoExt.data.LayerRecord``
     *
     *  Create a layer record given the config.
     */
    createLayerRecord: function(config) {
        var record;
        var index = this.store.findExact("name", config.name);
        if (index > -1) {

            record = this.store.getAt(index).copy(Ext.data.Record.id({}));
            var layer = record.getLayer().clone();
 
            // set layer title from config
            if (config.title) {
                /**
                 * Because the layer title data is duplicated, we have
                 * to set it in both places.  After records have been
                 * added to the store, the store handles this
                 * synchronization.
                 */
                layer.setName(config.title);
                record.set("title", config.title);
            }

            // set visibility from config
            if ("visibility" in config) {
                layer.visibility = config.visibility;
            }
            
            record.set("selected", config.selected || false);
            record.set("source", config.source);
            record.set("name", config.name);
            if ("group" in config) {
                record.set("group", config.group);
            }

            record.data.layer = layer;
            record.commit();
        }
        return record;
    }

});

Ext.preg(gxp.plugins.MapQuestSource.prototype.ptype, gxp.plugins.MapQuestSource);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/WMSSource.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = CatalogueSource
 */

/** api: (extends)
 *  plugins/WMSSource.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: CatalogueSource(config)
 *
 *    Base class for catalogue sources uses for search.
 */
gxp.plugins.CatalogueSource = Ext.extend(gxp.plugins.WMSSource, {

    /** api: config[url]
     *  ``String`` Online resource of the catalogue service.
     */
    url: null,

    /** api: config[yx]
     *  ``Object`` Members in the yx object are used to determine if a CRS URN
     *     corresponds to a CRS with y,x axis order.  Member names are CRS URNs
     *     and values are boolean.
     */
    yx: null,

    /** api: config[title]
     *  ``String`` Optional title for this source.
     */
    title: null,

    /** private: property[lazy]
     *  ``Boolean`` This source always operates lazy so without GetCapabilities
     */
    lazy: true,

    /** api: config[hidden]
     *  ``Boolean`` Normally we do not want these sources to show up in the
     *  AddLayers dialog for the source combobox. Set to false for a certain 
     *  source to show up anyway whenever that makes sense, e.g. by using a
     *  catalogue source to retrieve all the layers for a capabilities grid.
     */
    hidden: true,

    /** api: config[proxyOptions]
     *  ``Object``
     *  An optional object to pass to the constructor of the ProtocolProxy.
     *  This can be used e.g. to set listeners.
     */
    proxyOptions: null,

    /** api: method[describeLayer]
     *  :arg rec: ``GeoExt.data.LayerRecord`` the layer to issue a WMS
     *      DescribeLayer request for
     *  :arg callback: ``Function`` Callback function. Will be called with
     *      an ``Ext.data.Record`` from a ``GeoExt.data.DescribeLayerStore``
     *      as first argument, or false if the WMS does not support
     *      DescribeLayer.
     *  :arg scope: ``Object`` Optional scope for the callback.
     *
     *  Get a DescribeLayer response from this source's WMS.
     */
    describeLayer: function(rec, callback, scope) {
        // it makes no sense to keep a describeLayerStore since
        // everything is lazy and layers can come from different WMSs.
        var recordType = Ext.data.Record.create(
            [
                {name: "owsType", type: "string"},
                {name: "owsURL", type: "string"},
                {name: "typeName", type: "string"}
            ]
        );
        var record = new recordType({
            owsType: "WFS",
            owsURL: rec.get('url'),
            typeName: rec.get('name')
        });
        callback.call(scope, record);
    },

    /** private: method[destroy]
     */
    destroy: function() {
        this.store && this.store.destroy();
        this.store = null;
        gxp.plugins.CatalogueSource.superclass.destroy.apply(this, arguments);
    }

    /** api: method[getPagingStart]
     *  :return: ``Integer`` Where does paging start at?
     *
     *  To be implemented by subclasses
     */

    /** api: method[getPagingParamNames]
     *  :return: ``Object`` with keys start and limit.
     *
     *  Get the names of the parameters to use for paging.
     *
     *  To be implemented by subclasses
     */

    /** api: method[filter]
     *  Filter the store by querying the catalogue service.
     *  :param options: ``Object`` An object with the following keys:
     *
     * .. list-table::
     *     :widths: 20 80
     * 
     *     * - ``queryString``
     *       - the search string
     *     * - ``limit`` 
     *       - the maximum number of records to retrieve
     *     * - ``filters``
     *       - additional filters to include in the query
     *
     *  To be implemented by subclasses
     */

});

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/CatalogueSource.js
 * @requires GeoExt/data/CSWRecordsReader.js
 * @requires GeoExt/data/ProtocolProxy.js
 * @requires OpenLayers/Protocol/CSW/v2_0_2.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = CSWCatalogueSource
 */

/** api: (extends)
 *  plugins/CatalogueSource.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: CSWCatalogueSource(config)
 *
 *    Plugin for creating WMS layers lazily. The difference with the WMSSource
 *    is that the url is configured on the layer not on the source. This means
 *    that this source can create WMS layers for any url. This is particularly
 *    useful when working against a Catalogue Service, such as a OGC:CS-W.
 */
gxp.plugins.CSWCatalogueSource = Ext.extend(gxp.plugins.CatalogueSource, {

    /** api: ptype = gxp_cataloguesource */
    ptype: "gxp_cataloguesource",

    /** api: method[createStore]
     *  Create the store that will be used for the CS-W searches.
     */
    createStore: function() {
        this.store = new Ext.data.Store({
            proxy: new GeoExt.data.ProtocolProxy(Ext.apply({
                setParamsAsOptions: true,
                protocol: new OpenLayers.Protocol.CSW({
                    url: this.url
                })
            }, this.proxyOptions || {})),
            reader: new GeoExt.data.CSWRecordsReader({
                fields: ['title', 'abstract', 'URI', 'bounds', 'projection', 'references']
            })
        });
        gxp.plugins.LayerSource.prototype.createStore.apply(this, arguments);
    },

    /** api: method[getPagingStart]
     *  :return: ``Integer`` Where does paging start at?
     */
    getPagingStart: function() {
        return 1;
    },

    /** api: method[getPagingParamNames]
     *  :return: ``Object`` with keys start and limit.
     *
     *  Get the names of the parameters to use for paging.
     */
    getPagingParamNames: function() {
        return {
            start: 'startPosition',
            limit: 'maxRecords'
        };
    },

    /** private: method[getFullFilter]
     *  :arg filter: ``OpenLayers.Filter`` The filter to add to the other existing 
     *  filters. This is normally the free text search filter.
     *  :arg otherFilters: ``Array``
     *  :returns: ``OpenLayers.Filter`` The combined filter.
     *
     *  Get the filter to use in the CS-W query.
     */
    getFullFilter: function(filter, otherFilters) {
        var filters = [];
        if (filter !== undefined) {
            filters.push(filter);
        }
        filters = filters.concat(otherFilters);
        if (filters.length <= 1) {
            return filters[0];
        } else {
            return new OpenLayers.Filter.Logical({
                type: OpenLayers.Filter.Logical.AND,
                filters: filters
            });
        }
    },

    /** api: method[filter]
     *  Filter the store by querying the catalogue service.
     *  :param options: ``Object`` An object with the following keys:
     *
     * .. list-table::
     *     :widths: 20 80
     * 
     *     * - ``queryString``
     *       - the search string
     *     * - ``limit`` 
     *       - the maximum number of records to retrieve
     *     * - ``filters``
     *       - additional filters to include in the query
     */
    filter: function(options) {
        var filter = undefined;
        if (options.queryString !== "") {
            filter = new OpenLayers.Filter.Comparison({
                type: OpenLayers.Filter.Comparison.LIKE,
                matchCase: false,
                property: 'csw:AnyText',
                value: '*' + options.queryString + '*'
            });
        }
        var data = {
            "resultType": "results",
            "maxRecords": options.limit,
            "Query": {
                "typeNames": "gmd:MD_Metadata",
                "ElementSetName": {
                    "value": "full"
                }
            }
        };
        var fullFilter = this.getFullFilter(filter, options.filters);
        if (fullFilter !== undefined) {
            Ext.apply(data.Query, {
                "Constraint": {
                    version: "1.1.0",
                    Filter: fullFilter
                }
            });
        }
        Ext.apply(this.store.baseParams, data);
        this.store.load();
    }

});

Ext.preg(gxp.plugins.CSWCatalogueSource.prototype.ptype, gxp.plugins.CSWCatalogueSource);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/CatalogueSource.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = GeoNodeCatalogueSource
 */

/** api: (extends)
 *  plugins/CatalogueSource.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: GeoNodeCatalogueSource(config)
 *
 *    Plugin for creating WMS layers lazily. The difference with the WMSSource
 *    is that the url is configured on the layer not on the source. This means
 *    that this source can create WMS layers for any url. This is particularly
 *    useful when working against a Catalogue Service, such as GeoNode.
 */
gxp.plugins.GeoNodeCatalogueSource = Ext.extend(gxp.plugins.CatalogueSource, {

    /** api: ptype = gxp_geonodecataloguesource */
    ptype: "gxp_geonodecataloguesource",

    /** api: config[rootProperty]
     *  ``String`` Root property in the JSON response. Defaults to 'results'.
     */
    rootProperty: 'results',

    /** api: config[baseParams]
     *  ``Object`` Optional additional params to send in the requests.
     */
    baseParams: null,

    /** api: config[fields]
     *  ``Array`` Fields to use for the JsonReader. By default the following
     *  fields are provided: title, abstract, bounds and URI. Optionally this 
     *  can be overridden by applications to provide different or additional
     *  mappings.
     */
    fields: [
        {name: "title", convert: function(v) {
            return [v];
        }},
        {name: "abstract", mapping: "description"},
        {name: "bounds", mapping: "bbox", convert: function(v) {
            return {
                left: v.minx,
                right: v.maxx,
                bottom: v.miny,
                top: v.maxy
            };
        }},
        {name: "URI", mapping: "links", convert: function(v) {
            var result = [];
            for (var key in v) {
                result.push({value: v[key].url});
            }
            return result;
        }}
    ],

    /** api: method[createStore]
     *  Create the store that will be used for the GeoNode searches.
     */
    createStore: function() {
        this.store = new Ext.data.Store({
            proxy: new Ext.data.HttpProxy(Ext.apply({
                url: this.url, 
                method: 'GET'
            }, this.proxyOptions || {})),
            baseParams: Ext.apply({
                type: 'layer'
            }, this.baseParams),
            reader: new Ext.data.JsonReader({
                root: this.rootProperty
            }, this.fields)
        });
        gxp.plugins.LayerSource.prototype.createStore.apply(this, arguments);
    },

    /** api: method[getPagingStart]
     *  :return: ``Integer`` Where does paging start at?
     */
    getPagingStart: function() {
        return 0;
    },

    /** api: method[getPagingParamNames]
     *  :return: ``Object`` with keys start and limit.
     *
     *  Get the names of the parameters to use for paging.
     */
    getPagingParamNames: function() {
        return {
            start: 'startIndex',
            limit: 'limit'
        };
    },

    /** api: method[filter]
     *  Filter the store by querying the catalogue service.
     *  :param options: ``Object`` An object with the following keys:
     *
     * .. list-table::
     *     :widths: 20 80
     * 
     *     * - ``queryString``
     *       - the search string
     *     * - ``limit`` 
     *       - the maximum number of records to retrieve
     *     * - ``filters``
     *       - additional filters to include in the query
     */
    filter: function(options) {
        var bbox = undefined;

        // check for the filters property before using it
        if (options.filters !== undefined) {
            for (var i=0, ii=options.filters.length; i<ii; ++i) {
                var f = options.filters[i];
                if (f instanceof OpenLayers.Filter.Spatial) {
                    bbox = f.value.toBBOX();
                    break;
                }
            }
        }
        Ext.apply(this.store.baseParams, {
            'q': options.queryString
        });
        if (options.limit !== undefined) {
            Ext.apply(this.store.baseParams, {
                'limit': options.limit
            });
        }
        if (bbox !== undefined) {
            Ext.apply(this.store.baseParams, {
                'bbox': bbox
            });
        } else {
            delete this.store.baseParams.bbox;
        }
        this.store.load();
    },

    createLayerRecord: function(layerConfig) {
        layerConfig.restUrl = this.restUrl;
        layerConfig.queryable = true;
        return gxp.plugins.GeoNodeCatalogueSource.superclass.createLayerRecord.apply(this, arguments);
    }

});

Ext.preg(gxp.plugins.GeoNodeCatalogueSource.prototype.ptype, gxp.plugins.GeoNodeCatalogueSource);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/LayerSource.js
 * @requires OpenLayers/Layer/TMS.js
 * @requires OpenLayers/Format/TMSCapabilities.js
 */

Ext.ns('gxp.data', 'gxp.plugins');

gxp.data.TMSCapabilitiesReader = Ext.extend(Ext.data.DataReader, {
    constructor: function(meta, recordType) {
        meta = meta || {};
        if (!meta.format) {
            meta.format = new OpenLayers.Format.TMSCapabilities();
        }
        if(typeof recordType !== "function") {
            recordType = GeoExt.data.LayerRecord.create(
                recordType || meta.fields || [
                    {name: "name", type: "string"},
                    {name: "title", type: "string"},
                    {name: "tileMapUrl", type: "string"}
                ]);
        }
        gxp.data.TMSCapabilitiesReader.superclass.constructor.call(
            this, meta, recordType);
    },
    read: function(request) {
        var data = request.responseXML;
        if(!data || !data.documentElement) {
            data = request.responseText;
        }
        return this.readRecords(data);
    },
    readRecords: function(data) {
        var records = [], i, ii, url, proj;
        if (typeof data === "string" || data.nodeType) {
            data = this.meta.format.read(data);
            this.raw = data;
            // a single tileMap, someone supplied a url to a TileMap
            if (!data.tileMaps) {
                if (data.tileSets) {
                    proj = new OpenLayers.Projection(data.srs);
                    if (this.meta.mapProjection.equals(proj)) {
                        var serverResolutions = [];
                        for (i=0, ii=data.tileSets.length; i<ii; ++i) {
                            serverResolutions.push(data.tileSets[i].unitsPerPixel);
                        }
                        url = this.meta.baseUrl;
                        var layerName = url.substring(
                            url.indexOf(this.meta.version) + this.meta.version.length + 1,
                            url.lastIndexOf('/'));
                        records.push(new this.recordType({
                            layer: new OpenLayers.Layer.TMS(
                                data.title,
                                data.tileMapService.replace("/" + this.meta.version, ""), {
                                    serverResolutions: serverResolutions,
                                    type: data.tileFormat.extension,
                                    layername: layerName
                                }
                            ),
                            title: data.title,
                            name: data.title,
                            tileMapUrl: this.meta.baseUrl
                        }));
                    }
                }
            } else {
                for (i=0, ii=data.tileMaps.length; i<ii; ++i) {
                    var tileMap = data.tileMaps[i];
                    proj = new OpenLayers.Projection(tileMap.srs);
                    if (this.meta.mapProjection.equals(proj)) {
                        url = tileMap.href;
                        var layername = url.substring(url.indexOf(this.meta.version + '/') + 6);
                        records.push(new this.recordType({
                            layer: new OpenLayers.Layer.TMS(
                                tileMap.title, 
                                (this.meta.baseUrl.indexOf(this.meta.version) !== -1) ? this.meta.baseUrl.replace(this.meta.version + '/', '') : this.meta.baseUrl, {
                                    layername: layername
                                }
                            ),
                            title: tileMap.title,
                            name: tileMap.title,
                            tileMapUrl: url
                        }));
                    }
                }
            }
        }
        return {
            totalRecords: records.length,
            success: true,
            records: records
        };
    }
});

/** api: (define)
 *  module = gxp.plugins
 *  class = TMSSource
 */

/** api: (extends)
 *  plugins/LayerSource.js
 */

/** api: constructor
 *  .. class:: TMSSource(config)
 *
 *    Plugin for using TMS layers with :class:`gxp.Viewer` instances. The
 *    plugin issues a Capabilities request to create a store of the TMS's
 *    tile maps. It is currently not supported to use this source type directly
 *    in the viewer config, it is only used to add a TMS service dynamically
 *    through the AddLayers plugin.
 */
gxp.plugins.TMSSource = Ext.extend(gxp.plugins.LayerSource, {

    /** api: ptype = gxp_tmssource */
    ptype: "gxp_tmssource",

    /** api: config[url]
     *  ``String`` TMS service URL for this source
     */

    /** api: config[version]
     *  ``String`` TMS version to use, defaults to 1.0.0
     */
    version: "1.0.0",

    /** private: method[constructor]
     */
    constructor: function(config) {
        gxp.plugins.TMSSource.superclass.constructor.apply(this, arguments);
        this.format = new OpenLayers.Format.TMSCapabilities();
        if (this.url.slice(-1) !== '/') {
            this.url = this.url + '/';
        }
    },

    /** api: method[createStore]
     *
     *  Creates a store of layer records.  Fires "ready" when store is loaded.
     */
    createStore: function() {
        var format = this.format;
        this.store = new Ext.data.Store({
            autoLoad: true,
            listeners: {
                load: function() {
                    this.title = this.store.reader.raw.title;
                    this.fireEvent("ready", this);
                },
                exception: function() {
                    var msg = "Trouble creating TMS layer store from response.";
                    var details = "Unable to handle response.";
                    this.fireEvent("failure", this, msg, details);
                },
                scope: this
            },
            proxy: new Ext.data.HttpProxy({
                url: this.url.indexOf(this.version) === -1 ? this.url + this.version : this.url,
                disableCaching: false,
                method: "GET"
            }),
            reader: new gxp.data.TMSCapabilitiesReader({
                baseUrl: this.url, 
                version: this.version, 
                mapProjection: this.getMapProjection()
            })
        });
    },

    /** api: method[createLayerRecord]
     *  :arg config:  ``Object``  The application config for this layer.
     *  :returns: ``GeoExt.data.LayerRecord`` or null when the source is lazy.
     *
     *  Create a layer record given the config.
     */
    createLayerRecord: function(config, callback, scope) {
        var index = this.store.findExact("name", config.name);
        if (index > -1) {
            var record = this.store.getAt(index);
            var layer = record.getLayer();
            if (layer.serverResolutions !== null) {
                return record;
            } else {
                Ext.Ajax.request({
                    url: record.get('tileMapUrl'),
                    success: function(response) {
                        var serverResolutions = [];
                        var info = this.format.read(response.responseText);
                        for (var i=0, ii=info.tileSets.length; i<ii; ++i) {
                            serverResolutions.push(info.tileSets[i].unitsPerPixel);
                        }
                        layer.addOptions({
                            serverResolutions: serverResolutions,
                            type: info.tileFormat.extension
                        });
                        this.target.createLayerRecord({
                            source: this.id,
                            name: config.name
                        }, callback, scope);
                    },
                    scope: this
                });
            }
        }
    }

});

Ext.preg(gxp.plugins.TMSSource.prototype.ptype, gxp.plugins.TMSSource);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = StyleWriter
 *  base_link = `Ext.util.Observable <http://extjs.com/deploy/dev/docs/?class=Ext.util.Observable>`_
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: StyleWriter(config)
 *   
 *      Base class for plugins that plug into :class:`gxp.WMSStylesDialog` or
 *      similar classes that have a ``layerRecord`` and a ``stylesStore`` with
 *      a ``userStyle`` field. The plugin provides a save method, which will 
 *      persist style changes from the ``stylesStore`` to the server and
 *      associate them with the layer referenced in the target's
 *      ``layerRecord``.
 */
gxp.plugins.StyleWriter = Ext.extend(Ext.util.Observable, {
    
    /** private: property[target]
     *  ``Object``
     *  The object that this plugin is plugged into.
     */
    
    /** api: property[deletedStyles]
     *  ``Array(String)`` style names of styles from the server that were
     *  deleted and have to be removed from the server
     */
    deletedStyles: null,
    
    /** private: method[constructor]
     */
    constructor: function(config) {
        this.initialConfig = config;
        Ext.apply(this, config);
        
        this.deletedStyles = [];
        
        gxp.plugins.StyleWriter.superclass.constructor.apply(this, arguments);
    },
    
    /** private: method[init]
     *  :arg target: ``Object`` The object initializing this plugin.
     */
    init: function(target) {
        this.target = target;
        
        // keep track of removed style records, because Ext.Store does not.
        target.stylesStore.on({
            "remove": function(store, record, index) {
                var styleName = record.get("name");
                // only proceed if the style comes from the server
                record.get("name") === styleName &&
                    this.deletedStyles.push(styleName);
            },
            scope: this
        });
        
        target.on({
            "beforesaved": this.write,
            scope: this
        });
    },
    
    /** private: method[write]
     *  :arg target: :class:`gxp.WMSStylesDialog`
     *  :arg options: ``Object``
     *
     *  Listener for the target's ``beforesaved`` event. Saves the styles of
     *  the target's ``layerRecord``. To be implemented by subclasses.
     *  Subclasses should make sure to commit changes to the target's
     *  stylesStore. It is the responsibility of the application to update
     *  displayed layers with the new style set in the target's
     *  ``selectedStyle`` record.
     */
    write: function(target, options) {
        target.stylesStore.commitChanges();
        target.fireEvent("saved", target, target.selectedStyle.get("name"));
    }

});

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires util.js
 * @requires plugins/StyleWriter.js
 */

Ext.namespace("gxp.plugins");

/** api: (define)
 *  module = gxp.plugins
 *  class = GeoServerStyleWriter
 */

/** api: (extends)
 *  plugins/StyleWriter.js
 */

/** api: constructor
 *  .. class:: GeoServerStyleWriter(config)
 *   
 *      Save styles from :class:`gxp.WMSStylesDialog` or similar classes that
 *      have a ``layerRecord`` and a ``stylesStore`` with a ``userStyle``
 *      field. The plugin provides a save method, which will use the GeoServer
 *      RESTConfig API to persist style changes from the ``stylesStore`` to the
 *      server and associate them with the layer referenced in the target's
 *      ``layerRecord``.
 */
gxp.plugins.GeoServerStyleWriter = Ext.extend(gxp.plugins.StyleWriter, {
    
    /** api: config[baseUrl]
     *  ``String``
     *  The base url for the GeoServer REST API. Default is "/geoserver/rest".
     */
    baseUrl: "/geoserver/rest",
    
    /** private: method[constructor]
     */
    constructor: function(config) {
        this.initialConfig = config;
        Ext.apply(this, config);
        
        gxp.plugins.GeoServerStyleWriter.superclass.constructor.apply(this, arguments);
    },
    
    /** api: method[write]
     *  :arg options: ``Object``
     *
     *  Saves the styles of the target's ``layerRecord`` using GeoServer's
     *  RESTconfig API.
     *  
     *  Supported options:
     *
     *  * defaultStyle - ``String`` If set, the default style will be set.
     *  * success - ``Function`` A function to call when all styles were
     *    written successfully.
     *  * scope - ``Object`` A scope to call the ``success`` function with.
     */
    write: function(options) {
        delete this._failed;
        options = options || {};
        var dispatchQueue = [];
        var store = this.target.stylesStore;
        store.each(function(rec) {
            (rec.phantom || store.modified.indexOf(rec) !== -1) &&
                this.writeStyle(rec, dispatchQueue);
        }, this);
        var success = function() {
            var target = this.target;
            if (this._failed !== true) {
                // we don't need any callbacks for deleting styles.
                this.deleteStyles();
                var modified = this.target.stylesStore.getModifiedRecords();
                for (var i=modified.length-1; i>=0; --i) {
                    // mark saved
                    modified[i].phantom = false;
                }
                target.stylesStore.commitChanges();
                options.success && options.success.call(options.scope);
                target.fireEvent("saved", target, target.selectedStyle.get("name"));
            } else {
                target.fireEvent("savefailed", target, target.selectedStyle.get("name"));
            }
        };
        if(dispatchQueue.length > 0) {
            gxp.util.dispatch(dispatchQueue, function() {
                this.assignStyles(options.defaultStyle, success);
            }, this);
        } else {
            this.assignStyles(options.defaultStyle, success);
        }
    },
    
    /** private: method[writeStyle] 
     *  :arg styleRec: ``Ext.data.Record`` the record from the target's
     *      ``stylesStore`` to write
     *  :arg dispatchQueue: ``Array(Function)`` the dispatch queue the write
     *      function is added to.
     * 
     *  This method does not actually write styles, it just adds a function to
     *  the provided ``dispatchQueue`` that will do so.
     */
    writeStyle: function(styleRec, dispatchQueue) {
        var styleName = styleRec.get("userStyle").name;
        dispatchQueue.push(function(callback, storage) {
            Ext.Ajax.request({
                method: styleRec.phantom === true ? "POST" : "PUT",
                url: this.baseUrl + "/styles" + (styleRec.phantom === true ?
                    "" : "/" + styleName + ".xml"),
                headers: {
                    "Content-Type": "application/vnd.ogc.sld+xml; charset=UTF-8"
                },
                xmlData: this.target.createSLD({
                    userStyles: [styleName]
                }),
                failure: function() {
                    this._failed = true;
                    callback.call(this);
                },
                success: styleRec.phantom === true ? function(){
                    Ext.Ajax.request({
                        method: "POST",
                        url: this.baseUrl + "/layers/" +
                            this.target.layerRecord.get("name") + "/styles.json",
                        jsonData: {
                            "style": {
                                "name": styleName
                            }
                        },
                        failure: function() {
                            this._failed = true;
                            callback.call(this);
                        },
                        success: callback,
                        scope: this
                    });
                } : callback,
                scope: this
            });
        });
    },

    /** private: method[assignStyles]
     *  :arg defaultStyle: ``String`` The default style. Optional.
     *  :arg callback: ``Function`` The function to call when all operations
     *      succeeded. Will be called in the scope of this instance. Optional.
     */
    assignStyles: function(defaultStyle, callback) {
        var styles = [];
        this.target.stylesStore.each(function(rec) {
            if (!defaultStyle && rec.get("userStyle").isDefault === true) {
                defaultStyle = rec.get("name");
            }
            if (rec.get("name") !== defaultStyle &&
                                this.deletedStyles.indexOf(rec.id) === -1) {
                styles.push({"name": rec.get("name")});
            }
        }, this);
        Ext.Ajax.request({
            method: "PUT",
            url: this.baseUrl + "/layers/" +
                this.target.layerRecord.get("name") + ".json",
            jsonData: {
                "layer": {
                    "defaultStyle": {
                        "name": defaultStyle
                    },
                    "styles": styles.length > 0 ? {
                        "style": styles
                    } : {},
                    "enabled": true
                }
            },
            success: callback,
            failure: function() {
                this._failed = true;
                callback.call(this);
            },
            scope: this
        });
    },
    
    /** private: method[deleteStyles]
     *  Deletes styles that are no longer assigned to the layer.
     */
    deleteStyles: function() {
        for (var i=0, len=this.deletedStyles.length; i<len; ++i) {
            Ext.Ajax.request({
                method: "DELETE",
                url: this.baseUrl + "/styles/" + this.deletedStyles[i] +
                    // cannot use params for DELETE requests without jsonData
                    "?purge=true"
            });
        }
        this.deletedStyles = [];
    }

});

/** api: ptype = gxp_geoserverstylewriter */
Ext.preg("gxp_geoserverstylewriter", gxp.plugins.GeoServerStyleWriter);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires GeoExt/widgets/Action.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = Tool
 *  base_link = `Ext.util.Observable <http://extjs.com/deploy/dev/docs/?class=Ext.util.Observable>`_
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: Tool(config)
 *
 *    Base class for plugins that add tool functionality to
 *    :class:`gxp.Viewer`. These plugins are used by adding configuration 
 *    objects for them to the ``tools`` array of the viewer's config object,
 *    using their ``ptype``.
 */   
gxp.plugins.Tool = Ext.extend(Ext.util.Observable, {
    
    /** api: ptype = gxp_tool */
    ptype: "gxp_tool",
    
    /** api: config[autoActivate]
     *  ``Boolean`` Set to false if the tool should be initialized without
     *  activating it. Default is true.
     */
    autoActivate: true,
    
    /** api: property[active]
     *  ``Boolean`` Is the tool currently active?
     */

    /** api: config[actions]
     *  ``Array`` Custom actions for tools that do not provide their own. Array
     *  elements are expected to be valid Ext config objects or strings
     *  referencing a valid Ext component. Actions provided here may have
     *  additional ``menuText`` and ``buttonText`` properties. The former
     *  will be used as text when the action is used in a menu. The latter will
     *  be conditionally used on buttons, only if ``showButtonText`` is set to
     *  true. The native ``text`` property will unconditionally be used for
     *  buttons. Optional, only needed to create custom actions.
     */
    
    /** api: config[outputAction]
     *  ``Number`` The ``actions`` array index of the action that should
     *  trigger this tool's output. Only valid if ``actions`` is configured.
     *  Leave this unconfigured if none of the ``actions`` should trigger this
     *  tool's output.
     */
    
    /** api: config[actionTarget]
     *  ``Object`` or ``String`` or ``Array`` Where to place the tool's actions 
     *  (e.g. buttons or menus)? 
     *
     *  In case of a string, this can be any string that references an 
     *  ``Ext.Container`` property on the portal, or a unique id configured on a 
     *  component.
     *
     *  In case of an object, the object has a "target" and an "index" property, 
     *  so that the tool can be inserted at a specified index in the target. 
     *               
     *  actionTarget can also be an array of strings or objects, if the action is 
     *  to be put in more than one place (e.g. a button and a context menu item).
     *
     *  To reference one of the toolbars of an ``Ext.Panel``, ".tbar", ".bbar" or 
     *  ".fbar" has to be appended. The default is "map.tbar". The viewer's main 
     *  MapPanel can always be accessed with "map" as actionTarget. Set to null if 
     *  no actions should be created.
     *
     *  Some tools provide a context menu. To reference this context menu as
     *  actionTarget for other tools, configure an id in the tool's
     *  outputConfig, and use the id with ".contextMenu" appended. In the
     *  snippet below, a layer tree is created, with a "Remove layer" action
     *  as button on the tree's top toolbar, and as menu item in its context
     *  menu:
     *
     *  .. code-block:: javascript
     *
     *     {
     *         xtype: "gxp_layertree",
     *         outputConfig: {
     *             id: "tree",
     *             tbar: []
     *         }
     *     }, {
     *         xtype: "gxp_removelayer",
     *         actionTarget: ["tree.tbar", "tree.contextMenu"]
     *     }
     *
     *  If a tool has both actions and output, and you want to force it to
     *  immediately output to a container, set actionTarget to null. If you
     *  want to hide the actions, set actionTarget to false. In this case, you
     *  should configure a defaultAction to make sure that an action is active.
     */
    actionTarget: "map.tbar",
    
    /** api: config[showButtonText]
     *  Show the ``buttonText`` an action is configured with, if used as a
     *  button. Default is false.
     */
    showButtonText: false,
        
    /** api: config[toggleGroup]
     *  ``String`` If this tool should be radio-button style toggled with other
     *  tools, this string is to identify the toggle group.
     */
    
    /** api: config[defaultAction]
     *  ``Number`` Optional index of an action that should be active by
     *  default. Only works for actions that are a ``GeoExt.Action`` instance.
     */
    
    /** api: config[outputTarget]
     *  ``String`` Where to add the tool's output container? This can be any
     *  string that references an ``Ext.Container`` property on the portal, or
     *  "map" to access the viewer's main map. If not provided, a window will
     *  be created. To reference one of the toolbars of an ``Ext.Panel``,
     *  ".tbar", ".bbar" or ".fbar" has to be appended.
     */
     
    /** api: config[outputConfig]
     *  ``Object`` Optional configuration for the output container. This may
     *  be useful to override the xtype (e.g. "window" instead of "gx_popup"),
     *  or to provide layout configurations when rendering to an
     *  ``outputTarget``.
     */

    /** api: config[controlOptions]
     *  ``Object`` If this tool is associated with an ``OpenLayers.Control``
     *  then this is an optional object to pass to the constructor of the
     *  associated ``OpenLayers.Control``.
     */
    
    /** private: property[target]
     *  ``Object``
     *  The :class:`gxp.Viewer` that this plugin is plugged into.
     */
     
    /** private: property[actions]
     *  ``Array`` The actions this tool has added to viewer components.
     */
    
    /** private: property[output]
     *  ``Array`` output added by this container
     */
    output: null,
     
    /** private: method[constructor]
     */
    constructor: function(config) {
        this.initialConfig = config || {};
        this.active = false;
        Ext.apply(this, config);
        if (!this.id) {
            this.id = Ext.id();
        }
        this.output = [];
        
        this.addEvents(
            /** api: event[activate]
             *  Fired when the tool is activated.
             *
             *  Listener arguments:
             *  * tool - :class:`gxp.plugins.Tool` the activated tool
             */
            "activate",

            /** api: event[deactivate]
             *  Fired when the tool is deactivated.
             *
             *  Listener arguments:
             *  * tool - :class:`gxp.plugins.Tool` the deactivated tool
             */
            "deactivate"
        );
        
        gxp.plugins.Tool.superclass.constructor.apply(this, arguments);
    },
    
    /** private: method[init]
     *  :arg target: ``Object`` The object initializing this plugin.
     */
    init: function(target) {
        target.tools[this.id] = this;
        this.target = target;
        this.autoActivate && this.activate();
        this.target.on("portalready", this.addActions, this);
    },
    
    /** api: method[activate]
     *  :returns: ``Boolean`` true when this tool was activated
     *
     *  Activates this tool.
     */
    activate: function() {
        if (this.active === false) {
            this.active = true;
            this.fireEvent("activate", this);
            return true;
        }
    },
    
    /** api: method[deactivate]
     *  :returns: ``Boolean`` true when this tool was deactivated
     *
     *  Deactivates this tool.
     */
    deactivate: function() {
        if (this.active === true) {
            this.active = false;
            this.fireEvent("deactivate", this);
            return true;
        }
    },
    
    /** private: method[getContainer]
     *  :arg target: ``String`` A reference as described for :obj:`actionTarget`
     *      and :obj:`outputTarget`
     *  :returns: ``Ext.Component`` The container reference matching the target.
     */
    getContainer: function(target) {
        var ct, item, meth,
            parts = target.split("."),
            ref = parts[0];
        if (ref) {
            if (ref == "map") {
                ct = this.target.mapPanel;
            } else {
                ct = Ext.getCmp(ref) || this.target.portal[ref];
                if (!ct) {
                    throw new Error("Can't find component with id: " + ref);
                }
            }
        } else {
            ct = this.target.portal;
        }
        item = parts.length > 1 && parts[1];
        if (item) {
            meth = {
                "tbar": "getTopToolbar",
                "bbar": "getBottomToolbar",
                "fbar": "getFooterToolbar"
            }[item];
            if (meth) {
                ct = ct[meth]();
            } else {
                ct = ct[item];
            }
        }
        return ct;
    },
    
    /** api: method[addActions]
     *  :arg actions: ``Array`` Optional actions to add. If not provided,
     *      this.actions will be added.
     *  :returns: ``Array`` The actions added.
     */
    addActions: function(actions) {
        actions = actions || this.actions;
        if (!actions || this.actionTarget === null) {
            // add output immediately if we have no actions to trigger it
            this.removeOutput();
            this.addOutput(this.outputConfig);
            return;
        }
        
        var actionTargets = this.actionTarget instanceof Array ?
            this.actionTarget : [this.actionTarget];
        var a = actions instanceof Array ? actions : [actions];
        var action, actionTarget, cmp, i, j, jj, ct, index = null;
        for (i=actionTargets.length-1; i>=0; --i) {
            actionTarget = actionTargets[i];
            if (actionTarget) {
                if (actionTarget instanceof Object) {
                    index = actionTarget.index;
                    actionTarget = actionTarget.target;
                }
                ct = this.getContainer(actionTarget);
            }
            for (j=0, jj=a.length; j<jj; ++j) {
                if (!(a[j] instanceof Ext.Action || a[j] instanceof Ext.Component)) {
                    cmp = Ext.getCmp(a[j]);
                    if (cmp) {
                        a[j] = cmp;
                    }
                    if (typeof a[j] != "string") {
                        if (j == this.defaultAction) {
                            a[j].pressed = true;
                        }
                        a[j] = new Ext.Action(a[j]);
                    }
                }
                action = a[j];
                if (j == this.defaultAction && action instanceof GeoExt.Action) {
                    action.isDisabled() ?
                        action.activateOnEnable = true :
                        action.control.activate();
                }
                if (ct) {
                    if (this.showButtonText) {
                        action.setText(action.initialConfig.buttonText);
                    }
                    if (ct instanceof Ext.menu.Menu) {
                        action = Ext.apply(new Ext.menu.CheckItem(action), {
                            text: action.initialConfig.menuText,
                            group: action.initialConfig.toggleGroup,
                            groupClass: null
                        });
                    } else if (!(ct instanceof Ext.Toolbar)) {
                        // only Ext.menu.Menu and Ext.Toolbar containers
                        // support the Action interface. So if our container is
                        // something else, we create a button with the action.
                        action = new Ext.Button(action);
                    }
                    var addedAction = (index === null) ? ct.add(action) : ct.insert(index, action);
                    action = action instanceof Ext.Button ? action : addedAction;
                    if (index !== null) {
                        index += 1;
                    }
                    if (this.outputAction != null && j == this.outputAction) {
                        var cmp;
                        action.on("click", function() {
                            if (cmp) {
                                this.outputTarget ?
                                    cmp.show() : cmp.ownerCt.ownerCt.show();
                            } else {
                                cmp = this.addOutput();
                            }
                        }, this);
                    }
                }
            }
            // call ct.show() in case the container was previously hidden (e.g.
            // the mapPanel's bbar or tbar which are initially hidden)
            if (ct) {
                ct.isVisible() ?
                    ct.doLayout() : ct instanceof Ext.menu.Menu || ct.show();
            }
        }
        this.actions = a;
        return this.actions;
    },
    
    /** api: method[addOutput]
     *  :arg config: ``Object`` configuration for the ``Ext.Component`` to be
     *      added to the ``outputTarget``. Properties of this configuration
     *      will be overridden by the applications ``outputConfig`` for the
     *      tool instance. Tool plugins that want to reuse their output (after
     *      being closed by a window or crumb panel) can also provide an
     *      ``Ext.Component`` instance here, if it was previously created with
     *      ``addOutput``.
     *  :return: ``Ext.Component`` The component added to the ``outputTarget``. 
     *
     *  Adds output to the tool's ``outputTarget``. This method is meant to be
     *  called and/or overridden by subclasses.
     */
    addOutput: function(config) {
        if (!config && !this.outputConfig) {
            // nothing to do here for tools that don't have any output
            return;
        }

        config = config || {};
        var ref = this.outputTarget;
        var container;
        if (ref) {
            container = this.getContainer(ref);
            if (!(config instanceof Ext.Component)) {
                Ext.apply(config, this.outputConfig);
            }
        } else {
            var outputConfig = this.outputConfig || {};
            container = new Ext.Window(Ext.apply({
                hideBorders: true,
                shadow: false,
                closeAction: "hide",
                autoHeight: !outputConfig.height,
                layout: outputConfig.height ? "fit" : undefined,
                items: [{
                    defaults: Ext.applyIf({
                        autoHeight: !outputConfig.height && !(outputConfig.defaults && outputConfig.defaults.height)
                    }, outputConfig.defaults)
                }]
            }, outputConfig)).show().items.get(0);
        }
        if (container) {
            var component = container.add(config);
            component.on("removed", function(cmp) {
                this.output.remove(cmp);
            }, this, {single: true});
            if (component instanceof Ext.Window) {
                component.show();
            } else {
                container.doLayout();
            }
            this.output.push(component);
            return component;
        } else {
            var ptype = this.ptype;
            if (window.console) {
                console.error("Failed to create output for plugin with ptype: " + ptype);
            }
        }
    },
    
    /** api: method[removeOutput]
     *  Removes all output created by this tool
     */
    removeOutput: function() {
        var cmp;
        for (var i=this.output.length-1; i>=0; --i) {
            cmp = this.output[i];
            if (!this.outputTarget) {
                cmp.findParentBy(function(p) {
                    return p instanceof Ext.Window;
                }).close();
            } else {
                if (cmp.ownerCt) {
                    cmp.ownerCt.remove(cmp);
                    if (cmp.ownerCt instanceof Ext.Window) {
                        cmp.ownerCt[cmp.ownerCt.closeAction]();
                    }
                } else {
                    cmp.remove();
                }
            }
        }
        this.output = [];
    },
    
    /** api: method[getState]
     *  :return {Object}
     *  Gets the configured tool state. Overwrite in subclasses to return
     *  anything other than a copy of the initialConfig property.
     */
    getState: function(){
        return Ext.apply({}, this.initialConfig);
    }
});

Ext.preg(gxp.plugins.Tool.prototype.ptype, gxp.plugins.Tool);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 * @requires OpenLayers/Protocol/HTTP.js
 * @requires OpenLayers/Control/SelectFeature.js
 * @requires OpenLayers/Format/WMSGetFeatureInfo.js
 * @requires OpenLayers/Filter/FeatureId.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = ClickableFeatures
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: ClickableFeatures(config)
 *
 *    Base class for tools that need to handle feature clicks. Don't create
 *    instances of this base class. This tool uses a combination of WMS
 *    GetFeatureInfo and WFS GetFeature, because of the better algorithm 
 *    in WMS GetFeatureInfo to return a limited set of features from a crowded 
 *    spot.
 */   
gxp.plugins.ClickableFeatures = Ext.extend(gxp.plugins.Tool, {
    
    /** api: config[featureManager]
     *  ``String`` The id of the :class:`gxp.plugins.FeatureManager` to use
     *  with this tool.
     */
    featureManager: null,
    
    /** api: config[autoLoadFeature]
     *  ``Boolean`` Should this tool load a feature on click? If set to true,
     *  and if there is no loaded feature at the click position, this tool will
     *  call loadFeatures on the ``featureManager``, with a ``FeatureId``
     *  filter created from the id of a feature returned from a WMS
     *  GetFeatureInfo request at the click position. This feature will then be
     *  selected immediately. Default is false.
     */
    autoLoadFeature: false,
    
    /** private: property[autoLoadedFeature]
     *  ``OpenLayers.Feature`` the auto-loaded feature when
     *  :attr:`autoLoadFeature` is true.
     */
    autoLoadedFeature: null,
    
    /** api: config[tolerance]
     *  ``Number`` 
     *  Optional pixel tolerance to use when selecting features.  By default,
     *  the server decides whether a pixel click intersects a feature based on 
     *  its own rules.  If a pixel tolerance is provided, it will be included in
     *  requests for features to inform the server to look in a buffer around 
     *  features.
     */
    
    /** private: property[toleranceParameters]
     *  ``Array``
     *  List of parameter names to use in a GetFeatureInfo request when a 
     * ``tolerance`` is provided.  Default is ["BUFFER", "RADIUS"].
     */
    toleranceParameters: ["BUFFER", "RADIUS"],
    
    /** private: property[selectControl]
     *  ``OpenLayers.Control.SelectFeature`` the SelectFeature control used in
     *  the SelectionModel of the grid. Usually created by subclasses. If not,
     *  then a generic SelectFeature control which is not added to the map
     *  will be created when ``noFeatureClick`` is called for the first time.
     */
    
    /** api: config[controlOptions]
     *  ``Object`` Options for the ``OpenLayers.Control.SelectFeature`` used
     *  with this tool.
     */

    /** private: method[constructor]
     */
    constructor: function(config) {
        // deal with deprecated autoLoadFeatures config option
        //TODO remove this before we cut a release
        if (config && "autoLoadFeatures" in config) {
            config.autoLoadFeature = config.autoLoadFeatures;
            delete config.autoLoadFeatures;
            if (window.console) {
                console.warn("Deprecated config option 'autoLoadFeatures' for ptype: '" + config.ptype + "'. Use 'autoLoadFeature' instead.");
            }
        }
        gxp.plugins.ClickableFeatures.superclass.constructor.apply(this, [config]);
    },
    
    /** private: method[noFeatureClick]
     *  :arg evt: ``Object``
     */
    noFeatureClick: function(evt) {
        if (!this.selectControl) {
            this.selectControl = new OpenLayers.Control.SelectFeature(
                this.target.tools[this.featureManager].featureLayer,
                this.initialConfig.controlOptions
            );
        }
        var evtLL = this.target.mapPanel.map.getLonLatFromPixel(evt.xy);
        var featureManager = this.target.tools[this.featureManager];
        var page = featureManager.page;
        if (featureManager.visible() == "all" && featureManager.paging && page && page.extent.containsLonLat(evtLL)) {
            // no need to load a different page if the clicked location is
            // inside the current page bounds and all features are visible
            return;
        }

        var layer = featureManager.layerRecord && featureManager.layerRecord.getLayer();
        if (!layer) {
            // if the feature manager has no layer currently set, do nothing
            return;
        }
        
        // construct params for GetFeatureInfo request
        // layer is not added to map, so we do this manually
        var map = this.target.mapPanel.map;
        var size = map.getSize();
        var params = Ext.applyIf({
            REQUEST: "GetFeatureInfo",
            BBOX: map.getExtent().toBBOX(),
            WIDTH: size.w,
            HEIGHT: size.h,
            X: parseInt(evt.xy.x),
            Y: parseInt(evt.xy.y),
            QUERY_LAYERS: layer.params.LAYERS,
            INFO_FORMAT: "application/vnd.ogc.gml",
            EXCEPTIONS: "application/vnd.ogc.se_xml",
            FEATURE_COUNT: 1
        }, layer.params);
        if (typeof this.tolerance === "number") {
            for (var i=0, ii=this.toleranceParameters.length; i<ii; ++i) {
                params[this.toleranceParameters[i]] = this.tolerance;
            }
        }

        var projection = map.getProjectionObject();
        var layerProj = layer.projection;
        if (layerProj && layerProj.equals(projection)) {
            projection = layerProj;
        }
        if (parseFloat(layer.params.VERSION) >= 1.3) {
            params.CRS = projection.getCode();
        } else {
            params.SRS = projection.getCode();
        }
        
        var store = new GeoExt.data.FeatureStore({
            fields: {},
            proxy: new GeoExt.data.ProtocolProxy({
                protocol: new OpenLayers.Protocol.HTTP({
                    url: (typeof layer.url === "string") ? layer.url : layer.url[0],
                    params: params,
                    format: new OpenLayers.Format.WMSGetFeatureInfo()
                })
            }),
            autoLoad: true,
            listeners: {
                "load": function(store, records) {
                    if (records.length > 0) {
                        var fid = records[0].get("fid");
                        var filter = new OpenLayers.Filter.FeatureId({
                            fids: [fid] 
                        });

                        var autoLoad = function() {
                            featureManager.loadFeatures(
                                filter, function(features) {
                                    if (features.length) {
                                        this.autoLoadedFeature = features[0];
                                        this.select(features[0]);
                                    }
                                }, this
                            );
                        }.createDelegate(this);
                        
                        var feature = featureManager.featureLayer.getFeatureByFid(fid);                        
                        if (feature) {
                            this.select(feature);
                        } else if (featureManager.paging && featureManager.pagingType === gxp.plugins.FeatureManager.QUADTREE_PAGING) {
                            var lonLat = this.target.mapPanel.map.getLonLatFromPixel(evt.xy);
                            featureManager.setPage({lonLat: lonLat}, function() {
                                var feature = featureManager.featureLayer.getFeatureByFid(fid);
                                if (feature) {
                                    this.select(feature);
                                } else if (this.autoLoadFeature === true) {
                                    autoLoad();
                                }
                            }, this);
                        } else {
                            autoLoad();
                        }
                    }
                },
                scope: this
            }
        });
    },
    
    /** api: method[select]
     *  :arg feature: ``OpenLayers.Feature.Vector``
     *
     *  Action to perform when a feature is selected. The default action is to
     *  unselect existing selections and select the feature using the built-in
     *  SelectFeature control. To be overridden by subclasses.
     */
    select: function(feature) {
        this.selectControl.unselectAll();
        this.selectControl.select(feature);
    }
    
});

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = DeleteSelectedFeatures
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: DeleteSelectedFeatures(config)
 *
 *    Plugin for deleting selected features
 */
gxp.plugins.DeleteSelectedFeatures = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_deleteselectedfeatures */
    ptype: "gxp_deleteselectedfeatures",
    
    /** api: config[deleteMsgTitle]
     *  ``String``
     *  Text for delete confirmation window title (i18n).
     */
    deleteMsgTitle: "Delete",

    /** api: config[deleteFeaturesMsg]
     *  ``String``
     *  Text for delete confirmation message with multiple features (i18n).
     */
    deleteFeaturesMsg: "Are you sure you want to delete {0} selected features?",
    
    /** api: config[deleteFeatureMsg]
     *  ``String``
     *  Text for delete confirmation message with a single feature (i18n).
     */
    deleteFeatureMsg: "Are you sure you want to delete the selected feature?",

    /** api: config[menuText]
     *  ``String``
     *  Text for zoom menu item (i18n).
     */
    menuText: "Delete selected features",
    
    /** api: config[buttonText]
     *  ``String`` Text for the button label
     */

    /** api: config[tooltip]
     *  ``String``
     *  Text for zoom action tooltip (i18n).
     */
    tooltip: "Delete the currently selected features",
    
    /** api: config[featureManager]
     *  ``String`` id of the :class:`gxp.plugins.FeatureManager` to look for
     *  selected features
     */
    
    /** private: property[iconCls]
     */
    iconCls: "delete",
    
    /** api: method[addActions]
     */
    addActions: function() {
        var actions = gxp.plugins.DeleteSelectedFeatures.superclass.addActions.apply(this, [{
            text: this.buttonText,
            menuText: this.menuText,
            iconCls: this.iconCls,
            tooltip: this.tooltip,
            handler: this.deleteFeatures,
            scope: this
        }]);
        actions[0].disable();

        var layer = this.target.tools[this.featureManager].featureLayer;
        layer.events.on({
            "featureselected": function() {
                actions[0].isDisabled() && actions[0].enable();
            },
            "featureunselected": function() {
                layer.selectedFeatures.length == 0 && actions[0].disable();
            }
        });
        
        return actions;
    },
    
    deleteFeatures: function() {
        var featureManager = this.target.tools[this.featureManager];
        var features = featureManager.featureLayer.selectedFeatures;
        Ext.Msg.show({
            title: this.deleteMsgTitle,
            msg: features.length > 1 ?
                String.format(this.deleteFeaturesMsg, features.length) :
                this.deleteFeatureMsg,
            buttons: Ext.Msg.YESNO,
            fn: function(button) {
                if (button === "yes") {
                    var store = featureManager.featureStore;
                    for (var feature, i=features.length-1; i>=0; --i) {
                        feature = features[i];
                        feature.layer.selectedFeatures.remove(feature);
                        feature.layer.events.triggerEvent("featureunselected", {feature: feature});
                        if (feature.state !== OpenLayers.State.INSERT) { // TODO: remove after http://trac.geoext.org/ticket/141
                            feature.state = OpenLayers.State.DELETE; // TODO: remove after http://trac.geoext.org/ticket/141
                            store._removing = true; // TODO: remove after http://trac.geoext.org/ticket/141
                        } // TODO: remove after http://trac.geoext.org/ticket/141
                        store.remove(store.getRecordFromFeature(feature));
                        delete store._removing; // TODO: remove after http://trac.geoext.org/ticket/141
                    }
                    store.save();
                }
            },
            scope: this,
            icon: Ext.MessageBox.QUESTION
        });
    }
        
});

Ext.preg(gxp.plugins.DeleteSelectedFeatures.prototype.ptype, gxp.plugins.DeleteSelectedFeatures);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 * @requires widgets/form/GoogleGeocoderComboBox.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = GoogleGeocoder
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: GoogleGeocoder(config)
 *
 *    Plugin for adding a GoogleGeocoderComboBox to a viewer.  The underlying
 *    GoogleGeocoderComboBox can be configured by setting this tool's 
 *    ``outputConfig`` property. The gxp.form.GoogleGeocoderComboBox requires 
 *    the gxp.plugins.GoogleSource or the Google Maps V3 API to be loaded.
 */
gxp.plugins.GoogleGeocoder = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_googlegeocoder */
    ptype: "gxp_googlegeocoder",

    /** api: config[updateField]
     *  ``String``
     *  If value is specified, when an item is selected in the combo, the map
     *  will be zoomed to the corresponding field value in the selected record.
     *  If ``null``, no map navigation will occur.  Valid values are the field
     *  names described for the :class:`gxp.form.GoogleGeocoderComboBox`.
     *  Default is "viewport".
     */
    updateField: "viewport",
    
    init: function(target) {

        var combo = new gxp.form.GoogleGeocoderComboBox(Ext.apply({
            listeners: {
                select: this.onComboSelect,
                scope: this
            }
        }, this.outputConfig));
        
        var bounds = target.mapPanel.map.restrictedExtent;
        if (bounds && !combo.bounds) {
            target.on({
                ready: function() {
                    combo.bounds = bounds.clone().transform(
                        target.mapPanel.map.getProjectionObject(),
                        new OpenLayers.Projection("EPSG:4326")
                    );
                }
            });
        }
        this.combo = combo;
        
        return gxp.plugins.GoogleGeocoder.superclass.init.apply(this, arguments);

    },

    /** api: method[addOutput]
     */
    addOutput: function(config) {
        return gxp.plugins.GoogleGeocoder.superclass.addOutput.call(this, this.combo);
    },
    
    /** private: method[onComboSelect]
     *  Listener for combo's select event.
     */
    onComboSelect: function(combo, record) {
        if (this.updateField) {
            var map = this.target.mapPanel.map;
            var location = record.get(this.updateField).clone().transform(
                new OpenLayers.Projection("EPSG:4326"),
                map.getProjectionObject()
            );
            if (location instanceof OpenLayers.Bounds) {
                map.zoomToExtent(location, true);
            } else {
                map.setCenter(location);
            }
        }
    }

});

Ext.preg(gxp.plugins.GoogleGeocoder.prototype.ptype, gxp.plugins.GoogleGeocoder);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = GoogleEarth
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: GoogleEarth(config)
 *
 *    Provides an action for switching between normal map view and 
 *    Google Earth view.
 */
/** api: example
 *  This tool can only be used if ``portalItems`` of :class:`gxp.Viewer` is set up 
 *  in the following way (or similar, the requirement is to have a panel with a card
 *  layout which has 2 items: the map and the Google Earth panel):
 *
 *  .. code-block:: javascript
 *
 *      portalItems: [{
 *          region: "center",
 *          layout: "border",
 *          border: false,
 *           items: [{
 *               xtype: "panel", 
 *               id: "panel", 
 *               tbar: [], 
 *               layout: "card", 
 *               region: "center", 
 *               activeItem: 0, 
 *               items: [
 *               "map", {
 *                   xtype: 'gxp_googleearthpanel', 
 *                   mapPanel: "map"
 *               }
 *           ]
 *      } 
 *
 * Then make sure the tools go into the tbar of the panel, instead of the
 * "map.tbar" which is the default, an example is:
 *
 *  .. code-block:: javascript
 *
 *    tools: [
 *        {
 *            actionTarget: "panel.tbar",
 *            ptype: "gxp_googleearth",
 *        }
 *    ] 
 */
gxp.plugins.GoogleEarth = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_googleearth */
    ptype: "gxp_googleearth",

    /** config: config[timeout]
     *  ``Number``
     *  The time (in milliseconds) to wait before giving up on the Google API
     *  script loading.  This layer source will not be availble if the script
     *  does not load within the given timeout.  Default is 7000 (seven seconds).
     */
    timeout: 7000,

    //i18n
    menuText: "3D Viewer",
    tooltip: "Switch to 3D Viewer",
    tooltipMap: "Switch back to normal map view",

    /** private: method[constructor]
     */
    constructor: function(config) {
        gxp.plugins.GoogleEarth.superclass.constructor.apply(this, arguments);
    },
    
    /** api: method[addActions]
     */
    addActions: function() {
        var actions = [{
            menuText: this.menuText,
            enableToggle: true,
            iconCls: "gxp-icon-googleearth",
            tooltip: this.tooltip,
            toggleHandler: function(button, state) {
                // we unpress the button so that it will only show pressed
                // on successful display
                this.actions[0].each(function(cmp) {
                    if (cmp.toggle) {
                        cmp.toggle(false, true);
                    }
                });
                this.togglePanelDisplay(state);
            },
            scope: this
        }];

        return gxp.plugins.GoogleEarth.superclass.addActions.apply(this, [actions]);
    },

    /** private: method[togglePanelDisplay]
     *  :arg displayed: ``Boolean`` Display the Google Earth panel.
     */
    togglePanelDisplay: function(displayed) {
        // TODO: this split between the tool and the panel needs work
        var ownerCt = this.target.mapPanel.ownerCt;
        var layout = ownerCt && ownerCt.getLayout();
        if (layout && layout instanceof Ext.layout.CardLayout) {
            if (displayed === true) {
                gxp.plugins.GoogleEarth.loader.onLoad({
                    callback: function() {
                        // display the panel
                        layout.setActiveItem(1);
                        // enable action press any buttons associated with the action
                        this.actions[0].enable();
                        this.actions[0].items[0].setTooltip(this.tooltipMap);
                        this.actions[0].each(function(cmp) {
                            if (cmp.toggle) {
                                cmp.toggle(true, true);
                            }
                        });
                    },
                    // TODO: add errback for handling load failures
                    scope: this
                });
            } else {
                // hide the panel
                layout.setActiveItem(0);
                this.actions[0].items[0].setTooltip(this.tooltip);
            }
        }
    },

    /** private: method[getHost]
     *  :returns: ``String`` The current host name and port.
     * 
     *  This method is here mainly for mocking in tests.
     */
    getHost: function() {
        var name = window.location.host.split(":").shift();
        var port = window.location.port || "80";
        return name + ":" + port;
    }

});


/**
 * Create a loader singleton that all plugin instances can use.
 */
gxp.plugins.GoogleEarth.loader = new (Ext.extend(Ext.util.Observable, {

    /** private: property[ready]
     *  ``Boolean``
     *  This plugin type is ready to use.
     */
    ready: !!(window.google && window.google.earth),

    /** private: property[loading]
     *  ``Boolean``
     *  The resources for this plugin type are loading.
     */
    loading: false,
    
    constructor: function() {
        this.addEvents(
            /** private: event[ready]
             *  Fires when this plugin type is ready.
             */
             "ready",

             /** private: event[failure]
              *  Fires when script loading fails.
              */
              "failure"
        );
        return Ext.util.Observable.prototype.constructor.apply(this, arguments);
    },
    
    /** private: method[onScriptLoad]
     *  Called when all resources required by this plugin type have loaded.
     */
    onScriptLoad: function() {
        // the google loader calls this in the window scope
        var monitor = gxp.plugins.GoogleEarth.loader;
        if (!monitor.ready) {
            monitor.ready = true;
            monitor.loading = false;
            monitor.fireEvent("ready");
        }
    },
    
    /** api: method[gxp.plugins.GoogleEarth.loader.onLoad]
     *  :arg options: ``Object``
     *
     *  Options:
     *
     *  * callback - ``Function`` Called when script loads.
     *  * errback - ``Function`` Called if loading fails.
     *  * timeout - ``Number`` Time to wait before deciding that loading failed
     *      (in milliseconds).
     *  * scope - ``Object`` The ``this`` object for callbacks.
     */
    onLoad: function(options) {
        if (this.ready) {
            // call this in the next turn for consistent return before callback
            window.setTimeout(function() {
                options.callback.call(options.scope);
            }, 0);
        } else if (!this.loading) {
            this.loadScript(options);
        } else {
            this.on({
                ready: options.callback,
                failure: options.errback || Ext.emptyFn,
                scope: options.scope
            });
        }
    },

    /** private: method[onScriptLoad]
     *  Called when all resources required by this plugin type have loaded.
     */
    loadScript: function(options) {
        
        // remove any previous loader to ensure that the key is applied
        if (window.google) {
            delete google.loader;
        }

        var params = {
            autoload: Ext.encode({
                modules: [{
                    name: "earth",
                    version: "1",
                    callback: "gxp.plugins.GoogleEarth.loader.onScriptLoad"
                }]
            })
        };
        
        var script = document.createElement("script");
        script.src = "https://www.google.com/jsapi?" + Ext.urlEncode(params);

        // cancel loading if monitor is not ready within timeout
        var errback = options.errback || Ext.emptyFn;
        var timeout = options.timeout || gxp.plugins.GoogleSource.prototype.timeout;
        window.setTimeout((function() {
            if (!gxp.plugins.GoogleEarth.loader.ready) {
                this.fireEvent("failure");
                this.unload();
            }
        }).createDelegate(this), timeout);
        
        // register callback for ready
        this.on({
            ready: options.callback,
            failure: options.errback || Ext.emptyFn,
            scope: options.scope
        });

        this.loading = true;
        
        // The google loader accesses document.body, so we don't add the loader
        // script before the document is ready.
        function append() {
            document.getElementsByTagName("head")[0].appendChild(script);
        }
        if (document.body) {
            append();
        } else {
            Ext.onReady(append);
        }
        
        this.script = script;

    },
    
    /** api: method[unload]
     *  Clean up resources created by loading.
     */
    unload: function() {
        this.purgeListeners();
        if (this.script) {
            document.getElementsByTagName("head")[0].removeChild(this.script);
            delete this.script;
        }
        this.loading = false;
        this.ready = false;
        delete google.loader;
        delete google.earth;
    }

}))();

Ext.preg(gxp.plugins.GoogleEarth.prototype.ptype, gxp.plugins.GoogleEarth);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = WMSFilterView
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: WMSFilterView(config)
 *
 *    Plugin for displaying the selection of a
 *    :class:`gxp.plugins.FeatureManager` as WMS layer. Only works with WMS
 *    services that support the CQL_FILTER and FEATUREID vendor parameters.
 *    This tool will automatically add a WMS layer to the target's mapPanel,
 *    and populate it whenever a query is processed by the FeatureManager.
 */   
gxp.plugins.WMSFilterView = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_WMSFilterView */
    ptype: "gxp_wmsfilterview",
    
    /** api: config[featureManager]
     *  ``String`` The id of the :class:`gxp.plugins.FeatureManager` to use
     *  with this tool.
     */
    featureManager: null,
    
    /** private: property[filterLayer]
     *  ``OpenLayers.Layer.WMS``
     */
    
    init: function(target) {
        gxp.plugins.WMSFilterView.superclass.init.apply(this, arguments);        
        this.createFilterLayer();
    },
    
    createFilterLayer: function() {
        this.filterLayer = new OpenLayers.Layer.WMS(this.id + "filterlayer",
            Ext.BLANK_IMAGE_URL,
            {
                format: "image/png",
                transparent: true
            }, {
                buffer: 0,
                displayInLayerSwitcher: false,
                tileOptions: {maxGetUrlLength: 2048}
            }
        );
        var map = this.target.mapPanel.map;
        map.addLayer(this.filterLayer);
        map.events.on({
            addlayer: this.raiseLayer,
            scope: this
        });
        var featureManager = this.target.tools[this.featureManager];
        var format = new OpenLayers.Format.SLD();
        var clear = (function() {
            this.filterLayer.setUrl(Ext.BLANK_IMAGE_URL);
            this.filterLayer.setVisibility(false);
        }).bind(this); 
        featureManager.on({
            "clearfeatures": clear,
            "beforelayerchange": clear,
            "beforequery": function(tool, filter) {
                this.filterLayer.setUrl(Ext.BLANK_IMAGE_URL);
                this.filterLayer.setVisibility(false);
            },
            "query": function(tool, store, filter) {
                if (!filter) {
                    return;
                }
                var rule = new OpenLayers.Rule();
                var geomType = featureManager.geometryType.replace(/^Multi/, "");
                var symbolizer = featureManager.style["all"].rules[0].symbolizer;
                rule.symbolizer[geomType] = Ext.applyIf(
                    Ext.apply({}, symbolizer[geomType] || symbolizer),
                    OpenLayers.Feature.Vector.style["default"]
                );
                var style = new OpenLayers.Style(null, {
                  rules: [rule]
                });
                var layer = tool.layerRecord.getLayer();
                this.filterLayer.setUrl(layer.url);
                
                // Remove bbox filter on 1st level (usually set by QueryForm),
                // because bbox filter and wms requests don't play together.
                if (filter instanceof OpenLayers.Filter.Logical) {
                    var filters = filter.filters;
                    for (var i=filters.length-1; i>=0; --i)  {
                        if (filters[i].type === OpenLayers.Filter.Spatial.BBOX) {
                            filters.remove(filters[i]);
                        }
                    }
                    if (filters.length == 1 && filter.type !== OpenLayers.Filter.Comparison.NOT) {
                        filter = filters[0];
                    } else if (filters.length == 0) {
                        filter = null;
                    }
                } else if (filter.type === OpenLayers.Filter.Spatial.BBOX) {
                    filter = null;
                }
                
                var params = {};
                // To avoid switching to POST requests whenever possible, we
                // encode the filter with the much more compact CQL format and
                // FEATUREID vendor param, and strip namespace prefixes and
                // declarations from the SLD
                if (filter) {
                    if (filter instanceof OpenLayers.Filter.FeatureId) {
                        params.featureid = filter.fids;
                    } else {
                        params.cql_filter = new OpenLayers.Format.CQL().write(filter);
                    }
                }
                this.filterLayer.mergeNewParams(Ext.apply(params, {
                    sld_body: format.write({
                        namedLayers: [{
                            name: featureManager.layerRecord.get("name"),
                            userStyles: [style]
                        }]
                    }).replace(/( (xmlns|xsi):[^\"]*\"[^\"]*"|sld:)/g, "")
                }));
                this.filterLayer.setVisibility(true);
            },
            scope: this
        });
    },
    
    /** private: method[raiseLayer]
     *  Called whenever a layer is added to the map to keep this layer on top.
     */
    raiseLayer: function() {
        var map = this.filterLayer.map;
        map.setLayerIndex(this.filterLayer, map.layers.length);
    }
    
});

Ext.preg(gxp.plugins.WMSFilterView.prototype.ptype, gxp.plugins.WMSFilterView);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires util.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = WMSRasterStylesDialog
 */

Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: WMSRasterStyleDialog(config)
 *
 *    This plugins extends the :class:`gxp.WMSStylesDialog` to with basic
 *    raster support, for single-band rasters only.
 *
 *    TODO replace this with true raster support instead of squeezing it into
 *    a VectorLegend as if we were dealing with vector styles.
 */   
gxp.plugins.WMSRasterStylesDialog = {
    
    /** private: property[isRaster]
     *  ``Boolean`` Are we dealing with a raster layer with RasterSymbolizer?
     *  This is needed because we create pseudo rules from a RasterSymbolizer's
     *  ColorMap, and for this we need special treatment in some places.
     */
    isRaster: null,
    
    init: function(target) {
        Ext.apply(target, gxp.plugins.WMSRasterStylesDialog);
    },

    /** private: method[createRule]
     */
    createRule: function() {
        var symbolizers = [
            new OpenLayers.Symbolizer[this.isRaster ? "Raster" : this.symbolType]
        ];
        return new OpenLayers.Rule({symbolizers: symbolizers});
    },
    
    /** private: method[addRule]
     */
    addRule: function() {
        var legend = this.items.get(2).items.get(0);
        if (this.isRaster) {
            legend.rules.push(this.createPseudoRule());
            // we need either zero or at least two rules
            legend.rules.length == 1 &&
                legend.rules.push(this.createPseudoRule());
            this.savePseudoRules();
        } else {
            this.selectedStyle.get("userStyle").rules.push(
                this.createRule()
            );
            legend.update();
            // mark the style as modified
            this.selectedStyle.store.afterEdit(this.selectedStyle);
        }
        this.updateRuleRemoveButton();
    },
    
    /** private: method[removeRule]
     */
    removeRule: function() {
        if (this.isRaster) {
            var legend = this.items.get(2).items.get(0);
            var rule = this.selectedRule;
            legend.unselect();
            legend.rules.remove(rule);
            // we need either zero or at least two rules
            legend.rules.length == 1 && legend.rules.remove(legend.rules[0]);
            this.savePseudoRules();
        } else {
            gxp.WMSStylesDialog.prototype.removeRule.apply(this, arguments);
        }
    },
    
    /** private: method[duplicateRule]
     */
    duplicateRule: function() {
        var legend = this.items.get(2).items.get(0);
        if (this.isRaster) {
            legend.rules.push(this.createPseudoRule({
                quantity: this.selectedRule.name,
                label: this.selectedRule.title,
                color: this.selectedRule.symbolizers[0].fillColor,
                opacity: this.selectedRule.symbolizers[0].fillOpacity
            }));
            this.savePseudoRules();
        } else {
            var newRule = this.selectedRule.clone();
            newRule.name = gxp.util.uniqueName(
                (newRule.title || newRule.name) + " (copy)");
            delete newRule.title;
            this.selectedStyle.get("userStyle").rules.push(
                newRule
            );
            legend.update();
        }
        this.updateRuleRemoveButton();
    },
    
    editRule: function() {
        this.isRaster ? this.editPseudoRule() :
            gxp.WMSStylesDialog.prototype.editRule.apply(this, arguments);
    },
    
    /** private: method[editPseudoRule]
     *  Edit a pseudo rule of a RasterSymbolizer's ColorMap.
     */
    editPseudoRule: function() {
        var me = this;
        var rule = this.selectedRule;

        var pseudoRuleDlg = new Ext.Window({
            title: "Color Map Entry: " + rule.name,
            width: 340,
            autoHeight: true,
            modal: true,
            items: [{
                bodyStyle: "padding-top: 5px",
                border: false,
                defaults: {
                    autoHeight: true,
                    hideMode: "offsets"
                },
                items: [{
                    xtype: "form",
                    border: false,
                    labelAlign: "top",
                    defaults: {border: false},
                    style: {"padding": "0.3em 0 0 1em"},
                    items: [{
                        layout: "column",
                        defaults: {
                            border: false,
                            style: {"padding-right": "1em"}
                        },
                        items: [{
                            layout: "form",
                            width: 70,
                            items: [{
                                xtype: "numberfield",
                                anchor: "95%",
                                value: rule.name,
                                allowBlank: false,
                                fieldLabel: "Quantity",
                                validator: function(value) {
                                    var rules = me.items.get(2).items.get(0).rules;
                                    for (var i=rules.length-1; i>=0; i--) {
                                        if (rule !== rules[i] && rules[i].name == value) {
                                            return "Quantity " + value + " is already defined";
                                        }
                                    }
                                    return true;
                                },
                                listeners: {
                                    valid: function(cmp) {
                                        this.selectedRule.name = String(cmp.getValue());
                                        this.savePseudoRules();
                                    },
                                    scope: this
                                }
                            }]
                        }, {
                            layout: "form",
                            width: 130,
                            items: [{
                                xtype: "textfield",
                                fieldLabel: "Label",
                                anchor: "95%",
                                value: rule.title,
                                listeners: {
                                    valid: function(cmp) {
                                        this.selectedRule.title = cmp.getValue();
                                        this.savePseudoRules();
                                    },
                                    scope: this
                                }
                            }]
                        }, {
                            layout: "form",
                            width: 70,
                            items: [new GeoExt.FeatureRenderer({
                                symbolType: this.symbolType,
                                symbolizers: [rule.symbolizers[0]],
                                isFormField: true,
                                fieldLabel: "Appearance"
                            })]
                        }]
                    }]
                }, {
                    xtype: "gxp_polygonsymbolizer",
                    symbolizer: rule.symbolizers[0],
                    bodyStyle: {"padding": "10px"},
                    border: false,
                    labelWidth: 70,
                    defaults: {
                        labelWidth: 70
                    },
                    listeners: {
                        change: function(symbolizer) {
                            var symbolizerSwatch = pseudoRuleDlg.findByType(GeoExt.FeatureRenderer)[0];
                            symbolizerSwatch.setSymbolizers(
                                [symbolizer], {draw: symbolizerSwatch.rendered}
                            );
                            this.selectedRule.symbolizers[0] = symbolizer;
                            this.savePseudoRules();
                        },
                        scope: this
                    }
                }]
            }]
        });
        // remove stroke fieldset
        var strokeSymbolizer = pseudoRuleDlg.findByType("gxp_strokesymbolizer")[0];
        strokeSymbolizer.ownerCt.remove(strokeSymbolizer);
        
        pseudoRuleDlg.show();
    },
    
    /** private: method[savePseudoRules]
     *  Takes the pseudo rules from the legend and adds them as
     *  RasterSymbolizer ColorMap back to the userStyle.
     */
    savePseudoRules: function() {
        var style = this.selectedStyle;
        var legend = this.items.get(2).items.get(0);
        var userStyle = style.get("userStyle");
        
        var pseudoRules = legend.rules;
        pseudoRules.sort(function(a,b) {
            var left = parseFloat(a.name);
            var right = parseFloat(b.name);
            return left === right ? 0 : (left < right ? -1 : 1);
        });
        
        var symbolizer = userStyle.rules[0].symbolizers[0];
        symbolizer.colorMap = pseudoRules.length > 0 ?
            new Array(pseudoRules.length) : undefined;
        var pseudoRule;
        for (var i=0, len=pseudoRules.length; i<len; ++i) {
            pseudoRule = pseudoRules[i];
            symbolizer.colorMap[i] = {
                quantity: parseFloat(pseudoRule.name),
                label: pseudoRule.title || undefined,
                color: pseudoRule.symbolizers[0].fillColor || undefined,
                opacity: pseudoRule.symbolizers[0].fill == false ? 0 :
                    pseudoRule.symbolizers[0].fillOpacity
            };
        }
        this.afterRuleChange(this.selectedRule);
    },
    
    /** private: method[createLegend]
     *  :arg rules: ``Array``
     *  :arg options:
     */
    createLegend: function(rules, options) {
        var R = OpenLayers.Symbolizer.Raster;
        if (R && rules[0] && rules[0].symbolizers[0] instanceof R) {
            this.getComponent("rulesfieldset").setTitle("Color Map Entries");
            this.isRaster = true;
            this.addRasterLegend(rules, options);
        } else {
            this.isRaster = false;
            this.addVectorLegend(rules);
        }
    },    

    /** private: method[addRasterLegend]
     *  :arg rules: ``Array``
     *  :arg options: ``Object`` Additional options for this method.
     *  :returns: ``GeoExt.VectorLegend`` the legend that was created
     *
     *  Creates the vector legend for the pseudo rules that are created from
     *  the RasterSymbolizer of the first rule and adds it to the rules
     *  fieldset.
     *  
     *  Supported options:
     *
     *  * selectedRuleIndex: ``Number`` The index of a pseudo rule to select
     *    in the legend.
     */  
    addRasterLegend: function(rules, options) {
        options = options || {};
        //TODO raster styling support is currently limited to one rule, and
        // we can only handle a color map. No band selection and other stuff.
        var symbolizer = rules[0].symbolizers[0];
        var colorMap = symbolizer.colorMap || [];
        var pseudoRules = [];
        var colorMapEntry;
        for (var i=0, len=colorMap.length; i<len; i++) {
            pseudoRules.push(this.createPseudoRule(colorMap[i]));
        }
        this.selectedRule = options.selectedRuleIndex != null ?
            pseudoRules[options.selectedRuleIndex] : null;
        return this.addVectorLegend(pseudoRules, {
            symbolType: "Polygon",
            enableDD: false
        });
    },
    
    /** private: method[createPseudoRule]
     *  :arg colorMapEntry: ``Object``
     *  
     *  Creates a pseudo rule from a ColorMapEntry.
     */
    createPseudoRule: function(colorMapEntry) {
        var quantity = -1;
        if (!colorMapEntry) {
            var fieldset = this.items.get(2);
            if (fieldset.items) {
                rules = fieldset.items.get(0).rules;
                for (var i=rules.length-1; i>=0; i--) {
                    quantity = Math.max(quantity, parseFloat(rules[i].name));
                }            
            }
        }
        colorMapEntry = Ext.applyIf(colorMapEntry || {}, {
            quantity: ++quantity,
            color: "#000000",
            opacity: 1
        });
        return new OpenLayers.Rule({
            title: colorMapEntry.label,
            name: String(colorMapEntry.quantity),
            symbolizers: [new OpenLayers.Symbolizer.Polygon({
                fillColor: colorMapEntry.color,
                fillOpacity: colorMapEntry.opacity,
                stroke: false,
                fill: colorMapEntry.opacity !== 0
            })]
        });
    },

    /** private: method[updateRuleRemoveButton]
     *  Enable/disable the "Remove" button to make sure that we don't delete
     *  the last rule.
     */
    updateRuleRemoveButton: function() {
        this.items.get(3).items.get(1).setDisabled(!this.selectedRule ||
            (this.isRaster === false &&
            this.items.get(2).items.get(0).rules.length <= 1));
    }
    
};

/** api: ptype = gxp_wmsrasterstylesdialog */
Ext.preg("gxp_wmsrasterstylesdialog", gxp.plugins.WMSRasterStylesDialog);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 * @requires plugins/FeatureEditorGrid.js
 * @requires GeoExt/widgets/Popup.js
 * @requires OpenLayers/Control/WMSGetFeatureInfo.js
 * @requires OpenLayers/Format/WMSGetFeatureInfo.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = WMSGetFeatureInfo
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: WMSGetFeatureInfo(config)
 *
 *    This plugins provides an action which, when active, will issue a
 *    GetFeatureInfo request to the WMS of all layers on the map. The output
 *    will be displayed in a popup.
 */
gxp.plugins.WMSGetFeatureInfo = Ext.extend(gxp.plugins.Tool, {

    /** api: ptype = gxp_wmsgetfeatureinfo */
    ptype: "gxp_wmsgetfeatureinfo",

    /** api: config[outputTarget]
     *  ``String`` Popups created by this tool are added to the map by default.
     */
    outputTarget: "map",

    /** private: property[popupCache]
     *  ``Object``
     */
    popupCache: null,

    /** api: config[infoActionTip]
     *  ``String``
     *  Text for feature info action tooltip (i18n).
     */
    infoActionTip: "Get Feature Info",

    /** api: config[popupTitle]
     *  ``String``
     *  Title for info popup (i18n).
     */
    popupTitle: "Feature Info",

    /** api: config[text]
     *  ``String`` Text for the GetFeatureInfo button (i18n).
     */
    buttonText: "Identify",

    /** api: config[format]
     *  ``String`` Either "html" or "grid". If set to "grid", GML will be
     *  requested from the server and displayed in an Ext.PropertyGrid.
     *  Otherwise, the html output from the server will be displayed as-is.
     *  Default is "html".
     */
    format: "html",

    /** api: config[vendorParams]
     *  ``Object``
     *  Optional object with properties to be serialized as vendor specific
     *  parameters in the requests (e.g. {buffer: 10}).
     */

    /** api: config[layerParams]
     *  ``Array`` List of param names that should be taken from the layer and
     *  added to the GetFeatureInfo request (e.g. ["CQL_FILTER"]).
     */

    /** api: config[itemConfig]
     *  ``Object`` A configuration object overriding options for the items that
     *  get added to the popup for each server response or feature. By default,
     *  each item will be configured with the following options:
     *
     *  .. code-block:: javascript
     *
     *      xtype: "propertygrid", // only for "grid" format
     *      title: feature.fid ? feature.fid : title, // just title for "html" format
     *      source: feature.attributes, // only for "grid" format
     *      html: text, // responseText from server - only for "html" format
     */

    /** api: method[addActions]
     */
    addActions: function() {
        this.popupCache = {};

        var actions = gxp.plugins.WMSGetFeatureInfo.superclass.addActions.call(this, [{
            tooltip: this.infoActionTip,
            iconCls: "gxp-icon-getfeatureinfo",
            buttonText: this.buttonText,
            toggleGroup: this.toggleGroup,
            enableToggle: true,
            allowDepress: true,
            toggleHandler: function(button, pressed) {
                for (var i = 0, len = info.controls.length; i < len; i++) {
                    if (pressed) {
                        info.controls[i].activate();
                    } else {
                        info.controls[i].deactivate();
                    }
                }
            }
        }]);
        var infoButton = this.actions[0].items[0];

        var info = { controls: [] };
        var updateInfo = function() {
            var queryableLayers = this.target.mapPanel.layers.queryBy(function(x) {
                return x.get("queryable");
            });

            var map = this.target.mapPanel.map;
            var control;
            for (var i = 0, len = info.controls.length; i < len; i++) {
                control = info.controls[i];
                control.deactivate(); // TODO: remove when http://trac.openlayers.org/ticket/2130 is closed
                control.destroy();
            }

            info.controls = [];
            queryableLayers.each(function(x) {
                var layer = x.getLayer();
                var vendorParams = Ext.apply({}, this.vendorParams),
                    param;
                if (this.layerParams) {
                    for (var i = this.layerParams.length - 1; i >= 0; --i) {
                        param = this.layerParams[i].toUpperCase();
                        vendorParams[param] = layer.params[param];
                    }
                }
                var infoFormat = x.get("infoFormat");
                if (infoFormat === undefined) {
                    // TODO: check if chosen format exists in infoFormats array
                    // TODO: this will not work for WMS 1.3 (text/xml instead for GML)
                    infoFormat = this.format == "html" ? "text/html" : "application/vnd.ogc.gml";
                }
                var control = new OpenLayers.Control.WMSGetFeatureInfo(Ext.applyIf({
                    url: layer.url,
                    queryVisible: true,
                    layers: [layer],
                    infoFormat: infoFormat,
                    vendorParams: vendorParams,
                    eventListeners: {
                        getfeatureinfo: function(evt) {
                            var title = x.get("title") || x.get("name");
                            if (infoFormat == "text/html") {
                                var match = evt.text.match(/<body[^>]*>([\s\S]*)<\/body>/);
                                if (match && !match[1].match(/^\s*$/)) {
                                    this.displayPopup(evt, title, match[1]);
                                }
                            } else if (infoFormat == "text/plain") {
                                this.displayPopup(evt, title, '<pre>' + evt.text + '</pre>');
                            } else if (evt.features && evt.features.length > 0) {
                                this.displayPopup(evt, title, null, x.get("getFeatureInfo"));
                            }
                        },
                        scope: this
                    }
                }, this.controlOptions));
                map.addControl(control);
                info.controls.push(control);
                if (infoButton.pressed) {
                    control.activate();
                }
            }, this);

        };

        this.target.mapPanel.layers.on("update", updateInfo, this);
        this.target.mapPanel.layers.on("add", updateInfo, this);
        this.target.mapPanel.layers.on("remove", updateInfo, this);

        return actions;
    },

    /** private: method[displayPopup]
     * :arg evt: the event object from a 
     *     :class:`OpenLayers.Control.GetFeatureInfo` control
     * :arg title: a String to use for the title of the results section 
     *     reporting the info to the user
     * :arg text: ``String`` Body text.
     */
    displayPopup: function(evt, title, text, featureinfo) {
        var popup;
        var popupKey = evt.xy.x + "." + evt.xy.y;
        featureinfo = featureinfo || {};
        if (!(popupKey in this.popupCache)) {
            popup = this.addOutput({
                xtype: "gx_popup",
                title: this.popupTitle,
                layout: "accordion",
                fill: false,
                autoScroll: true,
                location: evt.xy,
                map: this.target.mapPanel,
                width: 250,
                height: 300,
                defaults: {
                    layout: "fit",
                    autoScroll: true,
                    autoHeight: true,
                    autoWidth: true,
                    collapsible: true
                }
            });
            popup.on({
                close: (function(key) {
                    return function(panel) {
                        delete this.popupCache[key];
                    };
                })(popupKey),
                scope: this
            });
            this.popupCache[popupKey] = popup;
        } else {
            popup = this.popupCache[popupKey];
        }

        var features = evt.features,
            config = [];
        if (!text && features) {
            var feature;
            for (var i = 0, ii = features.length; i < ii; ++i) {
                feature = features[i];
                config.push(Ext.apply({
                    xtype: "gxp_editorgrid",
                    readOnly: true,
                    listeners: {
                        'beforeedit': function(e) {
                            return false;
                        }
                    },
                    title: feature.fid ? feature.fid : title,
                    feature: feature,
                    fields: featureinfo.fields,
                    propertyNames: featureinfo.propertyNames
                }, this.itemConfig));
            }
        } else if (text) {
            config.push(Ext.apply({
                title: title,
                html: text
            }, this.itemConfig));
        }
        popup.add(config);
        popup.doLayout();
    }

});

Ext.preg(gxp.plugins.WMSGetFeatureInfo.prototype.ptype, gxp.plugins.WMSGetFeatureInfo);
/**
 * Copyright (c) 2008-2012 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = FormFieldHelp
 */

Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: FormFieldHelp(config)
 *
 *    Plugin for showing a help text when hovering over a form field.
 *    Uses an Ext.QuickTip.
 */
/** api: example
 *    The code example below shows how to use this plugin with a form field:
 *
 *    .. code-block:: javascript
 *
 *      var field = new Ext.form.TextField({
 *          name: 'foo',
 *          value: 'bar',
 *          plugins: [{
 *              ptype: 'gxp_formfieldhelp',
 *              helpText: 'This is the help text for my form field'
 *          }]
 *      });
 */
gxp.plugins.FormFieldHelp = Ext.extend(Object, {

    /** api: ptype = gxp_formfieldhelp */
    ptype: 'gxp_formfieldhelp',

    /** api: config[helpText]
     *  ``String`` The help text to show.
     */
    helpText: null,

    /** api: config[dismissDelay]
     *  ``Integer`` How long before the quick tip should disappear.
     *  Defaults to 5 seconds.
     */
    dismissDelay: 5000,

    /** private: method[constructor]
     */
    constructor: function(config) {
        Ext.apply(this, config);
    },

    /** private: method[init]
     *
     *  :arg target: ``Ext.form.Field`` The form field initializing this 
     *  plugin.
     */
    init: function(target){
        this.target = target;
        target.on('render', this.showHelp, this);
    },

    /** private: method[showHelp]
     *  Show the help popup for the field. Show it on the associated label if
     *  present, with a fallback to the form element itself.
     */
    showHelp: function() {
        var target;
        if (this.target.label) {
            target = this.target.label;
        } else {
            target = this.target.getEl();
        }
        Ext.QuickTips.register({
            target: target, 
            dismissDelay: this.dismissDelay,
            text: this.helpText
        });
    }
});

Ext.preg(gxp.plugins.FormFieldHelp.prototype.ptype, gxp.plugins.FormFieldHelp);

/**
 * Copyright (c) 2008-2012 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = FormFieldHelp
 */

Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: SchemaAnnotations
 *
 *    Module for getting annotations from the WFS DescribeFeatureType schema.
 *    This is currently used in gxp.plugins.FeatureEditorForm and
 *    gxp.plugins.FeatureEditorGrid.
 *   
 *    The WFS needs to provide xsd:annotation in the XML Schema which is 
 *    reported back on a WFS DescribeFeatureType request. An example is:
 *  
 *    .. code-block:: xml
 *
 *      <xsd:element maxOccurs="1" minOccurs="0" name="PERSONS" nillable="true" type="xsd:double">
 *        <xsd:annotation>
 *          <xsd:appinfo>{"title":{"en":"Population"}}</xsd:appinfo>
 *          <xsd:documentation xml:lang="en">
 *            Number of persons living in the state
 *          </xsd:documentation>
 *        </xsd:annotation>
 *      </xsd:element>
 *
 *    To use this module simply use Ext.override in your class, and use the 
 *    getAnnotationsFromSchema function on a record from the attribute store.
 *
 *    .. code-block:: javascript
 *
 *    Ext.override(gxp.plugins.YourPlugin, gxp.plugins.SchemaAnnotations);
 *
 */
gxp.plugins.SchemaAnnotations = {

    /** api: method[getAnnotationsFromSchema]
     *
     *  :arg r: ``Ext.data.Record`` a record from the AttributeStore
     *  :returns: ``Object`` Object with label and helpText properties or
     *  null if no annotation was found.
     */
    getAnnotationsFromSchema: function(r) {
        var result = null;
        var annotation = r.get('annotation');
        if (annotation !== undefined) {
            result = {};
            var lang = GeoExt.Lang.locale.split("-").shift();
            var i, ii;
            for (i=0, ii=annotation.appinfo.length; i<ii; ++i) {
                var json = Ext.decode(annotation.appinfo[i]);
                if (json.title && json.title[lang]) {
                    result.label = json.title[lang];
                    break;
                }
            }
            for (i=0, ii=annotation.documentation.length; i<ii; ++i) {
                if (annotation.documentation[i].lang === lang) {
                    result.helpText = annotation.documentation[i].textContent;
                    break;
                }
            }
        }
        return result;
    }
};

/**
 * Copyright (c) 2008-2012 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires GeoExt/widgets/form.js
 * @requires plugins/SchemaAnnotations.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = FeatureEditorGrid
 *  base_link = `Ext.grid.PropertyGrid <http://extjs.com/deploy/dev/docs/?class=Ext.grid.PropertyGrid>`_
 */

Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: FeatureEditorGrid(config)
 *
 *    Plugin for editing a feature in a property grid.
 */
gxp.plugins.FeatureEditorGrid = Ext.extend(Ext.grid.PropertyGrid, {

    /** api: ptype = gxp_editorgrid */
    ptype: "gxp_editorgrid",

    /** api: xtype = gxp_editorgrid */
    xtype: "gxp_editorgrid",

    /** api: config[feature]
     *  ``OpenLayers.Feature.Vector`` The feature being edited/displayed.
     */
    feature: null,

    /** api: config[schema]
     *  ``GeoExt.data.AttributeStore`` Optional. If provided, available
     *  feature attributes will be determined from the schema instead of using
     *  the attributes that the feature has currently set.
     */
    schema: null,

    /** api: config[fields]
     *  ``Array``
     *  List of field config names corresponding to feature attributes.  If
     *  not provided, fields will be derived from attributes. If provided,
     *  the field order from this list will be used, and fields missing in the
     *  list will be excluded.
     */
    fields: null,

    /** api: config[excludeFields]
     *  ``Array`` Optional list of field names (case sensitive) that are to be
     *  excluded from the editor plugin.
     */
    excludeFields: null,

    /** api: config[propertyNames]
     *  ``Object`` Property name/display name pairs. If specified, the display
     *  name will be shown in the name column instead of the property name.
     */
    propertyNames: null,

    /** api: config[readOnly]
     *  ``Boolean`` Set to true to disable editing. Default is false.
     */
    readOnly: null,

    /** private: property[border]
     *  ``Boolean`` Do not show a border.
     */
    border: false,

    /** private: method[initComponent]
     */
    initComponent : function() {
        if (!this.dateFormat) {
            this.dateFormat = Ext.form.DateField.prototype.format;
        }
        if (!this.timeFormat) {
            this.timeFormat = Ext.form.TimeField.prototype.format;
        }
        this.customRenderers = this.customRenderers || {};
        this.customEditors = this.customEditors || {};
        var feature = this.feature,
            attributes;
        if (this.fields) {
            // determine the order of attributes
            attributes = {};
            for (var i=0,ii=this.fields.length; i<ii; ++i) {
                attributes[this.fields[i]] = feature.attributes[this.fields[i]];
            }
        } else {
            attributes = feature.attributes;
        }
        if (!this.excludeFields) {
            this.excludeFields = [];
        }

        if(this.schema) {
            var ucFields = this.fields ?
                this.fields.join(",").toUpperCase().split(",") : [];
            this.schema.each(function(r) {
                var type = r.get("type");
                if (type.match(/^[^:]*:?((Multi)?(Point|Line|Polygon|Curve|Surface|Geometry))/)) {
                    // exclude gml geometries
                    return;
                }
                var name = r.get("name");
                if (this.fields) {
                    if (ucFields.indexOf(name.toUpperCase()) == -1) {
                        this.excludeFields.push(name);
                    }
                }
                var value = feature.attributes[name];
                var fieldCfg = GeoExt.form.recordToField(r);
                var annotations = this.getAnnotationsFromSchema(r);
                if (annotations && annotations.label) {
                    this.propertyNames = this.propertyNames || {};
                    this.propertyNames[name] = annotations.label;
                }
                var listeners;
                if (typeof value == "string") {
                    var format;
                    switch(type.split(":").pop()) {
                        case "date":
                            format = this.dateFormat;
                            fieldCfg.editable = false;
                            break;
                        case "dateTime":
                            if (!format) {
                                format = this.dateFormat + " " + this.timeFormat;
                                // make dateTime fields editable because the
                                // date picker does not allow to edit time
                                fieldCfg.editable = true;
                            }
                            fieldCfg.format = format;
                            //TODO When http://trac.osgeo.org/openlayers/ticket/3131
                            // is resolved, remove the listeners assignment below
                            listeners = {
                                "startedit": function(el, value) {
                                    if (!(value instanceof Date)) {
                                        var date = Date.parseDate(value.replace(/Z$/, ""), "c");
                                        if (date) {
                                            this.setValue(date);
                                        }
                                    }
                                }
                            };
                            this.customRenderers[name] = (function() {
                                return function(value) {
                                    //TODO When http://trac.osgeo.org/openlayers/ticket/3131
                                    // is resolved, change the 5 lines below to
                                    // return value.format(format);
                                    var date = value;
                                    if (typeof value == "string") {
                                        date = Date.parseDate(value.replace(/Z$/, ""), "c");
                                    }
                                    return date ? date.format(format) : value;
                                };
                            })();
                            break;
                        case "boolean":
                            listeners = {
                                "startedit": function(el, value) {
                                    this.setValue(Boolean(value));
                                }
                            };
                            break;
                        default:
                            break;
                    }
                }
                this.customEditors[name] = new Ext.grid.GridEditor({
                    field: Ext.create(fieldCfg),
                    listeners: listeners
                });
                attributes[name] = value;
            }, this);
            feature.attributes = attributes;
        }
        this.source = attributes;
        var ucExcludeFields = this.excludeFields.length ?
            this.excludeFields.join(",").toUpperCase().split(",") : [];
        this.viewConfig = {
            forceFit: true,
            getRowClass: function(record) {
                if (ucExcludeFields.indexOf(record.get("name").toUpperCase()) !== -1) {
                    return "x-hide-nosize";
                }
            }
        };
        this.listeners = {
            "beforeedit": function() {
                return this.featureEditor && this.featureEditor.editing;
            },
            "propertychange": function() {
                if (this.featureEditor) {
                    this.featureEditor.setFeatureState(this.featureEditor.getDirtyState());
                }
            },
            scope: this
        };
        //TODO This is a workaround for maintaining the order of the
        // feature attributes. Decide if this should be handled in
        // another way.
        var origSort = Ext.data.Store.prototype.sort;
        Ext.data.Store.prototype.sort = function() {};
        gxp.plugins.FeatureEditorGrid.superclass.initComponent.apply(this, arguments);
        Ext.data.Store.prototype.sort = origSort;

        /**
         * TODO: This is a workaround for getting attributes with undefined
         * values to show up in the property grid.  Decide if this should be 
         * handled in another way.
         */
        this.propStore.isEditableValue = function() {return true;};
    },

    /** private: method[init]
     *
     *  :arg target: ``gxp.FeatureEditPopup`` The feature edit popup 
     *  initializing this plugin.
     */
    init: function(target) {
        this.featureEditor = target;
        this.featureEditor.on("canceledit", this.onCancelEdit, this);
        this.featureEditor.add(this);
        this.featureEditor.doLayout();
    },

    /** private: method[destroy]
     *  Clean up.
     */
    destroy: function() {
        if (this.featureEditor) {
            this.featureEditor.un("canceledit", this.onCancelEdit, this);
            this.featureEditor = null;
        }
        gxp.plugins.FeatureEditorGrid.superclass.destroy.call(this);
    },

    /** private: method[onCancelEdit]
     *  :arg panel: ``gxp.FeatureEditPopup``
     *  :arg feature: ``OpenLayers.Feature.Vector``
     *
     *  When editing is cancelled, set the source of this property grid
     *  back to the supplied feature.
     */
    onCancelEdit: function(panel, feature) {
        if (feature) {
            this.setSource(feature.attributes);
        }
    }

});

// use the schema annotations module
Ext.override(gxp.plugins.FeatureEditorGrid, gxp.plugins.SchemaAnnotations);

Ext.preg(gxp.plugins.FeatureEditorGrid.prototype.ptype, gxp.plugins.FeatureEditorGrid);
Ext.reg(gxp.plugins.FeatureEditorGrid.prototype.xtype, gxp.plugins.FeatureEditorGrid);

/**
 * Copyright (c) 2008-2012 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires GeoExt/widgets/form.js
 * @requires plugins/SchemaAnnotations.js
 * @requires plugins/FormFieldHelp.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = FeatureEditorForm
 *  base_link = `Ext.Panel <http://extjs.com/deploy/dev/docs/?class=Ext.FormPanel>`_
 */

Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: FeatureEditorForm(config)
 *
 *    Plugin for editing feature attributes in a form.
 */
gxp.plugins.FeatureEditorForm = Ext.extend(Ext.FormPanel, {

    /** api: ptype = gxp_editorform */
    ptype: 'gxp_editorform',

    /** api: xtype = gxp_editorform */
    xtype: "gxp_editorform",

    /** api: config[feature]
     *  ``OpenLayers.Feature.Vector`` The feature being edited/displayed.
     */
    feature: null,

    /** api: config[schema]
     *  ``GeoExt.data.AttributeStore`` Optional. If provided, available
     *  feature attributes will be determined from the schema instead of using
     *  the attributes that the feature has currently set.
     */
    schema: null,

    /** api: config[fieldConfig]
     *  ``Object``
     *  An object with as keys the field names, which will provide the ability
     *  to override the xtype that GeoExt.form created by default based on the
     *  schema. When using a combo xtype, comboStoreData can be used to fill up
     *  the store of the combobox. 
     *  Example is : [['value1', 'display1'], ['value2', 'display2']]
     */
    fieldConfig: null,

    /** api: config[fields]
     *  ``Array``
     *  List of field config names corresponding to feature attributes.  If
     *  not provided, fields will be derived from attributes. If provided,
     *  the field order from this list will be used, and fields missing in the
     *  list will be excluded.
     */
    fields: null,

    /** api: config[excludeFields]
     *  ``Array`` Optional list of field names (case sensitive) that are to be
     *  excluded from the editor plugin.
     */
    excludeFields: null,

    /** api: config[propertyNames]
     *  ``Object`` Property name/display name pairs. If specified, the display
     *  name will be shown in the name column instead of the property name.
     */
    propertyNames: null,

    /** api: config[readOnly]
     *  ``Boolean`` Set to true to disable editing. Default is false.
     */
    readOnly: null,

    monitorValid: true,

    /** private: method[initComponent]
     */
    initComponent : function() {
        this.defaults = Ext.apply(this.defaults || {}, {readOnly: true});

        this.listeners = {
            clientvalidation: function(panel, valid) {
                if (valid && this.getForm().isDirty()) {
                    Ext.apply(this.feature.attributes, this.getForm().getFieldValues());
                    this.featureEditor.setFeatureState(this.featureEditor.getDirtyState());
                }
            },
            scope: this
        };

        gxp.plugins.FeatureEditorForm.superclass.initComponent.call(this);

        if (!this.excludeFields) {
            this.excludeFields = [];
        }

        // all remaining fields
        var excludeFields = [], i, ii;
        for (i=0, ii=this.excludeFields.length; i<ii; ++i) {
            excludeFields[i] = this.excludeFields[i].toLowerCase();
        }
        this.excludeFields = excludeFields;

        var ucFields = this.fields ?
            this.fields.join(",").toUpperCase().split(",") : [];

        var fields = {};
        if (this.schema) {
            this.schema.each(function(r) {
                var name = r.get("name");
                var lower = name.toLowerCase();
                if (this.fields) {
                    if (ucFields.indexOf(name.toUpperCase()) == -1) {
                        this.excludeFields.push(lower);
                    }
                }
                if (this.excludeFields.indexOf(lower) != -1) {
                    return;
                }
                var type = r.get("type");
                if (type.match(/^[^:]*:?((Multi)?(Point|Line|Polygon|Curve|Surface|Geometry))/)) {
                    // exclude gml geometries
                    return;
                }
                var fieldCfg = GeoExt.form.recordToField(r);
                var annotations = this.getAnnotationsFromSchema(r);
                if (annotations !== null) {
                    if (annotations.helpText) {
                        if (!fieldCfg.plugins) {
                            fieldCfg.plugins = [];
                        }
                        fieldCfg.plugins.push({
                            ptype: 'gxp_formfieldhelp',
                            helpText: annotations.helpText
                        });
                    }
                    if (annotations.label) {
                        fieldCfg.fieldLabel = annotations.label;
                    }
                }
                fieldCfg.fieldLabel = this.propertyNames ? (this.propertyNames[name] || fieldCfg.fieldLabel) : fieldCfg.fieldLabel;
                if (this.fieldConfig && this.fieldConfig[name]) {
                    Ext.apply(fieldCfg, this.fieldConfig[name]);
                }
                if (this.feature.attributes[name] !== undefined) {
                    fieldCfg.value = this.feature.attributes[name];
                }
                if (fieldCfg.value && fieldCfg.xtype == "checkbox") {
                    fieldCfg.checked = Ext.isBoolean(fieldCfg.value) ? fieldCfg.value : (fieldCfg.value === "true");
                }
                if (fieldCfg.value && fieldCfg.xtype == "gxp_datefield") {
                    fieldCfg.value = new Date(fieldCfg.value*1000);
                }
                if (fieldCfg.value && fieldCfg.xtype == "datefield") {
                    var dateFormat = "Y-m-d";
                    fieldCfg.format = dateFormat;
                    fieldCfg.value = Date.parseDate(fieldCfg.value.replace(/Z$/, ""), dateFormat);
                }
                if (fieldCfg.xtype === "combo") {
                    Ext.applyIf(fieldCfg, {
                        store: new Ext.data.ArrayStore({
                            fields: ['id', 'value'],
                            data: fieldCfg.comboStoreData
                        }),
                        displayField: 'value',
                        valueField: 'id',
                        mode: 'local',
                        triggerAction: 'all'
                    });
                }
                fields[lower] = fieldCfg;
            }, this);
            this.add(this.reorderFields(fields));
        } else {
            fields = {};
            for (var name in this.feature.attributes) {
                var lower = name.toLowerCase();
                if (this.fields) {
                    if (ucFields.indexOf(name.toUpperCase()) == -1) {
                        this.excludeFields.push(lower);
                    }
                }
                if (this.excludeFields.indexOf(lower) === -1) {
                    var fieldCfg = {
                        xtype: "textfield",
                        fieldLabel: this.propertyNames ? (this.propertyNames[name] || name) : name,
                        name: name,
                        value: this.feature.attributes[name]
                    };
                    fields[lower] = fieldCfg;
                }
            }
            this.add(this.reorderFields(fields));
        }
    },

    /** private: method[reorderFields]
     *
     *  :arg fields: ``Object``
     *  Reorder the fields, if this.fields was defined the order needs to be
     *  taken from this.fields.
     */
    reorderFields: function(fields) {
        var orderedFields = [];
        if (this.fields) {
            for (var i=0,ii=this.fields.length; i<ii; ++i) {
                // a field could have been configured that does not exist
                if (fields[this.fields[i].toLowerCase()]) {
                    orderedFields.push(fields[this.fields[i].toLowerCase()]);
                }
            }
        } else {
            for (var key in fields) {
                orderedFields.push(fields[key]);
            }
        }
        return orderedFields;
    },

    /** private: method[init]
     *
     *  :arg target: ``gxp.FeatureEditPopup`` The feature edit popup 
     *  initializing this plugin.
     */
    init: function(target) {
        this.featureEditor = target;
        this.featureEditor.on("startedit", this.onStartEdit, this);
        this.featureEditor.on("stopedit", this.onStopEdit, this);
        this.featureEditor.on("canceledit", this.onCancelEdit, this);
        this.featureEditor.add(this);
        this.featureEditor.doLayout();
    },

    /** private: method[destroy]
     *  Clean up.
     */
    destroy: function() {
        this.featureEditor.un("startedit", this.onStartEdit, this);
        this.featureEditor.un("stopedit", this.onStopEdit, this);
        this.featureEditor.un("canceledit", this.onCancelEdit, this);
        this.featureEditor = null;
        gxp.plugins.FeatureEditorForm.superclass.destroy.call(this);
    },

    /** private: method[onStartEdit]
     *  When editing starts in the feature edit popup, unmark all fields
     *  as readonly provided we are not in readOnly mode.
     */
    onStartEdit: function() {
        this.getForm().items.each(function(field){
             this.readOnly !== true && field.setReadOnly(false);
        }, this);
    },

    /** private: method[onStopEdit]
     *  When editing stops in the feature edit popup, mark all fields as read only.
     */
    onStopEdit: function() {
        this.getForm().items.each(function(field){
             field.setReadOnly(true);
        });
    },

    /** private: method[onCancelEdit]
     *  :arg panel: ``gxp.FeatureEditPopup``
     *  :arg feature: ``OpenLayers.Feature.Vector``
     *
     *  Reset the form when editing is canceled and the event has a feature.
     */
    onCancelEdit: function(panel, feature) {
        if (feature) {
            var form = this.getForm();
            for (var key in feature.attributes) {
                var field = form.findField(key);
                field && field.setValue(feature.attributes[key]);
            }
        }
    }

});

// use the schema annotations module
Ext.override(gxp.plugins.FeatureEditorForm, gxp.plugins.SchemaAnnotations);

Ext.preg(gxp.plugins.FeatureEditorForm.prototype.ptype, gxp.plugins.FeatureEditorForm);
Ext.reg(gxp.plugins.FeatureEditorForm.prototype.xtype, gxp.plugins.FeatureEditorForm);

/**
 * Copyright (c) 2008-2012 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/FeatureEditorGrid.js
 */

Ext.namespace("gxp.plugins");

gxp.plugins.VersionedEditor = Ext.extend(Ext.TabPanel, {

    /** api: config[url]
     *  ``String``
     *  Url of the web-api endpoint of GeoGit.
     */
    url: null,

    /** api: config[historyTpl]
     *  ``String`` Template to use for displaying the commit history.
     *  If not set, a default template will be provided.
     */
    historyTpl: '<ol><tpl for="."><li class="commit"><div class="commit-msg">{message}</div><div>{author} <span class="commit-datetime">authored {date:this.formatDate}</span></div></li></tpl>',

    /* i18n */
    attributesTitle: "Attributes",
    historyTitle: "History",
    hour: "hour",
    hours: "hours",
    day: "day",
    days: "days",
    ago: "ago",
    /* end i18n */

    border: false,
    activeTab: 0,

    /** api: config[editor]
     *  The ptype of the attribute editor to use. One of 'gxp_editorgrid' or
     *  'gxp_editorform'. Defaults to 'gxp_editorgrid'.
     */
    editor: null,

    /** private: property[attributeEditor]
     *  ``gxp.plugins.FeatureEditorGrid`` or ``gxp.plugins.FeatureEditorForm``
     */
    attributeEditor: null,

    /** api: ptype = gxp_versionededitor */
    ptype: "gxp_versionededitor",

    /** private: method[initComponent]
     */
    initComponent: function() {
        gxp.plugins.VersionedEditor.superclass.initComponent.call(this);
        var editorConfig = {
            feature: this.initialConfig.feature,
            schema: this.initialConfig.schema,
            fields: this.initialConfig.fields,
            excludeFields: this.initialConfig.excludeFields,
            propertyNames: this.initialConfig.propertyNames,
            readOnly: this.initialConfig.readOnly
        };
        var config = Ext.apply({
            xtype: this.initialConfig.editor || "gxp_editorgrid",
            title: this.attributesTitle
        }, editorConfig);
        this.attributeEditor = Ext.ComponentMgr.create(config);
        this.add(this.attributeEditor);
        var dataView = this.createDataView();
        this.add({
            xtype: 'panel',
            border: false,
            plain: true,
            layout: 'fit', 
            autoScroll: true, 
            items: [dataView], 
            title: this.historyTitle
        });
    },

    /** private: method[createDataView]
     */
    createDataView: function() {
        var typeName = this.schema.reader.raw.featureTypes[0].typeName;
        var path = typeName.split(":").pop() + "/" + this.feature.fid;
        if (this.url.charAt(this.url.length-1) !== '/') {
            this.url = this.url + "/";
        }
        var command = 'log';
        var url = this.url + command;
        url = Ext.urlAppend(url, 'path=' + path + '&output_format=json');
        var store = new Ext.data.JsonStore({
            url: url,
            root: 'response.commit',
            fields: ['message', 'author', 'email', 'commit', {
                name: 'date', type: 'date', convert: function(value) {
                    return new Date(value);
                }
            }],
            autoLoad: true
        });
        var me = this;
        var tpl = new Ext.XTemplate(this.historyTpl, {
            formatDate: function(value) {
                var now = new Date(), result = '';
                if (value > now.add(Date.DAY, -1)) {
                    var hours = Math.round((now-value)/(1000*60*60));
                    result += hours + ' ';
                    result += (result > 1) ? me.hours : me.hour;
                    result += ' ' + me.ago;
                    return result;
                } else if (value > now.add(Date.MONTH, -1)) {
                    var days = Math.round((now-value)/(1000*60*60*24));
                    result += days + ' ';
                    result += (result > 1) ? me.days : me.day;
                    result += ' ' + me.ago;
                    return result;
                }
            }
        });
        return new Ext.DataView({
            store: store,
            tpl: tpl,
            autoHeight:true
        });
    },

    /** private: method[init]
     *
     *  :arg target: ``gxp.FeatureEditPopup`` The feature edit popup 
     *  initializing this plugin.
     */
    init: function(target) {
        // make sure the editor is not added, we will take care
        // of adding the editor to our container later on
        target.on('beforeadd', OpenLayers.Function.False, this);
        this.attributeEditor.init(target);
        target.un('beforeadd', OpenLayers.Function.False, this);
        target.add(this);
        target.doLayout();
    }

});

Ext.preg(gxp.plugins.VersionedEditor.prototype.ptype, gxp.plugins.VersionedEditor);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/ClickableFeatures.js
 * @requires widgets/FeatureEditPopup.js
 * @requires util.js
 * @requires OpenLayers/Control/DrawFeature.js
 * @requires OpenLayers/Handler/Point.js
 * @requires OpenLayers/Handler/Path.js
 * @requires OpenLayers/Handler/Polygon.js
 * @requires OpenLayers/Control/SelectFeature.js
 * @requires GeoExt/widgets/form.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = FeatureEditor
 */

/** api: (extends)
 *  plugins/ClickableFeatures.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: FeatureEditor(config)
 *
 *    Plugin for feature editing. Requires a
 *    :class:`gxp.plugins.FeatureManager`.
 */   
gxp.plugins.FeatureEditor = Ext.extend(gxp.plugins.ClickableFeatures, {
    
    /** api: ptype = gxp_featureeditor */
    ptype: "gxp_featureeditor",

    /** api: config[commitMessage]
     *  ``Boolean`` Should we prompt the user for a commit message?
     *  Default is false.
     */
    commitMessage: false,
    
    /** api: config[splitButton]
     *  ``Boolean`` If set to true, the actions will be rendered as a single
     *  ``Ext.SplitButton`` instead of two separate ``Ext.Button`` instances,
     *  one for creating new features and one for editing existing features.
     *  Default is false.
     */

    /** private: property[splitButton]
     *  ``Ext.SplitButton`` If :obj:`splitButton` is configured, this will be
     *  the reference to the SplitButton once it was created.
     */
    splitButton: null,

    /** api: config[iconClsAdd]
     *  ``String``
     *  iconCls to use for the add button.
     */
    iconClsAdd: "gxp-icon-addfeature",

    /** api: config[closeOnSave]
     * ``Boolean``
     * If true, close the popup after saving. Defaults to false.
     */
    closeOnSave: false,

    /** api: config[supportAbstractGeometry]
     *  Should we support layers that advertize an abstract geometry type?
     *  In this case, we will provide menu options for digitizing point, line
     *  or polygon features. Default is false.
     */
    supportAbstractGeometry: false,

    /** api: config[supportNoGeometry]
     *  Should we support the ability to create features with no geometry?
     *  This only works when combined with supportAbstractGeometry: true.
     *  Default is false.
     */
    supportNoGeometry: false,

    /** api: config[iconClsEdit]
     *  ``String``
     *  iconCls to use for the edit button.
     */
    iconClsEdit: "gxp-icon-editfeature",

    /** i18n **/
    exceptionTitle: "Save Failed",
    exceptionText: "Trouble saving features",
    pointText: "Point",
    lineText: "Line",
    polygonText: "Polygon",
    noGeometryText: "Event",
    commitTitle: "Commit message",
    commitText: "Please enter a commit message for this edit:",

    /** api: config[createFeatureActionTip]
     *  ``String``
     *  Tooltip string for create new feature action (i18n).
     */
    createFeatureActionTip: "Create a new feature",

    /** api: config[createFeatureActionText]
     *  ``String``
     *  Create new feature text (i18n).
     */
    createFeatureActionText: "Create",
    
    /** api: config[editFeatureActionTip]
     *  ``String``
     *  Tooltip string for edit existing feature action (i18n).
     */
    editFeatureActionTip: "Edit existing feature",

    /** api: config[editFeatureActionText]
     *  ``String``
     *  Modify feature text (i18n).
     */
    editFeatureActionText: "Modify",
    
    /** api: config[splitButtonText]
     * ``String`` Text for the optional Edit SplitButton (i18n)
     */
    splitButtonText: "Edit",
    
    /** api: config[splitButtonTooltip]
     * ``String`` Tooltip for the optional Edit SplitButton (i18n)
     */
    splitButtonTooltip: "Edit features on selected WMS layer",

    /** api: config[outputTarget]
     *  ``String`` By default, the FeatureEditPopup will be added to the map.
     */
    outputTarget: "map",
    
    /** api: config[snappingAgent]
     *  ``String`` Optional id of the :class:`gxp.plugins.SnappingAgent` to use
     *  with this tool.
     */
    snappingAgent: null,
    
    /** api: config[readOnly]
     *  ``Boolean`` Set to true to use the FeatureEditor merely as a feature
     *  info tool, without editing capabilities. Default is false.
     */
    readOnly: false,

    /** api: config[modifyOnly]
     *  ``Boolean`` Set to true to use the FeatureEditor merely as a feature
     *  modify tool, i.e. there is no option to add new features.
     */
    modifyOnly: false,
    
    /** api: config[showSelectedOnly]
     *  ``Boolean`` If set to true, only selected features will be displayed
     *  on the layer. If set to false, all features (on the current page) will
     *  be. Default is true.
     */
    showSelectedOnly: true,
    
    /** api: config[fields]
     *  ``Array``
     *  List of field config names corresponding to feature attributes.  If
     *  not provided, fields will be derived from attributes. If provided,
     *  the field order from this list will be used, and fields missing in the
     *  list will be excluded.
     */

    /** api: config[excludeFields]
     *  ``Array`` Optional list of field names (case sensitive) that are to be
     *  excluded from the property grid of the FeatureEditPopup.
     */

    /** api: config[roles]
     *  ``Array`` Roles authorized to edit layers. Default is
     *  ["ROLE_ADMINISTRATOR"]
     */
    roles: ["ROLE_ADMINISTRATOR"],
    
    /** private: property[createAction]
     *  ``Ext.Action`` Action for creating new features
     */
    createAction: null,

    /** private: property[editAction]
     *  ``Ext.Action`` Action for editing existing features
     */
    editAction: null,
    
    /** private: property[activeIndex]
     *  ``Integer`` If configured with ``splitButton: true``, this will be the
     *  index of the currently active SplitButton.
     */
    activeIndex: 0,

    /** private: property[drawControl]
     *  ``OpenLayers.Control.DrawFeature``
     */
    drawControl: null,
    
    /** private: property[popup]
     *  :class:`gxp.FeatureEditPopup` FeatureEditPopup for this tool
     */
    popup: null,
    
    /** private: property[schema]
     *  ``GeoExt.data.AttributeStore``
     */
    schema: null,
    

    /** private: method[constructor]
     */
    constructor: function(config) {
        this.addEvents(
            /** api: event[layereditable]
             *  Fired when a layer is selected or unselected in the target 
             *  viewer.  Listeners can use this method to determine when a 
             *  layer is ready for editing.
             *
             *  Listener arguments:
             *
             *  * tool   - :class:`gxp.plugins.FeatureManager` This tool
             *  * record - ``GeoExt.data.LayerRecord`` The selected layer record.
             *    Will be ``null`` if no layer record is selected.
             *  * editable - ``Boolean`` The layer is ready to be edited.
             */
            "layereditable",

            /** api: event[featureeditable]
             *  Fired when a feature is selected or unselected for editing.  
             *  Listeners can use this method to determine when a feature is 
             *  ready for editing.  Beware that this event is fired multiple 
             *  times when a feature is unselected.
             *
             *  Listener arguments:
             *
             *  * tool   - :class:`gxp.plugins.FeatureManager` This tool
             *  * feature - ``OpenLayers.Feature.Vector`` The feature.
             *  * editable - ``Boolean`` The feature is ready to be edited.
             */
            "featureeditable"

        );
        gxp.plugins.FeatureEditor.superclass.constructor.apply(this, arguments);        
    },

    /** private: method[init]
     *  :arg target: ``Object`` The object initializing this plugin.
     */
    init: function(target) {
        gxp.plugins.FeatureEditor.superclass.init.apply(this, arguments);
        this.target.on("authorizationchange", this.onAuthorizationChange, this);
    },

    /** private: method[destroy]
     */
    destroy: function() {
        this.target.un("authorizationchange", this.onAuthorizationChange, this);
        gxp.plugins.FeatureEditor.superclass.destroy.apply(this, arguments);
    },
    
    /** private: method[onAuthorizationChange]
     */
    onAuthorizationChange: function() {
        if (!this.target.isAuthorized(this.roles)) {
            //TODO if a popup is open, this won't take care of closing it when
            // a user logs out.
            this.selectControl.deactivate();
            this.drawControl.deactivate();
        }
        // we don't want to return false here, otherwise we would abort the
        // event chain.
        this.enableOrDisable();
    },

    /** api: method[addActions]
     */
    addActions: function() {
        var popup;
        var featureManager = this.getFeatureManager();
        var featureLayer = featureManager.featureLayer;
        
        var intercepting = false;
        // intercept calls to methods that change the feature store - allows us
        // to persist unsaved changes before calling the original function
        function intercept(mgr, fn) {
            var fnArgs = Array.prototype.slice.call(arguments);
            // remove mgr and fn, which will leave us with the original
            // arguments of the intercepted loadFeatures or setLayer function
            fnArgs.splice(0, 2);
            if (!intercepting && popup && !popup.isDestroyed) {
                if (popup.editing) {
                    function doIt() {
                        intercepting = true;
                        unregisterDoIt.call(this);
                        if (fn === "setLayer") {
                            this.target.selectLayer(fnArgs[0]);
                        } else if (fn === "clearFeatures") {
                            // nothing asynchronous involved here, so let's
                            // finish the caller first before we do anything.
                            window.setTimeout(function() {mgr[fn].call(mgr);});
                        } else {
                            mgr[fn].apply(mgr, fnArgs);
                        }
                    }
                    function unregisterDoIt() {
                        featureManager.featureStore.un("write", doIt, this);
                        popup.un("canceledit", doIt, this);
                        popup.un("cancelclose", unregisterDoIt, this);
                    }
                    featureManager.featureStore.on("write", doIt, this);
                    popup.on({
                        canceledit: doIt,
                        cancelclose: unregisterDoIt,
                        scope: this
                    });
                    popup.close();
                }
                return !popup.editing;
            }
            intercepting = false;
        }
        featureManager.on({
            // TODO: determine where these events should be unregistered
            "beforequery": intercept.createDelegate(this, "loadFeatures", 1),
            "beforelayerchange": intercept.createDelegate(this, "setLayer", 1),
            "beforesetpage": intercept.createDelegate(this, "setPage", 1),
            "beforeclearfeatures": intercept.createDelegate(this, "clearFeatures", 1),
            scope: this
        });
        
        this.drawControl = new OpenLayers.Control.DrawFeature(
            featureLayer,
            OpenLayers.Handler.Point, 
            {
                eventListeners: {
                    featureadded: function(evt) {
                        if (this.autoLoadFeature === true) {
                            this.autoLoadedFeature = evt.feature;
                        }
                    },
                    activate: function() {
                        this.target.doAuthorized(this.roles, function() {
                            featureManager.showLayer(
                                this.id, this.showSelectedOnly && "selected"
                            );
                        }, this);
                    },
                    deactivate: function() {
                        featureManager.hideLayer(this.id);
                    },
                    scope: this
                }
            }
        );
        
        // create a SelectFeature control
        // "fakeKey" will be ignord by the SelectFeature control, so only one
        // feature can be selected by clicking on the map, but allow for
        // multiple selection in the featureGrid
        this.selectControl = new OpenLayers.Control.SelectFeature(featureLayer, {
            clickout: false,
            multipleKey: "fakeKey",
            eventListeners: {
                "activate": function() {
                    this.target.doAuthorized(this.roles, function() {
                        if (this.autoLoadFeature === true || featureManager.paging) {
                            this.target.mapPanel.map.events.register(
                                "click", this, this.noFeatureClick
                            );
                        }
                        featureManager.showLayer(
                            this.id, this.showSelectedOnly && "selected"
                        );
                        this.selectControl.unselectAll(
                            popup && popup.editing && {except: popup.feature}
                        );
                    }, this);
                },
                "deactivate": function() {
                    if (this.autoLoadFeature === true || featureManager.paging) {
                        this.target.mapPanel.map.events.unregister(
                            "click", this, this.noFeatureClick
                        );
                    }
                    if (popup) {
                        if (popup.editing) {
                            popup.on("cancelclose", function() {
                                this.selectControl.activate();
                            }, this, {single: true});
                        }
                        popup.on("close", function() {
                            featureManager.hideLayer(this.id);
                        }, this, {single: true});
                        popup.close();
                    } else {
                        featureManager.hideLayer(this.id);
                    }
                },
                scope: this
            }
        });
        
        featureLayer.events.on({
            "beforefeatureremoved": function(evt) {
                if (this.popup && evt.feature === this.popup.feature) {
                    this.selectControl.unselect(evt.feature);
                }
            },
            "featureunselected": function(evt) {
                var feature = evt.feature;
                if (feature) {
                    this.fireEvent("featureeditable", this, feature, false);
                }
                if (feature && feature.geometry && popup && !popup.hidden) {
                    popup.close();
                }
            },
            "beforefeatureselected": function(evt) {
                //TODO decide if we want to allow feature selection while a
                // feature is being edited. If so, we have to revisit the
                // SelectFeature/ModifyFeature setup, because that would
                // require to have the SelectFeature control *always*
                // activated *after* the ModifyFeature control. Otherwise. we
                // must not configure the ModifyFeature control in standalone
                // mode, and use the SelectFeature control that comes with the
                // ModifyFeature control instead.
                if(popup) {
                    return !popup.editing;
                }
            },
            "featureselected": function(evt) {
                var feature = evt.feature;
                if (feature) {
                    this.fireEvent("featureeditable", this, feature, true);
                }
                var featureStore = featureManager.featureStore;
                if(this._forcePopupForNoGeometry === true || (this.selectControl.active && feature.geometry !== null)) {
                    // deactivate select control so no other features can be
                    // selected until the popup is closed
                    if (this.readOnly === false) {
                        this.selectControl.deactivate();
                        // deactivate will hide the layer, so show it again
                        featureManager.showLayer(this.id, this.showSelectedOnly && "selected");
                    }
                    popup = this.addOutput({
                        xtype: "gxp_featureeditpopup",
                        collapsible: true,
                        feature: featureStore.getByFeature(feature),
                        vertexRenderIntent: "vertex",
                        readOnly: this.readOnly,
                        fields: this.fields,
                        excludeFields: this.excludeFields,
                        editing: feature.state === OpenLayers.State.INSERT,
                        schema: this.schema,
                        allowDelete: true,
                        width: 200,
                        height: 250
                    });
                    popup.on({
                        "close": function() {
                            if (this.readOnly === false) {
                                this.selectControl.activate();
                            }
                            if(feature.layer && feature.layer.selectedFeatures.indexOf(feature) !== -1) {
                                this.selectControl.unselect(feature);
                            }
                            if (feature === this.autoLoadedFeature) {
                                if (feature.layer) {
                                    feature.layer.removeFeatures([evt.feature]);
                                }
                                this.autoLoadedFeature = null;
                            }
                        },
                        "featuremodified": function(popup, feature) {
                            featureStore.on({
                                beforewrite: {
                                    fn: function(store, action, rs, options) {
                                        if (this.commitMessage === true) {
                                            options.params.handle = this._commitMsg;
                                            delete this._commitMsg;
                                        }
                                    },
                                    single: true
                                },
                                beforesave: {
                                    fn: function() {
                                        if (popup && popup.isVisible()) {
                                            popup.disable();
                                        }
                                        if (this.commitMessage === true) {
                                            if (!this._commitMsg) {
                                                var fn = arguments.callee;
                                                Ext.Msg.show({
                                                    prompt: true,
                                                    title: this.commitTitle,
                                                    msg: this.commitText,
                                                    buttons: Ext.Msg.OK,
                                                    fn: function(btn, text) {
                                                        if (btn === 'ok') {
                                                            this._commitMsg = text;
                                                            featureStore.un('beforesave', fn, this);
                                                            featureStore.save();
                                                        }
                                                    },
                                                    scope: this,
                                                    multiline: true
                                                });
                                                return false;
                                            }
                                        }
                                    },
                                    single: this.commitMessage !== true
                                },
                                write: {
                                    fn: function() {
                                        if (popup) {
                                            if (popup.isVisible()) {
                                                popup.enable();
                                            }
                                            if (this.closeOnSave) {
                                                popup.close();
                                            }
                                        }
                                        var layer = featureManager.layerRecord;
                                        this.target.fireEvent("featureedit", featureManager, {
                                            name: layer.get("name"),
                                            source: layer.get("source")
                                        });
                                    },
                                    single: true
                                },
                                exception: {
                                    fn: function(proxy, type, action, options, response, records) {
                                        var msg = this.exceptionText;
                                        if (type === "remote") {
                                            // response is service exception
                                            if (response.exceptionReport) {
                                                msg = gxp.util.getOGCExceptionText(response.exceptionReport);
                                            }
                                        } else {
                                            // non-200 response from server
                                            msg = "Status: " + response.status;
                                        }
                                        // fire an event on the feature manager
                                        featureManager.fireEvent("exception", featureManager, 
                                            response.exceptionReport || {}, msg, records);
                                        // only show dialog if there is no listener registered
                                        if (featureManager.hasListener("exception") === false && 
                                            featureStore.hasListener("exception") === false) {
                                                Ext.Msg.show({
                                                    title: this.exceptionTitle,
                                                    msg: msg,
                                                    icon: Ext.MessageBox.ERROR,
                                                    buttons: {ok: true}
                                                });
                                        }
                                        if (popup && popup.isVisible()) {
                                            popup.enable();
                                            popup.startEditing();
                                        }
                                    },
                                    single: true
                                },
                                scope: this
                            });                                
                            if(feature.state === OpenLayers.State.DELETE) {
                                /**
                                 * If the feature state is delete, we need to
                                 * remove it from the store (so it is collected
                                 * in the store.removed list.  However, it should
                                 * not be removed from the layer.  Until
                                 * http://trac.geoext.org/ticket/141 is addressed
                                 * we need to stop the store from removing the
                                 * feature from the layer.
                                 */
                                featureStore._removing = true; // TODO: remove after http://trac.geoext.org/ticket/141
                                featureStore.remove(featureStore.getRecordFromFeature(feature));
                                delete featureStore._removing; // TODO: remove after http://trac.geoext.org/ticket/141
                            }
                            featureStore.save();
                        },
                        "canceledit": function(popup, feature) {
                            featureStore.commitChanges();
                        },
                        scope: this
                    });
                    this.popup = popup;
                }
            },
            "sketchcomplete": function(evt) {
                // Why not register for featuresadded directly? We only want
                // to handle features here that were just added by a
                // DrawFeature control, and we need to make sure that our
                // featuresadded handler is executed after any FeatureStore's,
                // because otherwise our selectControl.select statement inside
                // this handler would trigger a featureselected event before
                // the feature row is added to a FeatureGrid. This, again,
                // would result in the new feature not being shown as selected
                // in the grid.
                featureManager.featureLayer.events.register("featuresadded", this, function(evt) {
                    featureManager.featureLayer.events.unregister("featuresadded", this, arguments.callee);
                    this.drawControl.deactivate();
                    this.selectControl.activate();
                    this.selectControl.select(evt.features[0]);
                });
            },
            scope: this
        });

        var toggleGroup = this.toggleGroup || Ext.id();

        var actions = [];
        var commonOptions = {
            tooltip: this.createFeatureActionTip,
            // backwards compatibility: only show text if configured
            menuText: this.initialConfig.createFeatureActionText,
            text: this.initialConfig.createFeatureActionText,
            iconCls: this.iconClsAdd,
            disabled: true,
            hidden: this.modifyOnly || this.readOnly,
            toggleGroup: toggleGroup,
            //TODO Tool.js sets group, but this doesn't work for GeoExt.Action
            group: toggleGroup,
            groupClass: null,
            enableToggle: true,
            allowDepress: true,
            control: this.drawControl,
            deactivateOnDisable: true,
            map: this.target.mapPanel.map,
            listeners: {checkchange: this.onItemCheckchange, scope: this}
        };
        if (this.supportAbstractGeometry === true) {
            var menuItems = [];
            if (this.supportNoGeometry === true) {
                menuItems.push(
                    new Ext.menu.CheckItem({
                        text: this.noGeometryText,
                        iconCls: "gxp-icon-event",
                        groupClass: null,
                        group: toggleGroup,
                        listeners: {
                            checkchange: function(item, checked) {
                                if (checked === true) {
                                    var feature = new OpenLayers.Feature.Vector(null);
                                    feature.state = OpenLayers.State.INSERT;
                                    featureLayer.addFeatures([feature]);
                                    this._forcePopupForNoGeometry = true;
                                    featureLayer.events.triggerEvent("featureselected", {feature: feature});
                                    delete this._forcePopupForNoGeometry;
                                }
                                if (this.createAction.items[0] instanceof Ext.menu.CheckItem) {
                                    this.createAction.items[0].setChecked(false);
                                } else {
                                    this.createAction.items[0].toggle(false);
                                }
                            },
                            scope: this
                        }
                    })
                );
            }
            var checkChange = function(item, checked, Handler) {
                if (checked === true) {
                    this.setHandler(Handler, false);
                }
                if (this.createAction.items[0] instanceof Ext.menu.CheckItem) {
                    this.createAction.items[0].setChecked(checked);
                } else {
                    this.createAction.items[0].toggle(checked);
                }
            };
            menuItems.push(
                new Ext.menu.CheckItem({
                    groupClass: null,
                    text: this.pointText,
                    group: toggleGroup,
                    iconCls: 'gxp-icon-point',
                    listeners: {
                        checkchange: checkChange.createDelegate(this, [OpenLayers.Handler.Point], 2)
                    }
                }),
                new Ext.menu.CheckItem({
                    groupClass: null,
                    text: this.lineText,
                    group: toggleGroup,
                    iconCls: 'gxp-icon-line',
                    listeners: {
                        checkchange: checkChange.createDelegate(this, [OpenLayers.Handler.Path], 2)
                    }
                }),
                new Ext.menu.CheckItem({
                    groupClass: null,
                    text: this.polygonText,
                    group: toggleGroup,
                    iconCls: 'gxp-icon-polygon',
                    listeners: {
                        checkchange: checkChange.createDelegate(this, [OpenLayers.Handler.Polygon], 2)
                    }
                })
            );

            actions.push(
                new GeoExt.Action(Ext.apply(commonOptions, {
                    menu: new Ext.menu.Menu({items: menuItems})
                }))
            );
        } else {
            actions.push(new GeoExt.Action(commonOptions));
        }
        actions.push(new GeoExt.Action({
            tooltip: this.editFeatureActionTip,
            // backwards compatibility: only show text if configured
            text: this.initialConfig.editFeatureActionText,
            menuText: this.initialConfig.editFeatureActionText,
            iconCls: this.iconClsEdit,
            disabled: true,
            toggleGroup: toggleGroup,
            //TODO Tool.js sets group, but this doesn't work for GeoExt.Action
            group: toggleGroup,
            groupClass: null,
            enableToggle: true,
            allowDepress: true,
            control: this.selectControl,
            deactivateOnDisable: true,
            map: this.target.mapPanel.map,
            listeners: {checkchange: this.onItemCheckchange, scope: this}
        }));
        
        this.createAction = actions[0];
        this.editAction = actions[1];
        
        if (this.splitButton) {
            this.splitButton = new Ext.SplitButton({
                menu: {items: [
                    Ext.apply(new Ext.menu.CheckItem(actions[0]), {
                        text: this.createFeatureActionText
                    }),
                    Ext.apply(new Ext.menu.CheckItem(actions[1]), {
                        text: this.editFeatureActionText
                    })
                ]},
                disabled: true,
                buttonText: this.splitButtonText,
                tooltip: this.splitButtonTooltip,
                iconCls: this.iconClsAdd,
                enableToggle: true,
                toggleGroup: this.toggleGroup,
                allowDepress: true,
                handler: function(button, event) {
                    if(button.pressed) {
                        button.menu.items.itemAt(this.activeIndex).setChecked(true);
                    }
                },
                scope: this,
                listeners: {
                    toggle: function(button, pressed) {
                        // toggleGroup should handle this
                        if(!pressed) {
                            button.menu.items.each(function(i) {
                                i.setChecked(false);
                            });
                        }
                    },
                    render: function(button) {
                        // toggleGroup should handle this
                        Ext.ButtonToggleMgr.register(button);
                    }
                }
            });
            actions = [this.splitButton];
        }

        actions = gxp.plugins.FeatureEditor.superclass.addActions.call(this, actions);

        featureManager.on("layerchange", this.onLayerChange, this);

        var snappingAgent = this.getSnappingAgent();
        if (snappingAgent) {
            snappingAgent.registerEditor(this);
        }

        return actions;
    },
    
    onItemCheckchange: function(item, checked) {
        if (this.splitButton) {
            this.activeIndex = item.ownerCt.items.indexOf(item);
            this.splitButton.toggle(checked);
            if (checked) {
                this.splitButton.setIconClass(item.iconCls);
            }
        }
    },

    /** private: method[getFeatureManager]
     *  :returns: :class:`gxp.plugins.FeatureManager`
     */
    getFeatureManager: function() {
        var manager = this.target.tools[this.featureManager];
        if (!manager) {
            throw new Error("Unable to access feature manager by id: " + this.featureManager);
        }
        return manager;
    },

    /** private: getSnappingAgent
     *  :returns: :class:`gxp.plugins.SnappingAgent`
     */
    getSnappingAgent: function() {
        var agent;
        var snapId = this.snappingAgent;
        if (snapId) {
            agent = this.target.tools[snapId];
            if (!agent) {
                throw new Error("Unable to locate snapping agent with id: " + snapId);
            }
        }
        return agent;
    },

    setHandler: function(Handler, multi) {
        var control = this.drawControl;
        var active = control.active;
        if(active) {
            control.deactivate();
        }
        control.handler.destroy(); 
        control.handler = new Handler(
            control, control.callbacks,
            Ext.apply(control.handlerOptions, {multi: multi})
        );
        if(active) {
            control.activate();
        } 
    },

    /**
     * private: method[enableOrDisable]
     */
    enableOrDisable: function() {
        // disable editing if no schema
        var disable = !this.schema;
        if (this.splitButton) {
            this.splitButton.setDisabled(disable);
        }
        this.createAction.setDisabled(disable);
        this.editAction.setDisabled(disable);
        return disable;
    },
    
    /** private: method[onLayerChange]
     *  :arg mgr: :class:`gxp.plugins.FeatureManager`
     *  :arg layer: ``GeoExt.data.LayerRecord``
     *  :arg schema: ``GeoExt.data.AttributeStore``
     */
    onLayerChange: function(mgr, layer, schema) {
        this.schema = schema;
        var disable = this.enableOrDisable();
        if (disable) {
            // not a wfs capable layer
            this.fireEvent("layereditable", this, layer, false);
            return;
        }

        var control = this.drawControl;
        var button = this.createAction;
        var handlers = {
            "Point": OpenLayers.Handler.Point,
            "Line": OpenLayers.Handler.Path,
            "Curve": OpenLayers.Handler.Path,
            "Polygon": OpenLayers.Handler.Polygon,
            "Surface": OpenLayers.Handler.Polygon
        };
        var simpleType = mgr.geometryType && mgr.geometryType.replace("Multi", "");
        var Handler = simpleType && handlers[simpleType];
        if (Handler) {
            var multi = (simpleType != mgr.geometryType);
            this.setHandler(Handler, multi);
            button.enable();
        } else if (this.supportAbstractGeometry === true && mgr.geometryType && mgr.geometryType === 'Geometry') {
            button.enable();
        } else {
            button.disable();
        }
        this.fireEvent("layereditable", this, layer, true);
    },
    
    /** private: method[select]
     *  :arg feature: ``OpenLayers.Feature.Vector``
     */
    select: function(feature) {
        this.selectControl.unselectAll(
            this.popup && this.popup.editing && {except: this.popup.feature});
        this.selectControl.select(feature);
    }
});

Ext.preg(gxp.plugins.FeatureEditor.prototype.ptype, gxp.plugins.FeatureEditor);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/ClickableFeatures.js
 * @requires widgets/grid/FeatureGrid.js
 * @requires GeoExt/widgets/grid/FeatureSelectionModel.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = FeatureGrid
 */

/** api: (extends)
 *  plugins/ClickableFeatures.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: FeatureGrid(config)
 *
 *    Plugin for displaying vector features in a grid. Requires a
 *    :class:`gxp.plugins.FeatureManager`. Also provides a context menu for
 *    the grid.
 */   
gxp.plugins.FeatureGrid = Ext.extend(gxp.plugins.ClickableFeatures, {
    
    /** api: ptype = gxp_featuregrid */
    ptype: "gxp_featuregrid",

    /** private: property[schema]
     *  ``GeoExt.data.AttributeStore``
     */
    schema: null,

    /** api: config[showTotalResults]
     *  ``Boolean`` If set to true, the total number of records will be shown
     *  in the bottom toolbar of the grid, if available.
     */
    showTotalResults: false,
    
    /** api: config[alwaysDisplayOnMap]
     *  ``Boolean`` If set to true, the features that are shown in the grid
     *  will always be displayed on the map, and there will be no "Display on
     *  map" button in the toolbar. Default is false. If set to true, no
     *  "Display on map" button will be shown.
     */
    alwaysDisplayOnMap: false,
    
    /** api: config[displayMode]
     *  ``String`` Should we display all features on the map, or only the ones
     *  that are currently selected on the grid. Valid values are "all" and
     *  "selected". Default is "all".
     */
    displayMode: "all",
    
    /** api: config[autoExpand]
     *  ``Boolean`` If set to true, and when this tool's output is added to a
     *  container that can be expanded, it will be expanded when features are
     *  loaded. Default is false.
     */
    autoExpand: false,
    
    /** api: config[autoCollapse]
     *  ``Boolean`` If set to true, and when this tool's output is added to a
     *  container that can be collapsed, it will be collapsed when no features
     *  are to be displayed. Default is false.
     */
    autoCollapse: false,
    
    /** api: config[selectOnMap]
     *  ``Boolean`` If set to true, features can not only be selected on the
     *  grid, but also on the map, and multi-selection will be enabled. Only
     *  set to true when no feature editor or feature info tool is used with
     *  the underlying feature manager. Default is false.
     */
    selectOnMap: false,
    
    /** api: config[displayFeatureText]
     * ``String``
     * Text for feature display button (i18n).
     */
    displayFeatureText: "Display on map",

    /** api: config[zoomFirstPageTip]
     *  ``String``
     *  Tooltip string for first page action (i18n).
     */
    firstPageTip: "First page",

    /** api: config[previousPageTip]
     *  ``String``
     *  Tooltip string for previous page action (i18n).
     */
    previousPageTip: "Previous page",

    /** api: config[zoomPageExtentTip]
     *  ``String``
     *  Tooltip string for zoom to page extent action (i18n).
     */
    zoomPageExtentTip: "Zoom to page extent",

    /** api: config[nextPageTip]
     *  ``String``
     *  Tooltip string for next page action (i18n).
     */
    nextPageTip: "Next page",

    /** api: config[lastPageTip]
     *  ``String``
     *  Tooltip string for last page action (i18n).
     */
    lastPageTip: "Last page",

    /** api: config[totalMsg]
     *  ``String``
     *  String template for showing total number of records (i18n).
     */
    totalMsg: "Features {1} to {2} of {0}",

    /** private: method[displayTotalResults]
     */
    displayTotalResults: function() {
        var featureManager = this.target.tools[this.featureManager];
        if (this.showTotalResults === true) {
            this.displayItem.setText(
                featureManager.numberOfFeatures !== null ? String.format(
                    this.totalMsg,
                    featureManager.numberOfFeatures,
                    featureManager.pageIndex * featureManager.maxFeatures + Math.min(featureManager.numberOfFeatures, 1),
                    Math.min((featureManager.pageIndex + 1) * featureManager.maxFeatures, featureManager.numberOfFeatures)
                ) : ""
            );
        }
    },
    
    /** api: method[addOutput]
     */
    addOutput: function(config) {
        var featureManager = this.target.tools[this.featureManager];
        var map = this.target.mapPanel.map, smCfg;
        // a minimal SelectFeature control - used just to provide select and
        // unselect, won't be added to the map unless selectOnMap is true
        this.selectControl = new OpenLayers.Control.SelectFeature(
            featureManager.featureLayer, this.initialConfig.controlOptions
        );
        if (this.selectOnMap) {
             if (this.autoLoadFeature || (featureManager.paging && featureManager.pagingType === gxp.plugins.FeatureManager.QUADTREE_PAGING)) {
                this.selectControl.events.on({
                    "activate": function() {
                        map.events.register(
                            "click", this, this.noFeatureClick
                        );
                    },
                    "deactivate": function() {
                        map.events.unregister(
                            "click", this, this.noFeatureClick
                        );
                    },
                    scope: this
                });
            }
            map.addControl(this.selectControl);
            smCfg = {
                selectControl: this.selectControl
            };
        } else {
            smCfg = {
                selectControl: this.selectControl,
                singleSelect: false,
                autoActivateControl: false,
                listeners: {
                    "beforerowselect": function() {
                        if((window.event && window.event.type == "contextmenu") ||this.selectControl.active || featureManager.featureStore.getModifiedRecords().length) {
                            return false;
                        }
                    },
                    scope: this
                }
            };
        }
        this.displayItem = new Ext.Toolbar.TextItem({});
        config = Ext.apply({
            xtype: "gxp_featuregrid",
            border: false,
            sm: new GeoExt.grid.FeatureSelectionModel(smCfg),
            autoScroll: true,
            columnMenuDisabled: !!featureManager.paging,
            bbar: (featureManager.paging ? [{
                iconCls: "x-tbar-page-first",
                ref: "../firstPageButton",
                tooltip: this.firstPageTip,
                disabled: true,
                handler: function() {
                    featureManager.setPage({index: 0});
                }
            }, {
                iconCls: "x-tbar-page-prev",
                ref: "../prevPageButton",
                tooltip: this.previousPageTip,
                disabled: true,
                handler: function() {
                    featureManager.previousPage();
                }
            }, {
                iconCls: "gxp-icon-zoom-to",
                ref: "../zoomToPageButton",
                tooltip: this.zoomPageExtentTip,
                disabled: true,
                hidden: (featureManager.pagingType !== gxp.plugins.FeatureManager.QUADTREE_PAGING) ||
                    featureManager.autoZoomPage,
                handler: function() {
                    var extent = featureManager.getPageExtent();
                    if (extent !== null) {
                        map.zoomToExtent(extent);
                    }
                }
            }, {
                iconCls: "x-tbar-page-next",
                ref: "../nextPageButton",
                tooltip: this.nextPageTip,
                disabled: true,
                handler: function() {
                    featureManager.nextPage();
                }
            }, {
                iconCls: "x-tbar-page-last",
                ref: "../lastPageButton",
                tooltip: this.lastPageTip,
                disabled: true,
                handler: function() {
                    featureManager.setPage({index: "last"});
                }
            }, {xtype: 'tbspacer', width: 10}, this.displayItem] : []).concat(["->"].concat(!this.alwaysDisplayOnMap ? [{
                text: this.displayFeatureText,
                enableToggle: true,
                toggleHandler: function(btn, pressed) {
                    this.selectOnMap && this.selectControl[pressed ? "activate" : "deactivate"]();
                    featureManager[pressed ? "showLayer" : "hideLayer"](this.id, this.displayMode);
                },
                scope: this
            }] : [])),
            contextMenu: new Ext.menu.Menu({items: []})
        }, config || {});
        var featureGrid = gxp.plugins.FeatureGrid.superclass.addOutput.call(this, config);
        featureGrid.on({
            "added": function(cmp, ownerCt) {
                function onClear() {
                    this.displayTotalResults();
                    this.selectOnMap && this.selectControl.deactivate();
                    this.autoCollapse && typeof ownerCt.collapse == "function" &&
                        ownerCt.collapse();
                }
                function onPopulate() {
                    this.displayTotalResults();
                    this.selectOnMap && this.selectControl.activate();
                    this.autoExpand && typeof ownerCt.expand == "function" &&
                        ownerCt.expand();
                }
                featureManager.on({
                    "query": function(tool, store) {
                        if (store && store.getCount()) {
                            onPopulate.call(this);
                        } else {
                            onClear.call(this);
                        }
                    },
                    "layerchange": onClear,
                    "clearfeatures": onClear,
                    scope: this
                });
            },
            contextmenu: function(event) {
                if (featureGrid.contextMenu.items.getCount() > 0) {
                    var rowIndex = featureGrid.getView().findRowIndex(event.getTarget());
                    if (rowIndex !== false) {
                        featureGrid.getSelectionModel().selectRow(rowIndex);
                        featureGrid.contextMenu.showAt(event.getXY());
                        event.stopEvent();
                    }
                }
            },
            scope: this
        });
        if (this.alwaysDisplayOnMap || (this.selectOnMap === true && this.displayMode === "selected")) {
            featureManager.showLayer(this.id, this.displayMode);
        }        
       
        featureManager.paging && featureManager.on({
            "beforesetpage": function() {
                featureGrid.zoomToPageButton.disable();
            },
            "setpage": function(mgr, condition, callback, scope, pageIndex, numPages) {
                var paging = (numPages > 0);
                featureGrid.zoomToPageButton.setDisabled(!paging);
                var prev = (paging && (pageIndex !== 0));
                featureGrid.firstPageButton.setDisabled(!prev);
                featureGrid.prevPageButton.setDisabled(!prev);
                var next = (paging && (pageIndex !== numPages-1));
                featureGrid.lastPageButton.setDisabled(!next);
                featureGrid.nextPageButton.setDisabled(!next);
            },
            scope: this
        });
                
        function onLayerChange() {
            var schema = featureManager.schema,
                ignoreFields = ["feature", "state", "fid"];
            //TODO use schema instead of store to configure the fields
            schema && schema.each(function(r) {
                r.get("type").indexOf("gml:") == 0 && ignoreFields.push(r.get("name"));
            });
            featureGrid.ignoreFields = ignoreFields;
            featureGrid.setStore(featureManager.featureStore, schema);
            if (!featureManager.featureStore) {
                // not a feature layer, reset toolbar
                if (featureManager.paging) {
                    featureGrid.lastPageButton.disable();
                    featureGrid.nextPageButton.disable();
                    featureGrid.firstPageButton.disable();
                    featureGrid.prevPageButton.disable();
                    featureGrid.zoomToPageButton.disable();
                }
                this.displayTotalResults();
            }
        }

        if (featureManager.featureStore) {
            onLayerChange.call(this);
        } 
        featureManager.on("layerchange", onLayerChange, this);
        
        return featureGrid;
    }
                
});

Ext.preg(gxp.plugins.FeatureGrid.prototype.ptype, gxp.plugins.FeatureGrid);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 * @requires data/WFSFeatureStore.js
 * @requires OpenLayers/StyleMap.js
 * @requires OpenLayers/Rule.js
 * @requires OpenLayers/Layer/Vector.js
 * @requires OpenLayers/Renderer/SVG.js
 * @requires OpenLayers/Renderer/VML.js
 * @requires OpenLayers/Renderer/Canvas.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = FeatureManager
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: FeatureManager(config)
 *
 *    Plugin for a shared feature manager that other tools can reference. Works
 *    on layers added by the :class:`gxp.plugins.WMSSource` plugin, if there is
 *    a WFS resource advertized in the layer's DescribeLayer document.
 *
 *    The FeatureManager handles WFS feature loading, filtering, paging and
 *    transactions.
 */   
gxp.plugins.FeatureManager = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_featuremanager */
    ptype: "gxp_featuremanager",
    
    /** api: config[maxFeatures]
     *  ``Number`` Default is 100
     */
    maxFeatures: 100,
    
    /** api: config[paging]
     *  ``Boolean`` Should paging be enabled? Default is true.
     */
    paging: true,

    /** api: config[pagingType]
     * ``Integer`` Paging type to use, one of: 
     * gxp.plugins.FeatureManager.QUADTREE_PAGING (0) or
     * gxp.plugins.FeatureManager.WFS_PAGING (1)
     */
    pagingType: null,
    
    /** api: config[autoZoomPage]
     *  ``Boolean`` Set to true to always zoom the map to the currently
     *  selected page. Default is false.
     */
    autoZoomPage: false,

    /** api: config[autoSetLayer]
     *  ``Boolean`` When no ``layer`` is configured, listen to the viewer's
     *  layerselectionchange event to automatically set the layer. Default is
     *  true unless ``layer`` is configured.
     */
    autoSetLayer: true,
    
    /** api: config[layer]
     *  ``Object`` with source and name properties. The layer referenced here
     *  will be set as soon as it is added to the target's map. When this
     *  option is configured, ``autoSetLayer`` will be set to false.
     */

    /** api: config[autoLoadFeatures]
     *  ``Boolean`` Automatically load features after a new layer has been set?
     *  Default is false.
     */
    autoLoadFeatures: false,
    
    /** api: config[symbolizer]
     *  ``Object`` An object with "Point", "Line" and "Polygon" properties,
     *  each with a valid symbolizer object for OpenLayers. Will be used to
     *  render features.
     */
    
    /** api: config[format]
     *  ``String`` Optional response format to use for WFS GetFeature requests.
     *  Valid values are "GML2", "GML3" and "JSON". By default this is not set,
     *  which means that GML3 will be used.
     */
    
    /** api: property[layerRecord]
     *  ``GeoExt.data.LayerRecord`` The currently selected layer for this
     *  FeatureManager
     */
    layerRecord: null,
    
    /** api: property[featureStore]
     *  :class:`gxp.data.WFSFeatureStore` The FeatureStore that this tool
     *  manages.
     */
    featureStore: null,
    
    /** private: property[hitCountProtocol]
     *  ``OpenLayers.Protocol.WFS``
     */
    hitCountProtocol: null,
    
    /** api: property[featureLayer]
     *  ``OpenLayers.Layer.Vector`` The layer associated with this tool's
     *  featureStore.
     */
    featureLayer: null,
    
    /** api: property[schema]
     *  ``GeoExt.data.AttributeStore`` or false if the ``featureLayer`` has no
     *   associated WFS FeatureType, or null if no layer is currently selected.
     */
    schema: null,
    
    /** api: property[geometryType]
     *  ``String`` The geometry type of the featureLayer
     */
    geometryType: null,
    
    /** api: config[multi]
     *  ``Boolean`` If set to true, geometries will be casted to Multi
     *  geometries before writing. No casting will be done for reading.
     */
    
    /** private: property[toolsShowingLayer]
     *  ``Object`` keyed by tool id - tools that currently need to show the
     *  layer. Each entry holds a String, which is either "default" or
     *  "invisible". Selected features will always be shown, and tools setting
     *  the style to "default" take precedence over tools that set it to
     *  "invisible".
     */
    toolsShowingLayer: null,
    
    /** api: config[selectStyle]
     *  ``Object`` Style properties that override the default style for
     *  selected features.
     */
    selectStyle: null,
    
    /** private: property[style]
     *  ``Object`` with an "all" and a "selected" property, each holding an
     *  ``OpenLayers.Style``
     */
    style: null,
    
    /** private: property[pages]
     *  ``Array`` of page objects for paging mode when in QUADTREE paging mode.
     */
    pages: null,

    /** private: property[page]
     *  ``Object`` The page currently loaded (for paging mode). Has extent
     *  and numFeatures properties, only used when in QUADTREE paging mode.
     */
    page: null,

    /** private: property[numberOfFeatures]
     *  ``Integer`` The total number of features returned by the query, only
     *  used when in WFS paging mode.
     */
    numberOfFeatures: null,

    /** private: property[numPages]
     *  ``Integer`` The number of pages available, only used when in WFS
     *  paging mode.
     */
    numPages: null,

    /** private: property[pageIndex]
     *  ``Integer`` The index of the current page, starts at 0, only used in
     *  WFS paging mode.
     */
    pageIndex: null,
    
    /** private: method[constructor]
     */
    constructor: function(config) {
        this.addEvents(
            /** api: event[beforequery]
             *  Fired before a WFS GetFeature request is issued. This event
             *  can be used to abort the loadFeatures method before any action
             *  is performed, by having a listener return false.
             *
             *  Listener arguments:
             *
             *  * tool   - :class:`gxp.plugins.FeatureManager` this tool
             *  * filter - ``OpenLayers.Filter`` the filter argument passed to
             *    the loadFeatures method
             *  * callback - ``Function`` the callback argument passed to the
             *    loadFeatures method
             *  * scope - ``Object`` the scope argument passed to the
             *    loadFeatures method
             */
            "beforequery",
            
            /** api: event[query]
             *  Fired after a WFS GetFeature query, when the results are
             *  available.
             *
             *  Listener arguments:
             *
             *  * tool  - :class:`gxp.plugins.FeatureManager` this tool
             *  * store - :class:`gxp.data.WFSFeatureStore`
             *  * filter - ``OpenLayers.Filter`` the filter argument passed to
             *    the loadFeatures method
             */
            "query",
            
            /** api: event[beforelayerchange]
             *  Fired before a layer change results in destruction of the
             *  current featureStore, and creation of a new one. This event
             *  can be used to abort the setLayer method before any action is
             *  performed, by having a listener return false.
             *
             *  Listener arguments:
             *
             *  * tool  - :class:`gxp.plugins.FeatureManager` this tool
             *  * layer - ``GeoExt.data.LayerRecord`` the layerRecord argument
             *    passed to the setLayer method
             */
            "beforelayerchange",
            
            /** api: event[layerchange]
             *  Fired after a layer change, as soon as the layer's schema is
             *  available and a ``featureStore`` has been created.
             *
             *  Listener arguments:
             *
             *  * tool   - :class:`gxp.plugins.FeatureManager` this tool
             *  * layer  - ``GeoExt.data.LayerRecord`` the new layer
             *  * schema - ``GeoExt.data.AttributeStore`` or false if the
             *    layer has no associated WFS FeatureType, or null if no layer
             *    is currently selected.
             */
            "layerchange",
            
            /** api: event[beforsetpage]
             *  Fired if paging is on, before a different page is requested. This
             *  event can be used to abort the setPage method before any action
             *  is performed, by having a listener return false.
             *
             *  Listener arguments:
             *
             *  * tool      - :class:`gxp.plugins.FeatureManager` this tool
             *  * condition - ``Object`` the condition passed to the setPage
             *    method
             *  * callback  - ``Function`` the callback argument passed to the
             *    setPage method
             *  * scope     - ``Object`` the scope argument passed to the
             *    setPage method
             */
            "beforesetpage",

            /** api: event[setpage]
             *  Fired if paging is on, when a different page is set, but before
             *  its features are loaded.
             *
             *  Listener arguments:
             *
             *  * tool      - :class:`gxp.plugins.FeatureManager` this tool
             *  * condition - ``Object`` the condition passed to the setPage
             *    method
             *  * callback  - ``Function`` the callback argument passed to the
             *    setPage method
             *  * scope     - ``Object`` the scope argument passed to the
             *    setPage method
             *  * pageIndex - ``Integer`` the index of the page
             *  * numPages  - ``Integer`` the number of pages
             */
            "setpage",
            
            /** api: event[beforeclearfeatures]
             *  Fired when the clearFeatures method is called, before clearing
             *  the features. This event can be used to abort clearFeatures
             *  before any action is performed, by having a listener return
             *  false.
             *
             *  Listener arguments:
             *
             *  * tool - :class:`gxp.plugins.FeatureManager` this tool
             */
            "beforeclearfeatures",
            
            /** api: event[clearfeatures]
             *  Fired when features have been cleared by the clearFeatures
             *  method.
             *
             *  Listener arguments:
             *
             *  * tool - :class:`gxp.plugins.FeatureManager` this tool
             */
            "clearfeatures",

            /** api: event[beforesave]
             *  Fired before a transaction is saved.
             *
             *  Listener arguments:
             *
             *  * tool - :class:`gxp.plugins.FeatureManager` this tool
             *  * store - :class:`gxp.data.WFSFeatureStore`
             *  * params - ``Object`` The params object which can be used to
             *    manipulate a transaction request.
             */
            "beforesave",

            /** api: event[exception]
             * Fired when an exception occurs.
             *
             * Listener arguments:
             *
             * * tool - :class:`gxp.plugins.FeatureManager`` this tool
             * * exceptionReport - ``Object`` The exceptionReport object
             * * msg - ``String`` The exception message
             * * records - ``Array`` of ``GeoExt.data.FeatureRecord`` 
             *   The features involved in the failing transaction.
             */
            "exception"
        );

        if (config && !config.pagingType) {
            this.pagingType = gxp.plugins.FeatureManager.QUADTREE_PAGING;
        }
        
        // change autoSetLayer default if passed a layer config
        if (config && config.layer) {
            this.autoSetLayer = false;
        }
        
        gxp.plugins.FeatureManager.superclass.constructor.apply(this, arguments);        
    },
    
    /** private: method[init]
     */
    init: function(target) {
        gxp.plugins.FeatureManager.superclass.init.apply(this, arguments);
        this.toolsShowingLayer = {};
        
        this.style = {
            "all": new OpenLayers.Style(null, {
                rules: [new OpenLayers.Rule({
                    symbolizer: this.initialConfig.symbolizer || {
                        "Point": {
                            pointRadius: 4,
                            graphicName: "square",
                            fillColor: "white",
                            fillOpacity: 1,
                            strokeWidth: 1,
                            strokeOpacity: 1,
                            strokeColor: "#333333"
                        },
                        "Line": {
                            strokeWidth: 4,
                            strokeOpacity: 1,
                            strokeColor: "#ff9933"
                        },
                        "Polygon": {
                            strokeWidth: 2,
                            strokeOpacity: 1,
                            strokeColor: "#ff6633",
                            fillColor: "white",
                            fillOpacity: 0.3
                        }
                    }
                })]
            }),
            "selected": new OpenLayers.Style(null, {
                rules: [new OpenLayers.Rule({symbolizer: {display: "none"}})]
            })
        };
        
        this.featureLayer = new OpenLayers.Layer.Vector(this.id, {
            displayInLayerSwitcher: false,
            visibility: false,
            styleMap: new OpenLayers.StyleMap({
                "select": Ext.applyIf(Ext.apply({display: ""}, this.selectStyle),
                    OpenLayers.Feature.Vector.style["select"]),
                "vertex": this.style["all"]
            }, {extendDefault: false})    
        });
        
        this.target.on({
            ready: function() {
                this.target.mapPanel.map.addLayer(this.featureLayer);
            },
            //TODO add featureedit listener; update the store
            scope: this
        });
        this.on({
            //TODO add a beforedestroy event to the tool
            beforedestroy: function() {
                this.target.mapPanel.map.removeLayer(this.featureLayer);
            },
            scope: this
        });
    },
    
    /** api: method[activate]
     *  :returns: ``Boolean`` true when this tool was activated
     *
     *  Activates this tool. When active, this tool loads the features for the
     *  configured layer, or listens to layer changes on the application and
     *  loads features for the selected layer.
     */
    activate: function() {
        if (gxp.plugins.FeatureManager.superclass.activate.apply(this, arguments)) {
            if (this.autoSetLayer) {
                this.target.on("beforelayerselectionchange", this.setLayer, this);
            }
            if (this.layer) {
                var config = Ext.apply({}, this.layer);
                this.target.createLayerRecord(config, this.setLayer, this);
            }
            this.on("layerchange", this.setSchema, this);
            return true;
        }
    },
    
    /** api: method[deactivate]
     *  :returns: ``Boolean`` true when this tool was deactivated
     *
     *  Dectivates this tool. When deactivated, this tool won't listen to layer
     *  changes on the application and load features for the selected layer.
     *  The current featureLayer will be cleared.
     */
    deactivate: function() {
        if (gxp.plugins.FeatureManager.superclass.deactivate.apply(this, arguments)) {
            if (this.autoSetLayer) {
                this.target.un("beforelayerselectionchange", this.setLayer, this);
            }
            this.un("layerchange", this.setSchema, this);
            this.setLayer();
            return true;
        }
    },

    /** api: method[getPageExtent]
     *  :returns: ``OpenLayers.Bounds`` the bounds of the current page
     *
     *  Get the extent of the current page.
     */
    getPageExtent: function() {
        if (this.pagingType === gxp.plugins.FeatureManager.QUADTREE_PAGING) {
            return this.page.extent;
        } else {
            return this.featureStore.layer.getDataExtent();
        }
    },
    
    /** api: method[setLayer]
     *  :arg layerRecord: ``GeoExt.data.LayerRecord``. If not provided, the
     *      current layer will be unset.
     *  :returns: ``Boolean`` The layer was changed.
     *
     *  Sets the layer for this tool
     */
    setLayer: function(layerRecord) {
        var change = this.fireEvent("beforelayerchange", this, layerRecord);
        if (change !== false) {
            if (layerRecord) {
                // do not use getProjection here since we never want to use the 
                // map's projection on the feature layer
                this.featureLayer.projection = layerRecord.getLayer().projection;
            }
            if (layerRecord !== this.layerRecord) {
                this.clearFeatureStore();
                this.layerRecord = layerRecord;
                if (layerRecord) {
                    this.autoLoadFeatures === true ?
                        this.loadFeatures() :
                        this.setFeatureStore();
                } else {
                    this.fireEvent("layerchange", this, null);
                }
            }
        }
        return change;
    },
    
    /** private: method[setSchema]
     *  :arg mgr: :class:`gxp.plugins.FeatureManager`
     *  :arg layer: ``GeoExt.data.LayerRecord``
     *  :arg schema: ``GeoExt.data.AttributeStore``
     */
    setSchema: function(mgr, layer, schema) {
        this.schema = schema;
    },
    
    /** api: method[showLayer]
     *  :arg id: ``String`` id of a tool that needs to show this tool's
     *      featureLayer.
     *  :arg display: ``String`` "all" or "selected". Optional, default is
     *      "all"
     */
    showLayer: function(id, display) {
        this.toolsShowingLayer[id] = display || "all";
        this.setLayerDisplay();
    },
    
    /** api: method[hideLayer]
     *  :arg id: ``String`` id of a tool that no longer needs to show this
     *      tool's featureLayer. The layer will be hidden if no more tools need
     *      to show it.
     */
    hideLayer: function(id) {
        delete this.toolsShowingLayer[id];
        this.setLayerDisplay();
    },
    
    /** private: mathod[setLayerDisplay]
     *  If ``toolsShowingLayer`` has entries, the layer will be added to the
     *  map, otherwise it will be removed. Tools can choose whether they want
     *  to display all features (display == "all") or only selected features
     *  (display == "selected"). If there are both tools that want to show all
     *  features and selected features, all features will be shown.
     */
    setLayerDisplay: function() {
        var show = this.visible();
        var map = this.target.mapPanel.map;
        if (show) {
            var style = this.style[show]; // "all" or "selected"
            if (style !== this.featureLayer.styleMap.styles["default"]) {
                this.featureLayer.styleMap.styles["default"] = style;
                this.featureLayer.redraw();
            }
            this.featureLayer.setVisibility(true);
            map.events.on({
                addlayer: this.raiseLayer,
                scope: this
            });
        } else if (this.featureLayer.map) {
            this.featureLayer.setVisibility(false);
            map.events.un({
                addlayer: this.raiseLayer,
                scope: this
            });
        }
    },
    
    /** api: method[visible]
     *  :returns: ``mixed`` "all", "selected" or false
     *
     *  Are we currently showing all features, selected features only or no
     *  features?
     */
    visible: function() {
        var show = false;
        for (var i in this.toolsShowingLayer) {
            if (show != "all") {
                show = this.toolsShowingLayer[i];
            }
        }
        return show;
    },
    
    /** private: method[raiseLayer]
     *  Called whenever a layer is added to the map to keep this layer on top.
     */
    raiseLayer: function() {
        var map = this.featureLayer && this.featureLayer.map;
        if (map) {
            map.setLayerIndex(this.featureLayer, map.layers.length);
        }
    },
    
    /** api: method[loadFeatures]
     *  :arg filter: ``OpenLayers.Filter`` Optional filter for the GetFeature
     *      request.
     *  :arg callback: ``Function`` Optional callback to call when the
     *      features are loaded. This function will be called with the array
     *      of the laoded features (``OpenLayers.Feature.Vector``) as argument.
     *  :arg scope: ``Object`` Optional scope for the callback function.
     */
    loadFeatures: function(filter, callback, scope) {
        if (this.fireEvent("beforequery", this, filter, callback, scope) !== false) {
            this.filter = filter;
            this.pages = null;
            if (callback) {
                var me = this;
                // unregister previous listener, if any
                me._activeQuery && me.un("query", me._activeQuery);
                this.on("query", me._activeQuery = function(tool, store) {
                    delete me._activeQuery;
                    this.un("query", arguments.callee, this);
                    var len = store.getCount();
                    if (store.getCount() == 0) {
                        callback.call(scope, []);
                    } else {
                        // wait until the features are added to the layer,
                        // so it is easier for listeners that e.g. want to
                        // select features, which requires them to be on
                        // a layer.
                        this.featureLayer.events.register("featuresadded", this, function(evt) {
                            this.featureLayer.events.unregister("featuresadded", this, arguments.callee);
                            callback.call(scope, evt.features);
                        });
                    }
                }, this, {single: true});
            }
            if (!this.featureStore) {
                this.paging && this.on("layerchange", function(tool, rec, schema) {
                    if (schema) {
                        this.un("layerchange", arguments.callee, this);
                        this.setPage();
                    }
                }, this);
                this.setFeatureStore(filter, !this.paging);
            } else {
                this.featureStore.setOgcFilter(filter);
                if (this.paging) {
                    this.setPage();
                } else {
                    this.featureStore.load();
                }
            }
        }
    },
    
    /** api: method[clearFeatures]
     *  Unload all features.
     */
    clearFeatures: function() {
        var store = this.featureStore;
        if (store) {
            if (this.fireEvent("beforeclearfeatures", this) !== false) {
                store.removeAll();
                this.fireEvent("clearfeatures", this);
                // TODO: make abort really work in OpenLayers
                var proxy = store.proxy;
                proxy.abortRequest();
                if (proxy.protocol.response) {
                    proxy.protocol.response.abort();
                }
            }
        }
    },
    
    /** private: method[getProjection]
     *  :arg record: ``GeoExt.data.LayerRecord``
     *  :returns: ``OpenLayers.Projection``
     *
     *  Gets the appropriate projection to use for feature requests.
     *  Use layer projection if it equals the map projection, and use the 
     *  map projection otherwise.
     */
    getProjection: function(record) {
        var projection = this.target.mapPanel.map.getProjectionObject();
        var layerProj = record.getLayer().projection;
        if (layerProj && layerProj.equals(projection)) {
            projection = layerProj;
        }
        return projection;
    },
    
    /** private: method[setFeatureStore]
     *  :arg filter: ``OpenLayers.Filter``
     *  :arg autoLoad: ``Boolean``
     */
    setFeatureStore: function(filter, autoLoad) {
        var record = this.layerRecord;
        var source = this.target.getSource(record);
        if (source && source instanceof gxp.plugins.WMSSource) {
            source.getSchema(record, function(schema) {
                if (schema === false) {
                    this.clearFeatureStore();
                } else {
                    var fields = [], geometryName;
                    var geomRegex = /gml:((Multi)?(Point|Line|Polygon|Curve|Surface|Geometry)).*/;
                    var types = {
                        "xsd:boolean": "boolean",
                        "xsd:int": "int",
                        "xsd:integer": "int",
                        "xsd:short": "int",
                        "xsd:long": "int",
                        "xsd:date": "date",
                        "xsd:string": "string",
                        "xsd:float": "float",
                        "xsd:double": "float"
                    };
                    schema.each(function(r) {
                        var match = geomRegex.exec(r.get("type"));
                        if (match) {
                            geometryName = r.get("name");
                            this.geometryType = match[1];
                        } else {
                            // TODO: use (and improve if needed) GeoExt.form.recordToField
                            var type = types[r.get("type")];
                            var field = {
                                name: r.get("name"),
                                type: types[type]
                            };
                            //TODO consider date type handling in OpenLayers.Format
                            if (type == "date") {
                                field.dateFormat = "Y-m-d\\Z";
                            }
                            fields.push(field);
                        }
                    }, this);
                    
                    var protocolOptions = {
                        srsName: this.getProjection(record).getCode(),
                        url: schema.url,
                        featureType: schema.reader.raw.featureTypes[0].typeName,
                        featureNS: schema.reader.raw.targetNamespace,
                        geometryName: geometryName
                    };
                    this.hitCountProtocol = new OpenLayers.Protocol.WFS(Ext.apply({
                        version: "1.1.0",
                        readOptions: {output: "object"},
                        resultType: "hits",
                        filter: filter
                    }, protocolOptions));
                    this.featureStore = new gxp.data.WFSFeatureStore(Ext.apply({
                        fields: fields,
                        proxy: {
                            protocol: {
                                outputFormat: this.format,
                                multi: this.multi
                            }
                        },
                        maxFeatures: this.maxFeatures,
                        layer: this.featureLayer,
                        ogcFilter: filter,
                        autoLoad: autoLoad,
                        autoSave: false,
                        listeners: {
                            "beforewrite": function(store, action, rs, options) {
                                this.fireEvent("beforesave", this, store, options.params);
                            },
                            "write": function(store, action, result, res, rs) {
                                this.redrawMatchingLayers(record);
                            },
                            "load": function(store, rs, options) {
                                this.fireEvent("query", this, store, this.filter);
                            },
                            scope: this
                        }
                    }, protocolOptions));
                }
                this.fireEvent("layerchange", this, record, schema);
            }, this);
        } else {
            this.clearFeatureStore();
            this.fireEvent("layerchange", this, record, false);
        }        
    },
    
    /** private: method[redrawMatchingLayers]
     *  :arg record: ``GeoExt.data.LayerRecord``
     *
     *  Called after features have been edited.  This method redraws all map
     *  layers with the same name & source as the provided layer record.
     */
    redrawMatchingLayers: function(record) {
        var name = record.get("name");
        var source = record.get("source");
        this.target.mapPanel.layers.each(function(candidate) {
            if (candidate.get("source") === source && candidate.get("name") === name) {
                candidate.getLayer().redraw(true);
            }
        });
    },
    
    /** private: method[clearFeatureStore]
     */
    clearFeatureStore: function() {
        if (this.featureStore) {
            //TODO remove when http://trac.geoext.org/ticket/367 is resolved
            this.featureStore.removeAll();
            this.featureStore.unbind();
            // end remove
            this.featureStore.destroy();
            this.numberOfFeatures = null;
            this.featureStore = null;
            this.geometryType = null;
        }
    },

    /** private: method[processPage]
     *  :arg page: ``Object`` The page to process.
     *  :arg condition: ``Object`` Object with index, next or lonLat
     *      properties. See ``setPage``.
     *  :arg callback: ``Function`` Callback to call when the requested page
     *      is available. Called with the page as 1st argument.
     *  :arg scope: ``The scope for the callback.
     *
     *  Takes a page, which still may have more features than ``maxFeatures``
     *  in its extent, creates leaves if necessary, and returns the correct
     *  leaf in a callback function.
     */
    processPage: function (page, condition, callback, scope) {
        condition = condition || {};
        var index = condition.lonLat ? null : condition.index;
        var next = condition.next;
        var pages = this.pages;
        var i = this.pages.indexOf(page);
        this.setPageFilter(page);
        var nextOk = next ?
            i == (pages.indexOf(next) || pages.length) - 1 : true;
        var lonLatOk = condition.lonLat ?
            page.extent.containsLonLat(condition.lonLat) : true;
        if (lonLatOk && page.numFeatures && page.numFeatures <= this.maxFeatures) {
            // nothing to do, leaf is a valid page
            callback.call(this, page);
        } else if (lonLatOk && (i == index || nextOk)) {
            // get the hit count if the page is relevant for the requested index
            this.hitCountProtocol.read({
                callback: function(response) {
                    var i = index, lonLat = condition.lonLat;
                    if (next) {
                        i = (pages.indexOf(next) || pages.length) - 1;
                    }
                    if (!i && lonLat && page.extent.containsLonLat(lonLat)) {
                        i = pages.indexOf(page);
                    }
                    page.numFeatures = response.numberOfFeatures;
                    if (this.page) {
                        return;
                    }
                    if (page.numFeatures > this.maxFeatures) {
                        this.createLeaf(page, Ext.applyIf({
                            index: i,
                            next: next
                        }, condition), callback, scope);
                    } else if (page.numFeatures == 0 && pages.length > 1) {
                        // remove page, unless it's the only one (which means
                        // that loadFeatures returned no features)
                        pages.remove(page);
                        // move to the next page if the removed page would have
                        // been the one for our location
                        condition.allowEmpty === false && this.setPage({
                            index: index % this.pages.length,
                            allowEmpty: false
                        });
                    } else if (this.pages.indexOf(page) == i) {
                        callback.call(this, page);
                    }
                },
                scope: this
            });
        }
    },
    
    /** private: method[createLeaf]
     *  :arg page: ``Object`` The page to process.
     *  :arg condition: ``Object`` Object with index, next or lonLat
     *      properties. See ``setPage``.
     *  :arg callback: ``Function`` Callback to call when the requested page
     *      is available. Called with the page as 1st argument.
     *  :arg scope: ``The scope for the callback.
     *
     *  Creates the 4 leaves for a page, and calls processPage on each.
     */
    createLeaf: function(page, condition, callback, scope) {
        condition = condition || {};
        var layer = this.layerRecord.getLayer();
        var pageIndex = this.pages.indexOf(page);
        // replace the page with its 4 subpages, so we remove it first.
        this.pages.remove(page);
        var extent = page.extent;
        var center = extent.getCenterLonLat();
        var l = [extent.left, center.lon, extent.left, center.lon];
        var b = [center.lat, center.lat, extent.bottom, extent.bottom];
        var r = [center.lon, extent.right, center.lon, extent.right];
        var t = [extent.top, extent.top, center.lat, center.lat];
        var i, leaf;
        for (i=3; i>=0; --i) {
            leaf = {extent: new OpenLayers.Bounds(l[i], b[i], r[i], t[i])};
            this.pages.splice(pageIndex, 0, leaf);
            this.processPage(leaf, condition, callback, scope);
        }
    },
    
    /** private: method[getPagingExtent]
     *  :arg meth: ``String`` Method to call on the target's map when neither
     *      a filter extent nor a layer extent are available. Useful values
     *      are "getExtent" and "getMaxExtent".
     *  :returns: ``OpenLayers.Bounds`` the extent to use for paging
     *
     *  Gets the extent to use for the root of the paging quad-tree.
     */
    getPagingExtent: function(meth) {
        var layer = this.layerRecord.getLayer();
        var filter = this.getSpatialFilter();
        var extent = filter ? filter.value : this.target.mapPanel.map[meth]();
        if (extent && layer.maxExtent) {
            if (extent.containsBounds(layer.maxExtent)) {
                // take the smaller one of the two
                extent = layer.maxExtent;
            }
        }
        return extent;
    },
    
    /** private: method[getSpatialFilter]
     *  :returns: ``OpenLayers.Filter.Spatial``
     *
     * Extracts the spatial part of the ``filter`` that is currently set.
     */
    getSpatialFilter: function() {
        var filter;
        if (this.filter instanceof OpenLayers.Filter.Spatial && this.filter.type === OpenLayers.Filter.Spatial.BBOX) {
            filter = this.filter;
        } else if (this.filter instanceof OpenLayers.Filter.Logical && this.filter.type === OpenLayers.Filter.Logical.AND) {
            for (var f, i=this.filter.filters.length-1; i>=0; --i) {
                f = this.filter.filters[i];
                if (f instanceof OpenLayers.Filter.Spatial && f.type === OpenLayers.Filter.Spatial.BBOX) {
                    filter = f;
                    break;
                }
            }
        }
        return filter;
    },
    
    /** private: method[setPageFilter]
     *  :arg page: ``Object`` The page to create the filter for
     *  :returns: ``OpenLayers.Filter`` The filter to use for the provided page
     *
     *  Creates the filter for a page's extent. This wraps the query filter,
     *  if any.
     */
    setPageFilter: function(page) {
        var filter;
        if (page.extent) {
            var bboxFilter = new OpenLayers.Filter.Spatial({
                type: OpenLayers.Filter.Spatial.BBOX,
                property: this.featureStore.geometryName,
                value: page.extent
            });
            filter = this.filter ?
                new OpenLayers.Filter.Logical({
                    type: OpenLayers.Filter.Logical.AND,
                    filters: [this.filter, bboxFilter]
                }) : bboxFilter;
        } else {
            filter = this.filter;
        }
        this.featureStore.setOgcFilter(filter);
        //TODO the protocol could use a setFilter method
        // http://trac.osgeo.org/openlayers/ticket/3201
        this.hitCountProtocol.filter = filter;
        this.hitCountProtocol.options.filter = filter;
        return filter;
    },
    
    /** api: method[nextPage]
     *  :arg callback: ``Function`` Optional callback to call when the page
     *      is available. The callback will receive the page as 1st argument.
     *  :arg scope: ``Object`` Optional scope for the callback.
     *
     *  Load the next page.
     */
    nextPage: function(callback, scope) {
        var index;
        if (this.pagingType === gxp.plugins.FeatureManager.QUADTREE_PAGING) {
            var page = this.page;
            this.page = null;
            index = (this.pages.indexOf(page) + 1) % this.pages.length;
        } else {
            index = this.pageIndex+1 % this.numPages;
        }
        this.setPage({index: index, allowEmpty: false}, callback, scope);
    },
    
    /** api: method[previousPage]
     *  :arg callback: ``Function`` Optional callback to call when the page
     *      is available. The callback will receive the page as 1st argument.
     *  :arg scope: ``Object`` Optional scope for the callback.
     *
     *  Load the previous page.
     */
    previousPage: function(callback, scope) {
        var index;
        if (this.pagingType === gxp.plugins.FeatureManager.QUADTREE_PAGING) {
            index = this.pages.indexOf(this.page) - 1;
            if (index < 0) {
                index = this.pages.length - 1;
            }
        } else {
            index = this.pageIndex-1;
            if (index < 0) {
                index = this.numPages - 1;
            }
        }
        this.setPage({index: index, allowEmpty: false, next: this.page}, callback);
    },
    
    /** api: method[setPage]
     *  :arg condition: ``Object`` Object to tell the method which page to set.
     *      If "lonLat" (``OpenLayers.LonLat``) is provided, the page
     *      containing the provided location will be loaded.
     *      If only an "index" property (pointing to a page in this tool's
     *      pages array) is provided, the method will load the according page
     *      if it has less then ``maxFeatures`` features. If it does not,
     *      leaves will be created until the top-left page has less than
     *      ``maxFeatures``, and this top-left page will be loaded. If index is
     *      "last", the last page of the quad-tree will be loaded. If an
     *      additional "next" property is provided (a page object is expected
     *      here), the page that would be loaded with ``previousPage`` called
     *      from the provided page will be set. This is the bottom-right page
     *      of the page pointed to with "index".
     *      If the resulting page would be empty, and "allowEmpty" is false,
     *      the next matching page will be loaded.
     *  :arg callback: ``Function`` Optional callback to call when the page
     *      is available. The callback will receive the page as 1st argument.
     *  :arg scope: ``Object`` Optional scope for the callback.
     *
     *  Sets and loads the page specified by the condition argument. This is
     *  usually used to load a page for a specific location, or to load the
     *  first or last page of the quad tree.
     *
     *  Sample code to load the page that contains the (0, 0) location:
     *
     *  .. code-block:: javascript
     *
     *      featureManager.setPage({lonLat: new OpenLayers.LonLat(0, 0)});
     *
     *  Sample code to load the first page of the quad-tree:
     *
     *  .. code-block:: javascript
     *
     *      featureManager.setPage({index: 0});
     *
     *  Sample code to load the last page of the quad-tree:
     *
     *  .. code-block:: javascript
     *
     *      featureManager.setPage({index: "last"});
     *
     *  Sample code to load the first page that contains features:
     *
     *  .. code-block:: javascript
     *
     *      featureManager.setPage();
     */
    setPage: function(condition, callback, scope) {
        if (this.pagingType === gxp.plugins.FeatureManager.QUADTREE_PAGING) {
            if (this.filter instanceof OpenLayers.Filter.FeatureId) {
                // no paging for FeatureId filters - these cannot be combined with
                // BBOX filters
                this.featureStore.load({callback: function() {
                    callback && callback.call(scope);
                }});
                return;
            }
            if (this.fireEvent("beforesetpage", this, condition, callback, scope) !== false) {
                if (!condition) {
                    // choose a page on the top left
                    var extent = this.getPagingExtent("getExtent");
                    var lonLat = new OpenLayers.LonLat(extent.left, extent.top);
                    // detect corner coordinate outside maxExtent and fall back
                    // to maxExtent
                    var maxExtent = this.target.mapPanel.map.getMaxExtent();
                    if (!maxExtent.containsLonLat(lonLat, true)) {
                        lonLat = new OpenLayers.LonLat(maxExtent.left, maxExtent.top);
                    }
                    condition = {
                        lonLat: lonLat,
                        allowEmpty: false
                    };
                }
                condition.index = condition.index || 0;
                if (condition.index == "last") {
                    condition.index = this.pages.length - 1;
                    condition.next = this.pages[0];
                }
                this.page = null;
                if (!this.pages) {
                    var layer = this.layerRecord.getLayer();
                    var queryExtent = this.getPagingExtent("getMaxExtent");
                    this.pages = [{extent: queryExtent}];
                    condition.index = 0;
                } else if (condition.lonLat) {
                    for (var i=this.pages.length-1; i>=0; --i) {
                        if (this.pages[i].extent.containsLonLat(condition.lonLat)) {
                            condition.index = i;
                            break;
                        }
                    }
                }
                this.processPage(this.pages[condition.index], condition,
                    function(page) {
                        var map = this.target.mapPanel.map;
                        this.page = page;
                        this.setPageFilter(page);
                        if (this.autoZoomPage && !map.getExtent().containsLonLat(page.extent.getCenterLonLat())) {
                            map.zoomToExtent(page.extent);
                        }
                        var pageIndex = this.pages.indexOf(this.page);
                        this.fireEvent("setpage", this, condition, callback, scope, pageIndex, this.pages.length);
                        this.featureStore.load({callback: function() {
                            callback && callback.call(scope, page);
                        }});
                    }, this
                );
            }
        } else {
            if (this.fireEvent("beforesetpage", this, condition, callback, scope) !== false) {
                if (!condition) {
                    this.hitCountProtocol.read({
                        filter: this.filter,
                        callback: function(response) {
                            this.numberOfFeatures = response.numberOfFeatures;
                            this.numPages = Math.ceil(this.numberOfFeatures/this.maxFeatures);
                            this.pageIndex = 0;
                            this.fireEvent("setpage", this, condition, callback, scope, this.pageIndex, this.numPages);
                            this.featureStore.load({output: "object", callback: function() {
                                callback && callback.call(scope);
                            }});
                        },
                        scope: this
                    });
                } else {
                    if (condition.index != null) {
                        if (condition.index === "last") {
                            this.pageIndex = this.numPages-1;
                        } else if (condition.index === "first") {
                            this.pageIndex = 0;
                        } else {
                            this.pageIndex = condition.index;
                        }
                        var startIndex = this.pageIndex*this.maxFeatures;
                        this.fireEvent("setpage", this, condition, callback, scope, this.pageIndex, this.numPages);
                        this.featureStore.load({startIndex: startIndex, callback: function() {
                            callback && callback.call(scope);
                        }});
                    }
                }
            }
        }
    }
    
});

/**
 * Paging types
 */
gxp.plugins.FeatureManager.QUADTREE_PAGING = 0;
gxp.plugins.FeatureManager.WFS_PAGING = 1;

Ext.preg(gxp.plugins.FeatureManager.prototype.ptype, gxp.plugins.FeatureManager);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = FeatureToField
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: FeatureToField(config)
 *
 *    Plugin for serializing the currently selected feature to the form field
 *    of a :class:`gxp.form.ViewerField`. Requires a
 *    :class:`gxp.plugins.FeatureManager` and a tool that selects features
 *    (e.g. :class:`gxp.plugins.FeatureEditor`).
 */   
gxp.plugins.FeatureToField = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_featuretofield */
    ptype: "gxp_featuretofield",
    
    /** api: config[featureManager]
     *  ``String`` :class:`FeatureManager` to use for this tool.
     */
     
    /** api: config[format]
     *  ``String`` The format to use for encoding the feature. Defaults to
     *  "GeoJSON", which means ``OpenLayers.Format.GeoJSON``. All
     *  OpenLayers.Format.* formats that can serialize a single feature can be
     *  used here.
     */
    format: "GeoJSON",
    
    /** api: method[addActions]
     */
    addActions: function() {
        var featureManager = this.target.tools[this.featureManager];
        var featureInField;
        var format = new OpenLayers.Format[this.format];
        featureManager.featureLayer.events.on({
            "featureselected": function(evt) {
                this.target.field.setValue(format.write(evt.feature));
                featureInField = evt.feature;
            },
            "featureunselected": function() {
                this.target.field.setValue("");
                featureInField = null;
            },
            scope: this
        });
        featureManager.on("layerchange", function() {
            featureManager.featureStore && featureManager.featureStore.on("save", function(store, batch, data) {
                if (data.create) {
                    var i, feature;
                    for (i=data.create.length-1; i>=0; --i) {
                        //TODO check why the WFSFeatureStore returns an object
                        // here instead of a record
                        feature = data.create[i].feature;
                        if (feature == featureInField) {
                            this.target.field.setValue(format.write(feature));
                        }
                    }
                }
            }, this);
        });
        
        return gxp.plugins.FeatureToField.superclass.addActions.apply(this, arguments);
    }
        
});

Ext.preg(gxp.plugins.FeatureToField.prototype.ptype, gxp.plugins.FeatureToField);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 * @include widgets/FilterBuilder.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = QueryForm
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: QueryForm(config)
 *
 *    Plugin for performing queries on feature layers
 *    TODO Replace this tool with something that is less like GeoEditor and
 *    more like filtering.
 */
gxp.plugins.QueryForm = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_queryform */
    ptype: "gxp_queryform",

    /** api: config[featureManager]
     *  ``String`` The id of the :class:`gxp.plugins.FeatureManager` to use
     *  with this tool.
     */
    featureManager: null,
    
    /** api: config[autoHide]
     *  ``Boolean`` Set to true if the output of this tool goes into an
     *  ``Ext.Window`` that should be hidden when the query result is
     *  available. Default is false.
     */
    autoHide: false,

    /** private: property[schema]
     *  ``GeoExt.data.AttributeStore``
     */
    schema: null,
    
    /** api: config[queryActionText]
     *  ``String``
     *  Text for query action (i18n).
     */
    queryActionText: "Query",
    
    /** api: config[cancelButtonText]
     *  ``String``
     *  Text for cancel button (i18n).
     */
    cancelButtonText: "Cancel",

    /** api: config[queryMenuText]
     *  ``String``
     *  Text for query menu item (i18n).
     */
    queryMenuText: "Query layer",

    /** api: config[queryActionTip]
     *  ``String``
     *  Text for query action tooltip (i18n).
     */
    queryActionTip: "Query the selected layer",

    /** api: config[queryByLocationText]
     *  ``String``
     *  Text for query by location (i18n).
     */
    queryByLocationText: "Query by current map extent",

    /** api: config[queryByAttributesText]
     *  ``String``
     *  Text for query by attributes (i18n).
     */
    queryByAttributesText: "Query by attributes",
    
    /** api: config[queryMsg]
     *  ``String``
     *  Text for query load mask (i18n).
     */
    queryMsg: "Querying...",
    
    /** api: config[noFeaturesTitle]
     *  ``String``
     *  Text for no features alert title (i18n)
     */
    noFeaturesTitle: "No Match",

    /** api: config[noFeaturesMsg]
     *  ``String``
     *  Text for no features alert message (i18n)
     */
    noFeaturesMessage: "Your query did not return any results.",

    /** api: config[actions]
     *  ``Object`` By default, this tool creates a "Query" action to trigger
     *  the output of this tool's form. Set to null if you want to include
     *  the form permanently in your layout.
     */
    
    /** api: config[outputAction]
     *  ``Number`` By default, the "Query" action will trigger this tool's
     *  form output. There is no need to change this unless you configure
     *  custom ``actions``.
     */
    outputAction: 0,
    
    /** api: config[autoExpand]
     *  ``String`` If set to the id of a container, the container will be
     *  expanded when the Query Form is enabled, and collapsed when it is
     *  disabled. Once the user manually expands/collapses the contaienr, the
     *  user setting will stick for the current session.
     */
    autoExpand: null,
    
    /** api: method[addActions]
     */
    addActions: function(actions) {
        if (!this.initialConfig.actions && !actions) {
            actions = [{
                text: this.queryActionText,
                menuText: this.queryMenuText,
                iconCls: "gxp-icon-find",
                tooltip: this.queryActionTip,
                disabled: true,
                toggleGroup: this.toggleGroup,
                enableToggle: true,
                allowDepress: true,
                toggleHandler: function(button, pressed) {
                    if (this.autoExpand && this.output.length > 0) {
                        var expandContainer = Ext.getCmp(this.autoExpand);
                        expandContainer[pressed ? 'expand' : 'collapse']();
                        if (pressed) {
                            expandContainer.expand();
                            if (expandContainer.ownerCt && expandContainer.ownerCt instanceof Ext.Panel) {
                                expandContainer.ownerCt.expand();
                            }
                        } else {
                            this.target.tools[this.featureManager].loadFeatures();
                        }
                    }
                },
                scope: this
            }];
        }
        this.actions = gxp.plugins.QueryForm.superclass.addActions.apply(this, actions);
        // support custom actions
        if (this.actionTarget !== null && this.actions) {
            this.target.tools[this.featureManager].on("layerchange", function(mgr, rec, schema) {
                for (var i=this.actions.length-1; i>=0; --i) {
                    this.actions[i].setDisabled(!schema);
                }
            }, this);
        }
    },

    /** api: method[addOutput]
     */
    addOutput: function(config) {
        var featureManager = this.target.tools[this.featureManager];

        config = Ext.apply({
            border: false,
            bodyStyle: "padding: 10px",
            layout: "form",
            width: 320,
            autoScroll: true,
            items: [{
                xtype: "fieldset",
                ref: "spatialFieldset",
                title: this.queryByLocationText,
                anchor: "97%",
                // This fieldset never expands
                style: "margin-bottom:0; border-left-color:transparent; border-right-color:transparent; border-width:1px 1px 0 1px; padding-bottom:0",
                checkboxToggle: true
            }, {
                xtype: "fieldset",
                ref: "attributeFieldset",
                title: this.queryByAttributesText,
                anchor: "97%",
                style: "margin-bottom:0",
                checkboxToggle: true
            }],
            bbar: ["->", {
                text: this.cancelButtonText,
                iconCls: "cancel",
                handler: function() {
                    var ownerCt = this.outputTarget ? queryForm.ownerCt :
                        queryForm.ownerCt.ownerCt;
                    if (ownerCt && ownerCt instanceof Ext.Window) {
                        ownerCt.hide();
                    }
                    addFilterBuilder(
                        featureManager, featureManager.layerRecord,
                        featureManager.schema
                    );
                    featureManager.loadFeatures();
                }
            }, {
                text: this.queryActionText,
                iconCls: "gxp-icon-find",
                handler: function() {
                    var filters = [];
                    if (queryForm.spatialFieldset.collapsed !== true) {
                        filters.push(new OpenLayers.Filter.Spatial({
                            type: OpenLayers.Filter.Spatial.BBOX,
                            property: featureManager.featureStore.geometryName,
                            value: this.target.mapPanel.map.getExtent()
                        }));
                    }
                    if (queryForm.attributeFieldset.collapsed !== true) {
                        var attributeFilter = queryForm.filterBuilder.getFilter();
                        attributeFilter && filters.push(attributeFilter);
                    }
                    featureManager.loadFeatures(filters.length > 1 ?
                        new OpenLayers.Filter.Logical({
                            type: OpenLayers.Filter.Logical.AND,
                            filters: filters
                        }) :
                        filters[0]
                    );
                },
                scope: this
            }]
        }, config || {});
        var queryForm = gxp.plugins.QueryForm.superclass.addOutput.call(this, config);
        
        var expandContainer = null, userExpand = true;
        if (this.autoExpand) {
            expandContainer = Ext.getCmp(this.autoExpand);
            function stopAutoExpand() {
                if (userExpand) {
                    expandContainer.un('expand', stopAutoExpand);
                    expandContainer.un('collapse', stopAutoExpand);
                    expandContainer = null;
                }
                userExpand = true;
            }
            expandContainer.on({
                'expand': stopAutoExpand,
                'collapse': stopAutoExpand
            });
        }
        var addFilterBuilder = function(mgr, rec, schema) {
            queryForm.attributeFieldset.removeAll();
            queryForm.setDisabled(!schema);
            if (expandContainer) {
                userExpand = false;
                expandContainer[schema ? 'expand' : 'collapse']();
                // if we're wrapped in another collapsed container, expand it
                if (schema && expandContainer && expandContainer.ownerCt && expandContainer.ownerCt instanceof Ext.Panel) {
                    expandContainer.ownerCt.expand();
                }
            }
            if (schema) {
                queryForm.attributeFieldset.add({
                    xtype: "gxp_filterbuilder",
                    ref: "../filterBuilder",
                    attributes: schema,
                    allowBlank: true,
                    allowGroups: false
                });
                queryForm.spatialFieldset.expand();
                queryForm.attributeFieldset.expand();
            } else {
                queryForm.attributeFieldset.rendered && queryForm.attributeFieldset.collapse();
                queryForm.spatialFieldset.rendered && queryForm.spatialFieldset.collapse();
            }
            queryForm.attributeFieldset.doLayout();
        };
        featureManager.on("layerchange", addFilterBuilder);
        addFilterBuilder(featureManager,
            featureManager.layerRecord, featureManager.schema
        );
        
        featureManager.on({
            "beforequery": function() {
                new Ext.LoadMask(queryForm.getEl(), {
                    store: featureManager.featureStore,
                    msg: this.queryMsg
                }).show();
            },
            "query": function(tool, store) {
                if (store) {
                    if (this.target.tools[this.featureManager].featureStore !== null) {
                        store.getCount() || Ext.Msg.show({
                            title: this.noFeaturesTitle,
                            msg: this.noFeaturesMessage,
                            buttons: Ext.Msg.OK,
                            icon: Ext.Msg.INFO
                        });
                        if (this.autoHide) {
                            var ownerCt = this.outputTarget ? queryForm.ownerCt :
                                queryForm.ownerCt.ownerCt;
                            ownerCt instanceof Ext.Window && ownerCt.hide();
                        }
                    }
                }
            },
            scope: this
        });
        
        return queryForm;
    }
        
});

Ext.preg(gxp.plugins.QueryForm.prototype.ptype, gxp.plugins.QueryForm);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 * @requires GeoExt/widgets/tree/LayerNode.js
 * @requires GeoExt/widgets/tree/TreeNodeUIEventMixin.js
 * @requires GeoExt/widgets/tree/LayerContainer.js
 * @requires GeoExt/widgets/tree/LayerLoader.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = LayerTree
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: LayerTree(config)
 *
 *    Plugin for adding a tree of layers to a :class:`gxp.Viewer`. Also
 *    provides a context menu on layer nodes.
 */   
gxp.plugins.LayerTree = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_layertree */
    ptype: "gxp_layertree",
    
    /** api: config[shortTitle]
     *  ``String``
     *  Short title text for this plugin's output (i18n)
     */
    shortTitle: "Layers",

    /** api: config[rootNodeText]
     *  ``String``
     *  Text for root node of layer tree (i18n).
     */
    rootNodeText: "Layers",

    /** api: config[overlayNodeText]
     *  ``String``
     *  Text for overlay node of layer tree (i18n).
     */
    overlayNodeText: "Overlays",

    /** api: config[baseNodeText]
     *  ``String``
     *  Text for baselayer node of layer tree (i18n).
     */
    baseNodeText: "Base Layers",
    
    /** api: config[groups]
     *  ``Object`` The groups to show in the layer tree. Keys are group names,
     *  and values are either group titles or an object with ``title`` and
     *  ``exclusive`` properties. ``exclusive``, if Boolean, means that nodes
     *  will have radio buttons instead of checkboxes, so only one layer of the
     *  group can be active at a time. If String, ``exclusive`` can be used to
     *  create exclusive sets of layers among several groups, by assigning the
     *  same string to each group. Optional, the default is
     *
     *  .. code-block:: javascript
     *
     *      groups: {
     *          "default": "Overlays", // title can be overridden with overlayNodeText
     *          "background": {
     *              title: "Base Layers", // can be overridden with baseNodeText
     *              exclusive: true
     *          }
     *      }
     */
    groups: null,
    
    /** api: config[defaultGroup]
     *  ``String`` The name of the default group, i.e. the group that will be
     *  used when none is specified. Defaults to ``default``.
     */
    defaultGroup: "default",
    
    /** private: config[treeNodeUI]
     *  ``Ext.tree.TreeNodeUI``
     */
    treeNodeUI: null,
    
    /** private: method[constructor]
     *  :arg config: ``Object``
     */
    constructor: function(config) {
        gxp.plugins.LayerTree.superclass.constructor.apply(this, arguments);
        if (!this.groups) {
            this.groups = {
                "default": this.overlayNodeText,
                "background": {
                    title: this.baseNodeText,
                    exclusive: true
                }
            };
        }
        if (!this.treeNodeUI) {
            this.treeNodeUI = Ext.extend(
                GeoExt.tree.LayerNodeUI,
                new GeoExt.tree.TreeNodeUIEventMixin()
            );
        }
    },
    
    /** private: method[addOutput]
     *  :arg config: ``Object``
     *  :returns: ``Ext.Component``
     */
    addOutput: function(config) {
        config = Ext.apply(this.createOutputConfig(), config || {});
        var output = gxp.plugins.LayerTree.superclass.addOutput.call(this, config);
        output.on({
            contextmenu: this.handleTreeContextMenu,
            beforemovenode: this.handleBeforeMoveNode,
            scope: this
        });
        return output;
    },
    
    /** private: method[createOutputConfig]
     *  :returns: ``Object`` Configuration object for an Ext.tree.TreePanel
     */
    createOutputConfig: function() {
        var treeRoot = new Ext.tree.TreeNode({
            text: this.rootNodeText,
            expanded: true,
            isTarget: false,
            allowDrop: false
        });

        var baseAttrs;
        if (this.initialConfig.loader && this.initialConfig.loader.baseAttrs) {
            baseAttrs = this.initialConfig.loader.baseAttrs;
        }
        
        var defaultGroup = this.defaultGroup,
            plugin = this,
            groupConfig,
            exclusive;
        for (var group in this.groups) {
            groupConfig = typeof this.groups[group] == "string" ?
                {title: this.groups[group]} : this.groups[group];
            exclusive = groupConfig.exclusive;
            treeRoot.appendChild(new GeoExt.tree.LayerContainer(Ext.apply({
                text: groupConfig.title,
                iconCls: "gxp-folder",
                expanded: true,
                group: group == this.defaultGroup ? undefined : group,
                loader: new GeoExt.tree.LayerLoader({
                    baseAttrs: exclusive ?
                        Ext.apply({checkedGroup: Ext.isString(exclusive) ? exclusive : group}, baseAttrs) :
                        baseAttrs,
                    store: this.target.mapPanel.layers,
                    filter: (function(group) {
                        return function(record) {
                            return (record.get("group") || defaultGroup) == group &&
                                record.getLayer().displayInLayerSwitcher == true;
                        };
                    })(group),
                    createNode: function(attr) {
                        plugin.configureLayerNode(this, attr);
                        return GeoExt.tree.LayerLoader.prototype.createNode.apply(this, arguments);
                    }
                }),
                singleClickExpand: true,
                allowDrag: false,
                listeners: {
                    append: function(tree, node) {
                        node.expand();
                    }
                }
            }, groupConfig)));
        }
        
        return {
            xtype: "treepanel",
            root: treeRoot,
            rootVisible: false,
            shortTitle: this.shortTitle,
            border: false,
            enableDD: true,
            selModel: new Ext.tree.DefaultSelectionModel({
                listeners: {
                    beforeselect: this.handleBeforeSelect,
                    scope: this
                }
            }),
            contextMenu: new Ext.menu.Menu({
                items: []
            })
        };
    },
    
    /** private: method[configureLayerNode]
     *  :arg loader: ``GeoExt.tree.LayerLoader``
     *  :arg node: ``Object`` The node
     */
    configureLayerNode: function(loader, attr) {
        attr.uiProvider = this.treeNodeUI;
        var layer = attr.layer;
        var store = attr.layerStore;
        if (layer && store) {
            var record = store.getAt(store.findBy(function(r) {
                return r.getLayer() === layer;
            }));
            if (record) {
                attr.qtip = record.get('abstract');
                if (!record.get("queryable") && !attr.iconCls) {
                    attr.iconCls = "gxp-tree-rasterlayer-icon";
                }
                if (record.get("fixed")) {
                    attr.allowDrag = false;
                }
                attr.listeners = {
                    rendernode: function(node) {
                        if (record === this.target.selectedLayer) {
                            node.select();
                        }
                        this.target.on("layerselectionchange", function(rec) {
                            if (!this.selectionChanging && rec === record) {
                                node.select();
                            }
                        }, this);
                    },
                    scope: this
                };
            }
        }
    },
    
    /** private: method[handleBeforeSelect]
     */
    handleBeforeSelect: function(selModel, node) {
         var changed = true;
         var layer = node && node.layer;
         var record;
         if (layer) {
             var store = node.layerStore;
             record = store.getAt(store.findBy(function(r) {
                 return r.getLayer() === layer;
             }));
         }
         this.selectionChanging = true;
         changed = this.target.selectLayer(record);
         this.selectionChanging = false;
         return changed;
     },
     
    /** private: method[handleTreeContextMenu]
     */
    handleTreeContextMenu: function(node, e) {
        if(node && node.layer) {
            node.select();
            var tree = node.getOwnerTree();
            if (tree.getSelectionModel().getSelectedNode() === node) {
                var c = tree.contextMenu;
                c.contextNode = node;
                c.items.getCount() > 0 && c.showAt(e.getXY());
            }
        }
    },
    
    /** private: method[handleBeforeMoveNode]
     */
    handleBeforeMoveNode: function(tree, node, oldParent, newParent, i) {
        // change the group when moving to a new container
        if(oldParent !== newParent) {
            var store = newParent.loader.store;
            var index = store.findBy(function(r) {
                return r.getLayer() === node.layer;
            });
            var record = store.getAt(index);
            record.set("group", newParent.attributes.group);
        }
    }
        
});

Ext.preg(gxp.plugins.LayerTree.prototype.ptype, gxp.plugins.LayerTree);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @require plugins/LayerTree.js
 * @require GeoExt/plugins/TreeNodeComponent.js
 * @require GeoExt/widgets/WMSLegend.js
 * @require GeoExt/widgets/VectorLegend.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = LayerManager
 */

/** api: (extends)
 *  plugins/LayerTree.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: LayerManager(config)
 *
 *    Plugin for adding a tree of layers with their legend to a
 *    :class:`gxp.Viewer`. Also provides a context menu on layer nodes.
 */   
/** api: example
 *  If you want to change the vendor-specific legend_options parameter that 
 *  is sent to the WMS for GetLegendGraphic you can use ``baseAttrs`` on the
 *  ``loader`` config:
 *
 *  .. code-block:: javascript
 *
 *    var layerManager = new gxp.plugins.LayerManager({
 *        loader: {
 *            baseAttrs: {
 *                baseParams: {
 *                    legend_options: "fontAntiAliasing:true;fontSize:11;fontName:Arial;fontColor:#FFFFFF"
 *                }
 *            }
 *        }
 *    });
 *
 */
gxp.plugins.LayerManager = Ext.extend(gxp.plugins.LayerTree, {
    
    /** api: ptype = gxp_layermanager */
    ptype: "gxp_layermanager",

    /** api: config[baseNodeText]
     *  ``String``
     *  Text for baselayer node of layer tree (i18n).
     */
    baseNodeText: "Base Maps",
    
    /** api: config[groups]
     *  ``Object`` The groups to show in the layer tree. Keys are group names,
     *  and values are either group titles or an object with ``title`` and
     *  ``exclusive`` properties. ``exclusive`` means that nodes will have
     *  radio buttons instead of checkboxes, so only one layer of the group can
     *  be active at a time. Optional, the default is
     *
     *  .. code-block:: javascript
     *
     *      groups: {
     *          "default": "Overlays", // title can be overridden with overlayNodeText
     *          "background": {
     *              title: "Base Maps", // can be overridden with baseNodeText
     *              exclusive: true
     *          }
     *      }
     */
    
    /** private: method[createOutputConfig] */
    createOutputConfig: function() {
        var tree = gxp.plugins.LayerManager.superclass.createOutputConfig.apply(this, arguments);
        Ext.applyIf(tree, Ext.apply({
            cls: "gxp-layermanager-tree",
            lines: false,
            useArrows: true,
            plugins: [{
                ptype: "gx_treenodecomponent"
            }]
        }, this.treeConfig));
        
        return tree;        
    },
    
    /** private: method[configureLayerNode] */
    configureLayerNode: function(loader, attr) {
        gxp.plugins.LayerManager.superclass.configureLayerNode.apply(this, arguments);
        var legendXType;
        // add a WMS legend to each node created
        if (OpenLayers.Layer.WMS && attr.layer instanceof OpenLayers.Layer.WMS) {
            legendXType = "gx_wmslegend";
        } else if (OpenLayers.Layer.Vector && attr.layer instanceof OpenLayers.Layer.Vector) {
            legendXType = "gx_vectorlegend";
        }
        if (legendXType) {
            var baseParams;
            if (loader && loader.baseAttrs && loader.baseAttrs.baseParams) {
                baseParams = loader.baseAttrs.baseParams;
            }
            Ext.apply(attr, {
                component: {
                    xtype: legendXType,
                    // TODO these baseParams were only tested with GeoServer,
                    // so maybe they should be configurable - and they are
                    // only relevant for gx_wmslegend.
                    hidden: !attr.layer.getVisibility(),
                    baseParams: Ext.apply({
                        transparent: true,
                        format: "image/png",
                        legend_options: "fontAntiAliasing:true;fontSize:11;fontName:Arial"
                    }, baseParams),
                    layerRecord: this.target.mapPanel.layers.getByLayer(attr.layer),
                    showTitle: false,
                    // custom class for css positioning
                    // see tree-legend.html
                    cls: "legend"
                }
            });
        }
    }
    
});

Ext.preg(gxp.plugins.LayerManager.prototype.ptype, gxp.plugins.LayerManager);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 * @requires widgets/NewSourceDialog.js
 * @requires widgets/FeedSourceDialog.js
 * @requires plugins/GeoNodeCatalogueSource.js
 * @requires widgets/CatalogueSearchPanel.js
 * @requires plugins/TMSSource.js
 * @requires plugins/ArcRestSource.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = AddLayers
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: AddLayers(config)
 *
 *    Plugin for removing a selected layer from the map.
 *    TODO Make this plural - selected layers
 */
gxp.plugins.AddLayers = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_addlayers */
    ptype: "gxp_addlayers",
    
    /** api: config[addActionMenuText]
     *  ``String``
     *  Text for add menu item (i18n).
     */
    addActionMenuText: "Add layers",

    /** api: config[findActionMenuText]
     *  ``String``
     *  Text for find menu item (i18n).
     */
    findActionMenuText: "Find layers",

    /** api: config[addActionMenuText]
     *  ``String``
     *  Text for add feed menu item (i18n).
     */
    addFeedActionMenuText: "Add feeds",

    /** api: config[addActionTip]
     *  ``String``
     *  Text for add action tooltip (i18n).
     */
    addActionTip: "Add layers",
    
    /** api: config[addActionText]
     *  ``String``
     *  Text for the Add action. None by default.
     */
   
    /** api: config[addServerText]
     *  ``String``
     *  Text for add server button (i18n).
     */
    addServerText: "Add a New Server",

    /** api: config[addButtonText]
     *  ``String``
     *  Text for add layers button (i18n).
     */
    addButtonText: "Add layers",
    
    /** api: config[untitledText]
     *  ``String``
     *  Text for an untitled layer (i18n).
     */
    untitledText: "Untitled",

    /** api: config[addLayerSourceErrorText]
     *  ``String``
     *  Text for an error message when WMS GetCapabilities retrieval fails (i18n).
     */
    addLayerSourceErrorText: "Error getting {type} capabilities ({msg}).\nPlease check the url and try again.",

    /** api: config[availableLayersText]
     *  ``String``
     *  Text for the available layers (i18n).
     */
    availableLayersText: "Available Layers",

    /** api: config[searchText]
     *  ``String``
     *  Text for the search dialog title (i18n).
     */
    searchText: "Search for layers",

    /** api: config[expanderTemplateText]
     *  ``String``
     *  Text for the grid expander (i18n).
     */
    expanderTemplateText: "<p><b>Abstract:</b> {abstract}</p>",
    
    /** api: config[panelTitleText]
     *  ``String``
     *  Text for the layer title (i18n).
     */
    panelTitleText: "Title",

    /** api: config[layerSelectionText]
     *  ``String``
     *  Text for the layer selection (i18n).
     */
    layerSelectionText: "View available data from:",
    
    /** api: config[instructionsText]
     *  ``String``
     *  Text for additional instructions at the bottom of the grid (i18n).
     *  None by default.
     */
    
    /** api: config[doneText]
     *  ``String``
     *  Text for Done button (i18n).
     */
    doneText: "Done",

    /** api: config[search]
     *  ``Object | Boolean``
     *  If provided, a :class:`gxp.CatalogueSearchPanel` will be added as a
     *  menu option. This panel will be constructed using the provided config.
     *  By default, no search functionality is provided.
     */

    /** api: config[feeds]
     *  ``Object | Boolean``
     *  If provided, a :class:`gxp.FeedSourceDialog` will be added as a
     *  menu option. This panel will be constructed using the provided config.
     *  By default, no feed functionality is provided.
     */

    /** api: config[upload]
     *  ``Object | Boolean``
     *  If provided, a :class:`gxp.LayerUploadPanel` will be made accessible
     *  from a button on the Available Layers dialog.  This panel will be 
     *  constructed using the provided config.  By default, no upload 
     *  button will be added to the Available Layers dialog.
     */
    
    /** api: config[uploadRoles]
     *  ``Array`` Roles authorized to upload layers. Default is
     *  ["ROLE_ADMINISTRATOR"]
     */
    uploadRoles: ["ROLE_ADMINISTRATOR"],
    
    /** api: config[uploadText]
     *  ``String``
     *  Text for upload button (only renders if ``upload`` is provided).
     */
    uploadText: "Upload layers",

    /** api: config[nonUploadSources]
     *  ``Array``
     *  If ``upload`` is enabled, the upload button will not be displayed for 
     *  sources whose identifiers or URLs are in the provided array.  By 
     *  default, the upload button will make an effort to be shown for all 
     *  sources with a url property.
     */

    /** api: config[relativeUploadOnly]
     *  ``Boolean``
     *  If ``upload`` is enabled, only show the button for sources with relative
     *  URLs (e.g. "/geoserver").  Default is ``true``.
     */
    relativeUploadOnly: true,
    
    /** api: config[uploadSource]
     *  ``String`` id of a WMS source (:class:`gxp.plugins.WMSSource') backed
     *  by a GeoServer instance that all uploads will be sent to. If provided,
     *  an Upload menu item will be shown in the "Add Layers" button menu.
     */
    
    /** api: config[postUploadAction]
     *  ``String|Object`` Either the id of a plugin that provides the action to
     *  be performed after an upload, or an object with ``plugin`` and
     *  ``outputConfig`` properties. The ``addOutput`` method of the plugin
     *  referenced by the provided id (or the ``plugin`` property) will be
     *  called, with the provided ``outputConfig`` as argument. A usage example
     *  would be to open the Styles tab of the LayerProperties dialog for a WMS
     *  layer:
     *
     *  .. code-block:: javascript
     *  
     *      postUploadAction: {
     *          plugin: "layerproperties",
     *          outputConfig: {activeTab: 2}
     *      }
     */

    /** api: config[startSourceId]
     * ``Integer``
     * The identifier of the source that we should start with.
     */
    startSourceId: null,

    /** api: config[catalogSourceKey]
     *  ``String`` When lazy layerRecords are created by the 'Find Layers'
     *  function, they can optionally be associated with another source. 
     *  E.g. the 'local' source in GeoNode client.
     */
    catalogSourceKey: null,
    
    /** private: property[selectedSource]
     *  :class:`gxp.plugins.LayerSource`
     *  The currently selected layer source.
     */
    selectedSource: null,
    
    /** private: property[addServerId]
     *  ``String`` Id of the record in the sourceComboBox that is used to
     *  add a new source.
     */
    addServerId: null,

    /** private: method[constructor]
     */
    constructor: function(config) {
        this.addEvents(
            /** api: event[sourceselected]
             *  Fired when a new source is selected.
             *
             *  Listener arguments:
             *
             *  * tool - :class:`gxp.plugins.AddLayers` This tool.
             *  * source - :class:`gxp.plugins.LayerSource` The selected source.
             */
            "sourceselected"
        );
        gxp.plugins.AddLayers.superclass.constructor.apply(this, arguments);        
    },
    
    /** api: method[addActions]
     */
    addActions: function() {
        var commonOptions = {
            tooltip : this.addActionTip,
            text: this.addActionText,
            menuText: this.addActionMenuText,
            disabled: true,
            iconCls: "gxp-icon-addlayers"
        };
        var options, uploadButton;
        if (this.initialConfig.search || (this.uploadSource)) {
            var items = [new Ext.menu.Item({
                iconCls: 'gxp-icon-addlayers', 
                text: this.addActionMenuText, 
                handler: this.showCapabilitiesGrid, 
                scope: this
            })];
            if (this.initialConfig.search && this.initialConfig.search.selectedSource &&
              this.target.sources[this.initialConfig.search.selectedSource]) {
                var search = new Ext.menu.Item({
                    iconCls: 'gxp-icon-addlayers',
                    text: this.findActionMenuText,
                    handler: this.showCatalogueSearch,
                    scope: this
                });
                items.push(search);
                Ext.Ajax.request({
                    method: "GET",
                    url: this.target.sources[this.initialConfig.search.selectedSource].url,
                    callback: function(options, success, response) {
                        if (success === false) {
                            this.target.layerSources[this.initialConfig.search.selectedSource].disable();
                            search.hide();
                        }
                    },
                    scope: this
                });
            }
            if (this.initialConfig.feeds) {
                items.push(new Ext.menu.Item({
                    iconCls: 'gxp-icon-addlayers',
                    text: this.addFeedActionMenuText,
                    handler: this.showFeedDialog,
                    scope: this
                }));
            }
            if (this.uploadSource) {
                uploadButton = this.createUploadButton(Ext.menu.Item);
                if (uploadButton) {
                    items.push(uploadButton);
                }
            }
            options = Ext.apply(commonOptions, {
                menu: new Ext.menu.Menu({
                    items: items
                })
            });
        } else {
            options = Ext.apply(commonOptions, {
                handler : this.showCapabilitiesGrid,
                scope: this
            });
        }
        var actions = gxp.plugins.AddLayers.superclass.addActions.apply(this, [options]);
        
        this.target.on("ready", function() {
            if (this.uploadSource) {
                var source = this.target.layerSources[this.uploadSource];
                if (source) {
                    this.setSelectedSource(source);
                } else {
                    delete this.uploadSource;
                    if (uploadButton) {
                        uploadButton.hide();
                    }
                    // TODO: add error logging
                    // throw new Error("Layer source for uploadSource '" + this.uploadSource + "' not found.");
                }
            }
            actions[0].enable();
        }, this);
        return actions;
    },

    /** api: method[showCatalogueSearch]
     * Shows the window with a search panel.
     */
    showCatalogueSearch: function() {
        var selectedSource = this.initialConfig.search.selectedSource;
        var sources = {};
        var found = false;
        for (var key in this.target.layerSources) {
            var source = this.target.layerSources[key];
            if (source instanceof gxp.plugins.CatalogueSource) {
                var obj = {};
                obj[key] = source;
                Ext.apply(sources, obj);
                found = true;
            }
        }
        if (found === false) {
            if (window.console) {
                window.console.debug('No catalogue source specified');
            }
            return;
        }
        var output = gxp.plugins.AddLayers.superclass.addOutput.apply(this, [{
            sources: sources,
            title: this.searchText,
            height: 300,
            width: 315,
            selectedSource: selectedSource,
            xtype: 'gxp_cataloguesearchpanel',
            map: this.target.mapPanel.map
        }]);
        output.on({
            'addlayer': function(cmp, sourceKey, layerConfig) {
                var source = this.target.layerSources[sourceKey];
                var bounds = OpenLayers.Bounds.fromArray(layerConfig.bbox,
                    (source.yx && source.yx[layerConfig.projection] === true));
                var mapProjection = this.target.mapPanel.map.getProjection();
                var bbox = bounds.transform(layerConfig.srs, mapProjection);
                layerConfig.srs = mapProjection;
                layerConfig.bbox = bbox.toArray();
                layerConfig.source = this.initialConfig.catalogSourceKey !== null ?
                    this.initialConfig.catalogSourceKey : sourceKey;
                var record = source.createLayerRecord(layerConfig);
                this.target.mapPanel.layers.add(record);
                if (bbox) {
                    this.target.mapPanel.map.zoomToExtent(bbox);
                }
            },
            scope: this
        });
        var popup = output.findParentByType('window');
        popup && popup.center();
        return output;
    },
        
    /** api: method[showCapabilitiesGrid]
     * Shows the window with a capabilities grid.
     */
    showCapabilitiesGrid: function() {
        if(!this.capGrid) {
            this.initCapGrid();
        } else if (!(this.capGrid instanceof Ext.Window)) {
            this.addOutput(this.capGrid);
        }
        this.capGrid.show();
    },

    /** api: method[showFeedDialog]
     * Shows the window with a dialog for adding feeds.
     */
    showFeedDialog: function() {
        if(!this.feedDialog) {
            var Cls = this.outputTarget ? Ext.Panel : Ext.Window;
            this.feedDialog = new Cls(Ext.apply({
                closeAction: "hide",
                autoScroll: true,
                title: this.addFeedActionMenuText,
                items: [{
                    xtype: "gxp_feedsourcedialog",
                    target: this.target,
                    listeners: {
                        'addfeed':function (ptype, config) {
                            var sourceConfig = {"config":{"ptype":ptype}};
                            if (config.url) {
                                sourceConfig.config["url"] = config.url;
                            }
                            var source = this.target.addLayerSource(sourceConfig);
                            config.source = source.id;
                            var feedRecord = source.createLayerRecord(config);
                            this.target.mapPanel.layers.add([feedRecord]);
                            this.feedDialog.hide();
                        },
                        scope: this
                    }
                }]
            }, this.initialConfig.outputConfig));
            if (Cls === Ext.Panel) {
                this.addOutput(this.feedDialog);
            }
        }
        if (!(this.feedDialog instanceof Ext.Window)) {
            this.addOutput(this.feedDialog);
        }
        this.feedDialog.show();
    },

    /**
     * private: method[initCapGrid]
     * Constructs a window with a capabilities grid.
     */
    initCapGrid: function() {
        var source, data = [], target = this.target;        
        for (var id in target.layerSources) {
            source = target.layerSources[id];
            if (source.store && !source.hidden) {
                data.push([id, source.title || id, source.url]);                
            }
        }
        var sources = new Ext.data.ArrayStore({
            fields: ["id", "title", "url"],
            data: data
        });

        var expander = this.createExpander();
        
        function addLayers() {
            var source = this.selectedSource;
            var records = capGridPanel.getSelectionModel().getSelections();
            var recordsToAdd = [],
                numRecords = records.length;
            function collectRecords(record) {
                if (recordsToAdd) {
                    recordsToAdd.push(record);
                }
                numRecords--;
                if (numRecords === 0) {
                    this.addLayers(recordsToAdd);
                }
            }
            for (var i=0, ii=records.length; i<ii; ++i) {
                var record = source.createLayerRecord({
                    name: records[i].get("name"),
                    source: source.id
                }, collectRecords, this);
                if (record) {
                    collectRecords.call(this, record);
                }
            }
        }
        
        var idx = 0;
        if (this.startSourceId !== null) {
            sources.each(function(record) {
                if (record.get("id") === this.startSourceId) {
                    idx = sources.indexOf(record);
                }
            }, this);
        }

        source = this.target.layerSources[data[idx][0]];

        var capGridPanel = new Ext.grid.GridPanel({
            store: source.store,
            autoScroll: true,
            autoExpandColumn: "title",
            plugins: [expander],
            loadMask: true,
            colModel: new Ext.grid.ColumnModel([
                expander,
                {id: "title", header: this.panelTitleText, dataIndex: "title", sortable: true},
                {header: "Id", dataIndex: "name", width: 120, sortable: true}
            ]),
            listeners: {
                rowdblclick: addLayers,
                scope: this
            }
        });
        
        var sourceComboBox = new Ext.form.ComboBox({
            ref: "../../sourceComboBox",
            width: 165,
            store: sources,
            valueField: "id",
            displayField: "title",
            tpl: '<tpl for="."><div ext:qtip="{url}" class="x-combo-list-item">{title}</div></tpl>',
            triggerAction: "all",
            editable: false,
            allowBlank: false,
            forceSelection: true,
            mode: "local",
            value: data[idx][0],
            listeners: {
                select: function(combo, record, index) {
                    var id = record.get("id");
                    if (id === this.addServerId) {
                        showNewSourceDialog();
                        sourceComboBox.reset();
                        return;
                    }
                    var source = this.target.layerSources[id];
                    capGridPanel.reconfigure(source.store, capGridPanel.getColumnModel());
                    // TODO: remove the following when this Ext issue is addressed
                    // http://www.extjs.com/forum/showthread.php?100345-GridPanel-reconfigure-should-refocus-view-to-correct-scroller-height&p=471843
                    capGridPanel.getView().focusRow(0);
                    this.setSelectedSource(source);
                    // blur the combo box
                    //TODO Investigate if there is a more elegant way to do this.
                    (function() {
                        combo.triggerBlur();
                        combo.el.blur();
                    }).defer(100);
                },
                focus: function(field) {
                    if (target.proxy) {
                        field.reset();
                    }
                },
                scope: this
            }
        });

        var capGridToolbar = null,
            container;

        if (this.target.proxy || data.length > 1) {
            container = new Ext.Container({
                cls: 'gxp-addlayers-sourceselect',
                items: [
                    new Ext.Toolbar.TextItem({text: this.layerSelectionText}),
                    sourceComboBox
                ]
            });
            capGridToolbar = [container];
        }
        
        if (this.target.proxy) {
            this.addServerId = Ext.id();
            sources.loadData([[this.addServerId, this.addServerText + "..."]], true);
        }
        
        var newSourceDialog = {
            xtype: "gxp_newsourcedialog",
            header: false,
            listeners: {
                "hide": function(cmp) {
                    if (!this.outputTarget) {
                        cmp.ownerCt.hide();
                    }
                },
                "urlselected": function(newSourceDialog, url, type) {
                    newSourceDialog.setLoading();
                    var ptype;
                    switch (type) {
                    	case 'TMS':
                    		ptype = "gxp_tmssource";
                    		break;
                    	case 'REST':
                    		ptype = 'gxp_arcrestsource';
                    		break;
                    	default:
                    		ptype = 'gxp_wmscsource';
                    }
                    this.target.addLayerSource({
                        config: {url: url, ptype: ptype},
                        callback: function(id) {
                            // add to combo and select
                            var record = new sources.recordType({
                                id: id,
                                title: this.target.layerSources[id].title || this.untitledText
                            });
                            sources.insert(0, [record]);
                            sourceComboBox.onSelect(record, 0);
                            newSourceDialog.hide();
                        },
                        fallback: function(source, msg) {
                            newSourceDialog.setError(
                                new Ext.Template(this.addLayerSourceErrorText).apply({type: type, msg: msg})
                            );
                        },
                        scope: this
                    });
                },
                scope: this
            }
        };
        var me = this;
        function showNewSourceDialog() {
            if (me.outputTarget) {
                me.addOutput(newSourceDialog);
            } else {
                new Ext.Window({
                    title: gxp.NewSourceDialog.prototype.title,
                    modal: true,
                    hideBorders: true,
                    width: 300,
                    items: newSourceDialog
                }).show();
            }
        }        
        
        
        var items = {
            xtype: "container",
            region: "center",
            layout: "fit",
            hideBorders: true,
            items: [capGridPanel]
        };
        if (this.instructionsText) {
            items.items.push({
                xtype: "box",
                autoHeight: true,
                autoEl: {
                    tag: "p",
                    cls: "x-form-item",
                    style: "padding-left: 5px; padding-right: 5px"
                },
                html: this.instructionsText
            });
        }
        
        var bbarItems = [
            "->",
            new Ext.Button({
                text: this.addButtonText,
                iconCls: "gxp-icon-addlayers",
                handler: addLayers,
                scope : this
            }),
            new Ext.Button({
                text: this.doneText,
                handler: function() {
                    this.capGrid.hide();
                },
                scope: this
            })
        ];
        
        var uploadButton;
        if (!this.uploadSource) {
            uploadButton = this.createUploadButton();
            if (uploadButton) {
                bbarItems.unshift(uploadButton);
            }
        }

        var Cls = this.outputTarget ? Ext.Panel : Ext.Window;
        this.capGrid = new Cls(Ext.apply({
            title: this.availableLayersText,
            closeAction: "hide",
            layout: "border",
            height: 300,
            width: 315,
            modal: true,
            items: items,
            tbar: capGridToolbar,
            bbar: bbarItems,
            listeners: {
                hide: function(win) {
                    capGridPanel.getSelectionModel().clearSelections();
                },
                show: function(win) {
                    if (this.selectedSource === null) {
                        this.setSelectedSource(this.target.layerSources[data[idx][0]]);
                    } else {
                        this.setSelectedSource(this.selectedSource);
                    }
                },
                scope: this
            }
        }, this.initialConfig.outputConfig));
        if (Cls === Ext.Panel) {
            this.addOutput(this.capGrid);
        }
        
    },
    
    /** private: method[addLayers]
     *  :arg records: ``Array`` the layer records to add
     *  :arg isUpload: ``Boolean`` Do the layers to add come from an upload?
     */
    addLayers: function(records, isUpload) {
        var source = this.selectedSource;
        var layerStore = this.target.mapPanel.layers,
            extent, record, layer;
        for (var i=0, ii=records.length; i<ii; ++i) {
            // If the source is lazy, then createLayerRecord will not return
            // a record, and we take the preconfigured record.
            record = source.createLayerRecord({
                name: records[i].get("name"),
                source: source.id
            }) || records[i];
            if (record) {
                layer = record.getLayer();
                if (layer.maxExtent) {
                    if (!extent) {
                        extent = record.getLayer().maxExtent.clone();
                    } else {
                        extent.extend(record.getLayer().maxExtent);
                    }
                }
                if (record.get("group") === "background") {
                    // layer index 0 is the invisible base layer, so we insert
                    // at position 1.
                    layerStore.insert(1, [record]);
                } else {
                    layerStore.add([record]);
                }
            }
        }
        if (extent) {
            this.target.mapPanel.map.zoomToExtent(extent);
        }
        if (records.length === 1 && record) {
            // select the added layer
            this.target.selectLayer(record);
            if (isUpload && this.postUploadAction) {
                // show LayerProperties dialog if just one layer was uploaded
                var outputConfig,
                    actionPlugin = this.postUploadAction;
                if (!Ext.isString(actionPlugin)) {
                    outputConfig = actionPlugin.outputConfig;
                    actionPlugin = actionPlugin.plugin;
                }
                this.target.tools[actionPlugin].addOutput(outputConfig);
            }
        }
    },
    
    /** private: method[setSelectedSource]
     *  :arg source: :class:`gxp.plugins.LayerSource`
     */
    setSelectedSource: function(source, callback) {
        this.selectedSource = source;
        var store = source.store;
        this.fireEvent("sourceselected", this, source);
        if (this.capGrid && source.lazy) {
            source.store.load({callback: (function() {
                var sourceComboBox = this.capGrid.sourceComboBox,
                    store = sourceComboBox.store,
                    valueField = sourceComboBox.valueField,
                    index = store.findExact(valueField, sourceComboBox.getValue()),
                    rec = store.getAt(index),
                    source = this.target.layerSources[rec.get("id")];
                if (source) {
                    if (source.title !== rec.get("title") && !Ext.isEmpty(source.title)) {
                        rec.set("title", source.title);
                        sourceComboBox.setValue(rec.get(valueField));
                    }
                } else {
                    store.remove(rec);
                }
            }).createDelegate(this)});
        }
    },
    
    /** api: method[createUploadButton]
     *  :arg Cls: ``Function`` The class to use for creating the button. If not
     *      provided, an ``Ext.Button`` instance will be created.
     *      ``Ext.menu.Item`` would be another option.
     *  If this tool is provided an ``upload`` property, a button will be created
     *  that launches a window with a :class:`gxp.LayerUploadPanel`.
     */
    createUploadButton: function(Cls) {
        Cls = Cls || Ext.Button;
        var button;
        var uploadConfig = this.initialConfig.upload || !!this.initialConfig.uploadSource;
        // the url will be set in the sourceselected sequence
        var url;
        if (uploadConfig) {
            if (typeof uploadConfig === "boolean") {
                uploadConfig = {};
            }
            button = new Cls({
                text: this.uploadText,
                iconCls: "gxp-icon-filebrowse",
                hidden: !this.uploadSource,
                handler: function() {
                    this.target.doAuthorized(this.uploadRoles, function() {
                        var panel = new gxp.LayerUploadPanel(Ext.apply({
                            title: this.outputTarget ? this.uploadText : undefined,
                            url: url,
                            width: 300,
                            border: false,
                            bodyStyle: "padding: 10px 10px 0 10px;",
                            labelWidth: 65,
                            autoScroll: true,
                            defaults: {
                                anchor: "99%",
                                allowBlank: false,
                                msgTarget: "side"
                            },
                            listeners: {
                                uploadcomplete: function(panel, detail) {
                                    var layers = detail["import"].tasks;
                                    var item, names = {}, resource, layer;
                                    for (var i=0, len=layers.length; i<len; ++i) {
                                        item = layers[i];
                                        if (item.state === "ERROR") {
                                            Ext.Msg.alert(item.layer.originalName, item.errorMessage);
                                            return;
                                        }
                                        var ws;
                                        if (item.target.dataStore) {
                                            ws = item.target.dataStore.workspace.name;
                                        } else if (item.target.coverageStore) {
                                            ws = item.target.coverageStore.workspace.name;
                                        }
                                        names[ws + ":" + item.layer.name] = true;
                                    }
                                    this.selectedSource.store.load({
                                        params: {"_dc": Math.random()},
                                        callback: function(records, options, success) {
                                            var gridPanel, sel;
                                            if (this.capGrid && this.capGrid.isVisible()) {
                                                gridPanel = this.capGrid.get(0).get(0);
                                                sel = gridPanel.getSelectionModel();
                                                sel.clearSelections();
                                            }
                                            // select newly added layers
                                            var newRecords = [];
                                            var last = 0;
                                            this.selectedSource.store.each(function(record, index) {
                                                if (record.get("name") in names) {
                                                    last = index;
                                                    newRecords.push(record);
                                                }
                                            });
                                            if (gridPanel) {
                                                // this needs to be deferred because the 
                                                // grid view has not refreshed yet
                                                window.setTimeout(function() {
                                                    sel.selectRecords(newRecords);
                                                    gridPanel.getView().focusRow(last);
                                                }, 100);
                                            } else {
                                                this.addLayers(newRecords, true);
                                            }
                                        },
                                        scope: this
                                    });
                                    if (this.outputTarget) {
                                        panel.hide();
                                    } else {
                                        win.close();
                                    }
                                },
                                scope: this
                            }
                        }, uploadConfig));
                    
                        var win;
                        if (this.outputTarget) {
                            this.addOutput(panel);
                        } else {
                            win = new Ext.Window({
                                title: this.uploadText,
                                modal: true,
                                resizable: false,
                                items: [panel]
                            });
                            win.show();
                        }
                    }, this);
                },
                scope: this
            });
            
            var urlCache = {};
            function getStatus(url, callback, scope) {
                if (url in urlCache) {
                    // always call callback after returning
                    window.setTimeout(function() {
                        callback.call(scope, urlCache[url]);
                    }, 0);
                } else {
                    Ext.Ajax.request({
                        url: url,
                        disableCaching: false,
                        callback: function(options, success, response) {
                            var status = response.status;
                            urlCache[url] = status;
                            callback.call(scope, status);
                        }
                    });
                }
            }
            
            this.on({
                sourceselected: function(tool, source) {
                    button[this.uploadSource ? "show" : "hide"]();
                    var show = false;
                    if (this.isEligibleForUpload(source)) {
                        url = this.getGeoServerRestUrl(source.url);
                        if (this.target.isAuthorized()) {
                            // determine availability of upload functionality based
                            // on a 200 for GET /imports
                            getStatus(url + "/imports", function(status) {
                                button.setVisible(status === 200);
                            }, this);
                        }
                    }
                },
                scope: this
            });
        }
        return button;
    },
    
    /** private: method[getGeoServerRestUrl]
     *  :arg url: ``String`` A GeoServer url like "geoserver/ows"
     *  :returns: ``String`` The rest endpoint for the above GeoServer,
     *      i.e. "geoserver/rest" 
     */
    getGeoServerRestUrl: function(url) {
        var parts = url.split("/");
        parts.pop();
        parts.push("rest");
        return parts.join("/");
    },
    
    /** private: method[isEligibleForUpload]
     *  :arg source: :class:`gxp.plugins.LayerSource`
     *  :returns: ``Boolean``
     *
     *  Determine if the provided source is eligible for upload given the tool
     *  config.
     */
    isEligibleForUpload: function(source) {
        return (
            source.url &&
            (this.relativeUploadOnly ? (source.url.charAt(0) === "/") : true) &&
            (this.nonUploadSources || []).indexOf(source.id) === -1
        );
    },
    
    /** api: config[createExpander]
     *  ``Function`` Returns an ``Ext.grid.RowExpander``. Can be overridden
     *  by applications/subclasses to provide a custom expander.
     */
    createExpander: function() {
        return new Ext.grid.RowExpander({
            tpl: new Ext.Template(this.expanderTemplateText)
        });
    }

});

Ext.preg(gxp.plugins.AddLayers.prototype.ptype, gxp.plugins.AddLayers);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = RemoveLayer
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: RemoveLayer(config)
 *
 *    Plugin for removing a selected layer from the map.
 *    TODO Make this plural - selected layers
 */
gxp.plugins.RemoveLayer = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_removelayer */
    ptype: "gxp_removelayer",
    
    /** api: config[removeMenuText]
     *  ``String``
     *  Text for remove menu item (i18n).
     */
    removeMenuText: "Remove layer",

    /** api: config[removeActionTip]
     *  ``String``
     *  Text for remove action tooltip (i18n).
     */
    removeActionTip: "Remove layer",
    
    /** api: method[addActions]
     */
    addActions: function() {
        var selectedLayer;
        var actions = gxp.plugins.RemoveLayer.superclass.addActions.apply(this, [{
            menuText: this.removeMenuText,
            iconCls: "gxp-icon-removelayers",
            disabled: true,
            tooltip: this.removeActionTip,
            handler: function() {
                var record = selectedLayer;
                if(record) {
                    this.target.mapPanel.layers.remove(record);
                }
            },
            scope: this
        }]);
        var removeLayerAction = actions[0];

        this.target.on("layerselectionchange", function(record) {
            selectedLayer = record;
            removeLayerAction.setDisabled(
                this.target.mapPanel.layers.getCount() <= 1 || !record
            );
        }, this);
        var enforceOne = function(store) {
            removeLayerAction.setDisabled(
                !selectedLayer || store.getCount() <= 1
            );
        };
        this.target.mapPanel.layers.on({
            "add": enforceOne,
            "remove": enforceOne
        });
        
        return actions;
    }
        
});

Ext.preg(gxp.plugins.RemoveLayer.prototype.ptype, gxp.plugins.RemoveLayer);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = SelectedFeatureActions
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: SelectedFeatureActions(config)
 *
 *    Plugin for creating actions that put an iframe with a url generated from
 *    a template with information from feature attributes or the feature id in
 *    the tool's outputTarget.
 */
 /** api: example
  *  Configuration in the  :class:`gxp.Viewer`:
  *
  *  .. code-block:: javascript
  *
  *    tools: [{
  *        ptype: "gxp_selectedfeatureactions",
  *        featureManager: "myfeaturemanager",
  *        actionTarget: "featuregrid.contextMenu",
  *        actions: [{
  *            menuText: "Search for title",
  *            urlTemplate: "http://google.com/search?q={title}",
  *            iconCls: "google-icon"
  *        }]
  *        }
  *        //...
  *    ]
  */
gxp.plugins.SelectedFeatureActions = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_selectedfeatureactions */
    ptype: "gxp_selectedfeatureactions",
    
    /** api: config[featureManager]
     *  :class:`gxp.plugins.FeatureManager` The feature manager to get the
     *  selected feature from.
     */
    
    /** api: config[actions]
     *  ``Object`` Like actions in :class:`gxp.plugins.Tool`, but with two
     *  additional properties:
     *
     *  * urlTemplate - ``String`` template for the link to follow. To
     *    reference attributes of the selected feature, use "{fieldName}"
     *    in the template. In addition to the attributes, "{fid}" is available
     *    for the feature id (typename prefix removed), and "{layer}" for the
     *    name of the underlying WMS layer (usually prefix:name).
     *  * outputConfig - ``Object`` overrides this tool's outputConfig for
     *    output triggered by the respective action. Useful e.g. for creating
     *    windows with different sizes for each action.
     */
     
    addActions: function() {
        var featureManager = this.target.tools[this.featureManager];
        var len = this.actions.length, actions = new Array(len);
        var tool = this;
        for (var i=0; i<len; ++i) {
            actions[i] = Ext.apply({
                iconCls: "process",
                disabled: true,
                handler: function() {
                    var feature = featureManager.featureLayer.selectedFeatures[0];
                    var tpl = new Ext.Template(this.urlTemplate);
                    var outputConfig = Ext.applyIf(this.outputConfig || {},
                        tool.initialConfig.outputConfig);
                    tool.outputConfig = Ext.apply(outputConfig, {
                        title: this.menuText,
                        bodyCfg: {
                            tag: "iframe",
                            src: tpl.apply(Ext.applyIf({
                                fid: feature.fid.split(".").pop(),
                                layer: featureManager.layerRecord.get("name")
                            }, feature.attributes)),
                            style: {border: "0px none"}
                        }
                    });
                    tool.addOutput();
                }
            }, this.actions[i]);
        }
        featureManager.featureLayer.events.on({
            "featureselected": function(evt) {
                var disabled = evt.feature.layer.selectedFeatures.length != 1;
                for (var i=actions.length-1; i>=0; --i) {
                    actions[i].setDisabled(disabled);
                }
            },
            "featureunselected": function(evt) {
                if (evt.feature.layer.selectedFeatures.length == 0) {
                    for (var i=actions.length-1; i>=0; --i) {
                        actions[i].disable();
                    }
                }
            },
            scope: this
        });
        gxp.plugins.SelectedFeatureActions.superclass.addActions.apply(this, [actions]);
    }
    
});

Ext.preg(gxp.plugins.SelectedFeatureActions.prototype.ptype, gxp.plugins.SelectedFeatureActions);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 * @require OpenLayers/Control/Snapping.js
 * @require OpenLayers/Strategy/BBOX.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = SnappingAgent
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: SnappingAgent(config)
 *
 *    Plugin for managing snapping while editing.
 */   
gxp.plugins.SnappingAgent = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_snappingagent */
    ptype: "gxp_snappingagent",    
    
    /** api: config[controlOptions]
     *  ``Object`` Options for the ``OpenLayers.Control.Snapping`` used with
     *  this tool.
     */
    
    /** api: config[targets]
     *  ``Array`` Shortcut to the targets control option of the
     *  ``OpenLayers.Control.Snapping`` used with this tool.
     */
    
    /** private: property[controls]
     *  ``Object``
     *  Object property names are editor ids and values are snapping controls 
     *  associated with each editor.
     */ 

    /** private: method[init]
     */
    init: function(target) {
        gxp.plugins.SnappingAgent.superclass.init.apply(this, arguments);
        this.snappingTargets = [];
        this.controls = {};
        this.setSnappingTargets(this.targets);
    },
    
    /** private: method[setSnappingTargets]
     *  :arg targets: ``Array`` List of snapping target configurations.
     */
    setSnappingTargets: function(targets) {
        // clear any previous targets
        this.clearSnappingTargets();
        // configure any given targets
        if (targets) {
            for (var i=0, ii=targets.length; i<ii; ++i) {
                this.addSnappingTarget(targets[i]);
            }
        }
    },
    
    /** private: method[clearSnappingTargets]
     *  Removes all existing snapping targets.  Snapping targets have references
     *  to vector layers that are created in :meth:`addSnappingTarget`.  This 
     *  method destroys those layers.
     */
    clearSnappingTargets: function() {
        var target;
        for (var i=0, ii=this.snappingTargets.length; i<ii; ++i) {
            target = this.snappingTargets[i];
            if (target.layer) {
                target.layer.destroy();
            }
        }
        this.snappingTargets.length = 0;
    },
    
    /** private: method[addSnappingTarget]
     *  :arg snapTarget: ``Object`` Snapping target configuration.
     * 
     *  Create vector layers for the given snapping target based on ``source``
     *  and ``name`` properties.  When the schema for the related feature source
     *  is loaded, a vector layer will be created and set on the snapping
     *  target configuration.  After the snapping target is given a layer, it
     *  will be added to the ``snappingTargets`` list.
     */
    addSnappingTarget: function(snapTarget) {
        snapTarget = Ext.apply({}, snapTarget);

        // Generate a layer for the snapTarget. This layer is not given a 
        // protocol until the feature manager below gives it one.
        var map = this.target.mapPanel.map;
        var layer = new OpenLayers.Layer.Vector(snapTarget.name, {
            strategies: [new OpenLayers.Strategy.BBOX({
                ratio: 1.5,
                // we update manually, because usually the layer is
                // invisble and the strategy would not update anyway
                autoActivate: false
            })],
            displayInLayerSwitcher: false,
            visibility: false,
            minResolution: snapTarget.minResolution,
            maxResolution: snapTarget.maxResolution
        });
        snapTarget.layer = layer;
        this.snappingTargets.push(snapTarget);

        // TODO: Discuss simplifying this.  What we want here is a WFS protocol
        // given a WMS layer config.  We're only using the FeatureManager for 
        // generating the protocol options.
        var featureManager = new gxp.plugins.FeatureManager({
            maxFeatures: null,
            paging: false,
            layer: {
                source: snapTarget.source,
                name: snapTarget.name
            },
            listeners: {
                layerchange: function() {
                    // at this point we have a protocol for the layer
                    layer.protocol = featureManager.featureStore.proxy.protocol;
                    map.addLayer(layer);
                    map.events.on({
                        moveend: function() {
                            this.updateSnappingTarget(snapTarget);
                        },
                        scope: this
                    });
                    this.updateSnappingTarget(snapTarget);
                    this.target.on({
                        featureedit: function(featureManager, layerCfg) {
                            if (layerCfg.name == snapTarget.name && layerCfg.source == snapTarget.source) {
                                this.updateSnappingTarget(snapTarget, {force: true});
                            }
                        },
                        scope: this
                    });
                },
                scope: this
            }
        });

        featureManager.init(this.target);
    },
    
    /** private: method[updateSnappingTarget]
     *  :arg snapTarget: ``Object`` The snapTarget to update
     *  :arg options: ``Object`` 1st argument for
     *      OpenLayers.Strategy.BBOX::update
     *
     *  Checks if features need to be loaded for the snapTarget, and loads them
     *  by calling update on the BBOX strategy.
     */
    updateSnappingTarget: function(snapTarget, options) {
        var min = snapTarget.minResolution || Number.NEGATIVE_INFINITY;
        var max = snapTarget.maxResolution || Number.POSITIVE_INFINITY;
        var resolution = this.target.mapPanel.map.getResolution();
        if (min <= resolution && resolution < max) {
            //TODO unhack this - uses a non-API method (update) and sets a
            // read-only property (visibility) to make the non-API method work
            // in this context.
            var visibility = snapTarget.layer.visibility;
            snapTarget.layer.visibility = true;
            snapTarget.layer.strategies[0].update(options);
            snapTarget.layer.visibility = visibility;
        }
    },
    
    /** private: method[createSnappingControl]
     *  :arg layer: ``OpenLayers.Layer.Vector`` An editable vector layer.
     *
     *  Prepares a snapping control for the provided layer.  All target
     *  configuration is derived from the configuration of this snapping agent.
     */
    createSnappingControl: function(layer) {
        var options = this.initialConfig.controlOptions || this.initialConfig.options;
        var control = new OpenLayers.Control.Snapping(
            Ext.applyIf({layer: layer}, options || {})
        );
        return control;
    },
    
    /** api: method[registerEditor]
     *  :arg editor: :class:`gxp.plugins.FeatureEditor`
     *
     *  Register a feature editor with this snapping agent.  This is called by
     *  feature editors that are configured with a snapping agent.
     */
    registerEditor: function(editor) {
        var featureManager = editor.getFeatureManager();
        var control = this.createSnappingControl(featureManager.featureLayer);
        this.controls[editor.id] = control;
        editor.on({
            layereditable: this.onLayerEditable,
            featureeditable: this.onFeatureEditable,
            scope: this
        });
    },
    
    /** private: method[onLayerEditable]
     *  :arg editor: :class:`gxp.plugins.SnappingAgent`
     *  :arg record: ``GeoExt.data.LayerRecord``
     *  :arg editable: ``Boolean``
     *
     *  Called when ``layereditable`` is fired on the one of the registered 
     *  feature editors.  The purpose of this listener is to set snapping 
     *  targets for the snapping control associated with the given editor
     *  while respecting the snapping target ``restrictedLayer``
     *  property.
     */
    onLayerEditable: function(editor, record, editable) {
        // deactivate all controls except for the one associated with the editor
        var control = this.controls[editor.id];
        if (!editable) {
            control.deactivate();
        } else {
            var targets = [];
            var snappingTarget, layerConfig, include;
            var source = record.get("source");
            var name = record.get("name");
            for (var i=0, ii=this.snappingTargets.length; i<ii; ++i) {
                snappingTarget = this.snappingTargets[i];
                if (snappingTarget.restrictedLayers) {
                    include = false;
                    for (var j=0, jj=snappingTarget.restrictedLayers.length; j<jj; ++j) {
                        layerConfig = snappingTarget.restrictedLayers[j];
                        if (layerConfig.source === source && layerConfig.name === name) {
                            include = true;
                            break;
                        }
                    }
                    if (include) {
                        targets.push(snappingTarget);
                    }
                } else {
                    // no restrictedLayers config, all targets apply
                    targets.push(snappingTarget);
                }
            }
            control.setTargets(targets);
            control.activate();
        }
    },

    /** private: method[onFeatureEditable]
     *  :arg editor: :class:`gxp.plugins.SnappingAgent`
     *  :arg record: ``OpenLayers.Feature.Vector``
     *  :arg editable: ``Boolean``
     *
     *  Called when a feature is selected or unselected for editing.  The 
     *  purpose of this listener is to set or unset any filter on snapping 
     *  targets for the snapping control associated with the given editor
     *  so features are not snapped to themselves during editing.
     */
    onFeatureEditable: function(editor, feature, editable) {
        var manager = editor.getFeatureManager();
        var editableLayer = manager.layerRecord;
        var source = editableLayer.get("source");
        var name = editableLayer.get("name");
        var target, originalFilter, filter;
        // check for editable layer in snapping targets
        for (var i=0, ii=this.snappingTargets.length; i<ii; ++i) {
            target = this.snappingTargets[i];
            if (source === target.source && name === target.name) {
                // editable layer is also snapping target
                originalFilter = this.targets[i].filter;
                if (!feature || !feature.fid || !editable) {
                    // restore the original filter
                    target.filter = originalFilter;
                } else {
                    filter = new OpenLayers.Filter.Logical({
                        type: OpenLayers.Filter.Logical.NOT,
                        filters: [
                            new OpenLayers.Filter.FeatureId({fids: [feature.fid]})
                        ]
                    });
                    if (originalFilter) {
                        target.filter = new OpenLayers.Filter.Logical({
                            type: OpenLayers.Filter.Logical.AND,
                            filters: [originalFilter, filter]
                        });
                    } else {
                        target.filter = filter;
                    }
                }
            }
        }
    }


});

Ext.preg(gxp.plugins.SnappingAgent.prototype.ptype, gxp.plugins.SnappingAgent);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 * @requires widgets/WMSStylesDialog.js
 * @requires plugins/GeoServerStyleWriter.js
 * @requires plugins/WMSRasterStylesDialog.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = Styler
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: Styler(config)
 *
 *    Plugin providing a styles editing dialog for geoserver layers.
 */
gxp.plugins.Styler = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_styler */
    ptype: "gxp_styler",
    
    /** api: config[menuText]
     *  ``String``
     *  Text for layer properties menu item (i18n).
     */
    menuText: "Edit Styles",

    /** api: config[tooltip]
     *  ``String``
     *  Text for layer properties action tooltip (i18n).
     */
    tooltip: "Manage layer styles",
    
    /** api: config[roles]
     *  ``Array`` Roles authorized to style layers. Default is
     *  ["ROLE_ADMINISTRATOR"]
     */
    roles: ["ROLE_ADMINISTRATOR"],
    
    /** api: config[sameOriginStyling]
     *  ``Boolean``
     *  Only allow editing of styles for layers whose sources have a URL that
     *  matches the origin of this applicaiton.  It is strongly discouraged to 
     *  do styling through commonly used proxies as all authorization headers
     *  and cookies are shared with all remote sources.  Default is ``true``.
     */
    sameOriginStyling: true,
    
    /** api: config[rasterStyling]
     *  ``Boolean`` If set to true, single-band raster styling will be
     *  supported. Default is ``false``.
     */
    rasterStyling: false,
    
    /** api: config[requireDescribeLayer]
     *  ``Boolean`` If set to false, styling will be enabled for all WMS layers
     *  that have "/ows" or "/wms" at the end of their base url in case the WMS
     *  does not support DescribeLayer. Only set to false when rasterStyling is
     *  set to true. Default is true.
     */
    requireDescribeLayer: true,
    
    constructor: function(config) {
        gxp.plugins.Styler.superclass.constructor.apply(this, arguments);
        
        if (!this.outputConfig) {
            this.outputConfig = {
                autoHeight: true,
                width: 265
            };
        }
        Ext.applyIf(this.outputConfig, {
            closeAction: "close"
        });
    },

    /** private: method[init]
     *  :arg target: ``Object`` The object initializing this plugin.
     */
    init: function(target) {
        gxp.plugins.Styler.superclass.init.apply(this, arguments);
        this.target.on("authorizationchange", this.enableOrDisable, this);
    },

    /** private: method[destroy]
     */
    destroy: function() {
        this.target.un("authorizationchange", this.enableOrDisable, this);
        gxp.plugins.Styler.superclass.destroy.apply(this, arguments);
    },

    /** private: method[enableOrDisable]
     *  Enable or disable the button when the login status changes.
     */
    enableOrDisable: function() {
        if (this.target && this.target.selectedLayer !== null) {
            this.handleLayerChange(this.target.selectedLayer);
        }
    },
    
    /** api: method[addActions]
     */
    addActions: function() {
        var layerProperties;
        var actions = gxp.plugins.Styler.superclass.addActions.apply(this, [{
            menuText: this.menuText,
            iconCls: "gxp-icon-palette",
            disabled: true,
            tooltip: this.tooltip,
            handler: function() {
                this.target.doAuthorized(this.roles, this.addOutput, this);
            },
            scope: this
        }]);
        
        this.launchAction = actions[0];
        this.target.on({
            layerselectionchange: this.handleLayerChange,
            scope: this
        });
        
        return actions;
    },
    
    /** private: method[handleLayerChange]
     *  :arg record: ``GeoExt.data.LayerRecord``
     *
     *  Handle changes to the target viewer's selected layer.
     */
    handleLayerChange: function(record) {
        this.launchAction.disable();
        if (record) {
            var source = this.target.getSource(record);
            if (source instanceof gxp.plugins.WMSSource) {
                source.describeLayer(record, function(describeRec) {
                    this.checkIfStyleable(record, describeRec);
                }, this);
            }
        }
    },

    /** private: method[checkIfStyleable]
     *  :arg layerRec: ``GeoExt.data.LayerRecord``
     *  :arg describeRec: ``Ext.data.Record`` Record from a 
     *      `GeoExt.data.DescribeLayerStore``.
     *
     *  Given a layer record and the corresponding describe layer record, 
     *  determine if the target layer can be styled.  If so, enable the launch 
     *  action.
     */
    checkIfStyleable: function(layerRec, describeRec) {
        if (describeRec) {
            var owsTypes = ["WFS"];
            if (this.rasterStyling === true) {
                owsTypes.push("WCS");
            }
        }
        if (describeRec ? owsTypes.indexOf(describeRec.get("owsType")) !== -1 : !this.requireDescribeLayer) {
            var editableStyles = false;
            var source = this.target.layerSources[layerRec.get("source")];
            var url;
            // TODO: revisit this
            var restUrl = layerRec.get("restUrl");
            if (restUrl) {
                url = restUrl + "/styles";
            } else {
                url = source.url.split("?")
                    .shift().replace(/\/(wms|ows)\/?$/, "/rest/styles");
            }
            if (this.sameOriginStyling) {
                // this could be made more robust
                // for now, only style for sources with relative url
                editableStyles = url.charAt(0) === "/";
                // and assume that local sources are GeoServer instances with
                // styling capabilities
                if (this.target.authenticate && editableStyles) {
                    // we'll do on-demand authentication when the button is
                    // pressed.
                    this.launchAction.enable();
                    return;
                }
            } else {
                editableStyles = true;
            }
            if (editableStyles) {
                if (this.target.isAuthorized()) {
                    // check if service is available
                    this.enableActionIfAvailable(url);
                }
            }
        }
    },
    
    /** private: method[enableActionIfAvailable]
     *  :arg url: ``String`` URL of style service
     * 
     *  Enable the launch action if the service is available.
     */
    enableActionIfAvailable: function(url) {
        Ext.Ajax.request({
            method: "PUT",
            url: url,
            callback: function(options, success, response) {
                // we expect a 405 error code here if we are dealing
                // with GeoServer and have write access.
                this.launchAction.setDisabled(response.status !== 405);                        
            },
            scope: this
        });
    },
    
    addOutput: function(config) {
        config = config || {};
        var record = this.target.selectedLayer;

        var origCfg = this.initialConfig.outputConfig || {};
        this.outputConfig.title = origCfg.title ||
            this.menuText + ": " + record.get("title");
        this.outputConfig.shortTitle = record.get("title");

        Ext.apply(config, gxp.WMSStylesDialog.createGeoServerStylerConfig(record));
        if (this.rasterStyling === true) {
            config.plugins.push({
                ptype: "gxp_wmsrasterstylesdialog"
            });
        }
        Ext.applyIf(config, {style: "padding: 10px"});
        
        var output = gxp.plugins.Styler.superclass.addOutput.call(this, config);
        if (!(output.ownerCt.ownerCt instanceof Ext.Window)) {
            output.dialogCls = Ext.Panel;
            output.showDlg = function(dlg) {
                dlg.layout = "fit";
                dlg.autoHeight = false;
                output.ownerCt.add(dlg);
            };
        }
        output.stylesStore.on("load", function() {
            if (!this.outputTarget && output.ownerCt.ownerCt instanceof Ext.Window) {
                output.ownerCt.ownerCt.center();
            }
        });
    }
        
});

Ext.preg(gxp.plugins.Styler.prototype.ptype, gxp.plugins.Styler);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 * @requires OpenLayers/Control/NavigationHistory.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = NavigationHistory
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: NavigationHistory(config)
 *
 *    Provides two actions for zooming back and forth.
 */
gxp.plugins.NavigationHistory = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_navigationhistory */
    ptype: "gxp_navigationhistory",
    
    /** api: config[previousMenuText]
     *  ``String``
     *  Text for zoom previous menu item (i18n).
     */
    previousMenuText: "Zoom To Previous Extent",

    /** api: config[nextMenuText]
     *  ``String``
     *  Text for zoom next menu item (i18n).
     */
    nextMenuText: "Zoom To Next Extent",

    /** api: config[previousTooltip]
     *  ``String``
     *  Text for zoom previous action tooltip (i18n).
     */
    previousTooltip: "Zoom To Previous Extent",

    /** api: config[nextTooltip]
     *  ``String``
     *  Text for zoom next action tooltip (i18n).
     */
    nextTooltip: "Zoom To Next Extent",
    
    /** private: method[constructor]
     */
    constructor: function(config) {
        gxp.plugins.NavigationHistory.superclass.constructor.apply(this, arguments);
    },

    /** api: method[addActions]
     */
    addActions: function() {
        var historyControl = new OpenLayers.Control.NavigationHistory();
        this.target.mapPanel.map.addControl(historyControl);
        var actions = [new GeoExt.Action({
            menuText: this.previousMenuText,
            iconCls: "gxp-icon-zoom-previous",
            tooltip: this.previousTooltip,
            disabled: true,
            control: historyControl.previous
        }), new GeoExt.Action({
            menuText: this.nextMenuText,
            iconCls: "gxp-icon-zoom-next",
            tooltip: this.nextTooltip,
            disabled: true,
            control: historyControl.next
        })];
        return gxp.plugins.NavigationHistory.superclass.addActions.apply(this, [actions]);
    }
        
});

Ext.preg(gxp.plugins.NavigationHistory.prototype.ptype, gxp.plugins.NavigationHistory);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 * @require OpenLayers/Control/ZoomBox.js
 * @require GeoExt/widgets/Action.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = Zoom
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: Zoom(config)
 *
 *    Provides actions for box zooming, zooming in and zooming out.
 */
gxp.plugins.Zoom = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_zoom */
    ptype: "gxp_zoom",
    
    /** api: config[zoomMenuText]
     *  ``String``
     *  Text for zoom box menu item (i18n).
     */
    zoomMenuText: "Zoom Box",

    /** api: config[zoomInMenuText]
     *  ``String``
     *  Text for zoom in menu item (i18n).
     */
    zoomInMenuText: "Zoom In",

    /** api: config[zoomOutMenuText]
     *  ``String``
     *  Text for zoom out menu item (i18n).
     */
    zoomOutMenuText: "Zoom Out",

    /** api: config[zoomInTooltip]
     *  ``String``
     *  Text for zoom box action tooltip (i18n).
     */
    zoomTooltip: "Zoom by dragging a box",

    /** api: config[zoomInTooltip]
     *  ``String``
     *  Text for zoom in action tooltip (i18n).
     */
    zoomInTooltip: "Zoom in",

    /** api: config[zoomOutTooltip]
     *  ``String``
     *  Text for zoom out action tooltip (i18n).
     */
    zoomOutTooltip: "Zoom out",
    
    /** api: config[toggleGroup]
     *  ``String`` Toggle group for this plugin's Zoom action.
     */
    
    /** api: config[showZoomBoxAction]
     * {Boolean} If true, the tool will have a Zoom Box button as first action.
     * The zoom box will be provided by an OpenLayers.Control.ZoomBox, and
     * :obj:`controlOptions` configured for this tool will apply to the ZoomBox
     * control.
     * If set to false, only Zoom In and Zoom Out buttons will be created.
     * Default is false.
     */

    /** private: method[constructor]
     */
    constructor: function(config) {
        gxp.plugins.Zoom.superclass.constructor.apply(this, arguments);
    },

    /** api: method[addActions]
     */
    addActions: function() {
        var actions = [{
            menuText: this.zoomInMenuText,
            iconCls: "gxp-icon-zoom-in",
            tooltip: this.zoomInTooltip,
            handler: function() {
                this.target.mapPanel.map.zoomIn();    
            },
            scope: this
        }, {
            menuText: this.zoomOutMenuText,
            iconCls: "gxp-icon-zoom-out",
            tooltip: this.zoomOutTooltip,
            handler: function() {
                this.target.mapPanel.map.zoomOut();
            },
            scope: this
        }];
        if (this.showZoomBoxAction) {
            actions.unshift(new GeoExt.Action({
                menuText: this.zoomText,
                iconCls: "gxp-icon-zoom",
                tooltip: this.zoomTooltip,
                control: new OpenLayers.Control.ZoomBox(this.controlOptions),
                map: this.target.mapPanel.map,
                enableToggle: true,
                allowDepress: false,
                toggleGroup: this.toggleGroup
            }));
        }
        return gxp.plugins.Zoom.superclass.addActions.apply(this, [actions]);
    }
        
});

Ext.preg(gxp.plugins.Zoom.prototype.ptype, gxp.plugins.Zoom);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = ZoomToExtent
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: ZoomToExtent(config)
 *
 *    Provides an action for zooming to an extent.  If not configured with a 
 *    specific extent, the action will zoom to the map's visible extent.
 */
gxp.plugins.ZoomToExtent = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_zoomtoextent */
    ptype: "gxp_zoomtoextent",
    
    /** api: config[buttonText]
     *  ``String`` Text to show next to the zoom button
     */
     
    /** api: config[menuText]
     *  ``String``
     *  Text for zoom menu item (i18n).
     */
    menuText: "Zoom To Max Extent",

    /** api: config[tooltip]
     *  ``String``
     *  Text for zoom action tooltip (i18n).
     */
    tooltip: "Zoom To Max Extent",
    
    /** api: config[extent]
     *  ``Array | OpenLayers.Bounds``
     *  The target extent.  If none is provided, the map's visible extent will 
     *  be used.
     */
    extent: null,
    
    /** api: config[closest]
     *  ``Boolean`` Find the zoom level that most closely fits the specified
     *  extent. Note that this may result in a zoom that does not exactly
     *  contain the entire extent.  Default is true.
     */
    closest: true,
    
    /** private: property[iconCls]
     */
    iconCls: "gxp-icon-zoomtoextent",
    
    /** api: config[closest]
     *  ``Boolean`` Find the zoom level that most closely fits the specified
     *  extent. Note that this may result in a zoom that does not exactly
     *  contain the entire extent.  Default is true.
     */
    closest: true,
    
    /** private: method[constructor]
     */
    constructor: function(config) {
        gxp.plugins.ZoomToExtent.superclass.constructor.apply(this, arguments);
        if (this.extent instanceof Array) {
            this.extent = OpenLayers.Bounds.fromArray(this.extent);
        }
    },

    /** api: method[addActions]
     */
    addActions: function() {
        return gxp.plugins.ZoomToExtent.superclass.addActions.apply(this, [{
            text: this.buttonText,
            menuText: this.menuText,
            iconCls: this.iconCls,
            tooltip: this.tooltip,
            handler: function() {
                var map = this.target.mapPanel.map;
                var extent = typeof this.extent == "function" ? this.extent() : this.extent;
                if (!extent) {
                    // determine visible extent
                    var layer, extended;
                    for (var i=0, len=map.layers.length; i<len; ++i) {
                        layer = map.layers[i];
                        if (layer.getVisibility()) {
                            extended = layer.restrictedExtent || layer.maxExtent;
                            if (extent) {
                                extent.extend(extended);
                            } else if (extended) {
                                extent = extended.clone();
                            }
                        }
                    }
                }
                if (extent) {
                    // respect map properties
                    var restricted = map.restrictedExtent || map.maxExtent;
                    if (restricted) {
                        extent = new OpenLayers.Bounds(
                            Math.max(extent.left, restricted.left),
                            Math.max(extent.bottom, restricted.bottom),
                            Math.min(extent.right, restricted.right),
                            Math.min(extent.top, restricted.top)
                        );
                    }
                    map.zoomToExtent(extent, this.closest);
                }
            },
            scope: this
        }]);
    }
        
});

Ext.preg(gxp.plugins.ZoomToExtent.prototype.ptype, gxp.plugins.ZoomToExtent);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/ZoomToExtent.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = ZoomToDataExtent
 */

/** api: (extends)
 *  plugins/ZoomToExtent.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: ZoomToDataExtent(config)
 *
 *    Plugin for zooming to the data extent of a vector layer
 */
gxp.plugins.ZoomToDataExtent = Ext.extend(gxp.plugins.ZoomToExtent, {
    
    /** api: ptype = gxp_zoomtodataextent */
    ptype: "gxp_zoomtodataextent",
    
    /** api: config[menuText]
     *  ``String``
     *  Text for zoom menu item (i18n).
     */
    menuText: "Zoom to layer extent",

    /** api: config[tooltip]
     *  ``String``
     *  Text for zoom action tooltip (i18n).
     */
    tooltip: "Zoom to layer extent",
    
    /** api: config[featureManager]
     *  ``String`` id of the :class:`gxp.plugins.FeatureManager` to look for
     *  selected features
     */
    
    /** api: config[closest]
     *  ``Boolean`` Find the zoom level that most closely fits the specified
     *  extent. Note that this may result in a zoom that does not exactly
     *  contain the entire extent.  Default is false.
     */
    closest: false,

    /** private: property[iconCls]
     */
    iconCls: "gxp-icon-zoom-to",

    /** api: method[extent]
     */
    extent: function() {
        return this.target.tools[this.featureManager].featureLayer.getDataExtent();
    },

    /** api: method[addActions]
     */
    addActions: function() {
        var actions = gxp.plugins.ZoomToDataExtent.superclass.addActions.apply(this, arguments);
        actions[0].disable();

        var layer = this.target.tools[this.featureManager].featureLayer;
        layer.events.on({
            "featuresadded": function() {
                actions[0].isDisabled() && actions[0].enable();
            },
            "featuresremoved": function() {
                layer.features.length == 0 && actions[0].disable();
            }
        });
        
        return actions;
    }
        
});

Ext.preg(gxp.plugins.ZoomToDataExtent.prototype.ptype, gxp.plugins.ZoomToDataExtent);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/ZoomToExtent.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = ZoomToLayerExtent
 */

/** api: (extends)
 *  plugins/ZoomToExtent.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: ZoomToLayerExtent(config)
 *
 *    Plugin for zooming to the extent of a non-vector layer
 */
gxp.plugins.ZoomToLayerExtent = Ext.extend(gxp.plugins.ZoomToExtent, {
    
    /** api: ptype = gxp_zoomtolayerextent */
    ptype: "gxp_zoomtolayerextent",
    
    /** api: config[menuText]
     *  ``String``
     *  Text for zoom menu item (i18n).
     */
    menuText: "Zoom to layer extent",

    /** api: config[tooltip]
     *  ``String``
     *  Text for zoom action tooltip (i18n).
     */
    tooltip: "Zoom to layer extent",
    
    /** private: property[iconCls]
     */
    iconCls: "gxp-icon-zoom-to",

    /** private: method[destroy]
     */
    destroy: function() {
        this.selectedRecord = null;
        gxp.plugins.ZoomToLayerExtent.superclass.destroy.apply(this, arguments);
    },

    /** api: method[extent]
     */
    extent: function() {
        var layer = this.selectedRecord.getLayer(),
            dataExtent;
        if (OpenLayers.Layer.Vector) {
            dataExtent = layer instanceof OpenLayers.Layer.Vector &&
                layer.getDataExtent();
        }
        return layer.restrictedExtent || dataExtent || layer.maxExtent || map.maxExtent;
    },

    /** api: method[addActions]
     */
    addActions: function() {
        var actions = gxp.plugins.ZoomToLayerExtent.superclass.addActions.apply(this, arguments);
        actions[0].disable();

        this.target.on("layerselectionchange", function(record) {
            this.selectedRecord = record;
            actions[0].setDisabled(
                !record || !record.get('layer')
            );
        }, this);

        return actions;
    }
        
});

Ext.preg(gxp.plugins.ZoomToLayerExtent.prototype.ptype, gxp.plugins.ZoomToLayerExtent);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/ZoomToExtent.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = ZoomToSelectedFeatures
 */

/** api: (extends)
 *  plugins/ZoomToExtent.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: ZoomToSelectedFeatures(config)
 *
 *    Plugin for zooming to the extent of selected features
 */
gxp.plugins.ZoomToSelectedFeatures = Ext.extend(gxp.plugins.ZoomToExtent, {
    
    /** api: ptype = gxp_zoomtoselectedfeatures */
    ptype: "gxp_zoomtoselectedfeatures",
    
    /** api: config[menuText]
     *  ``String``
     *  Text for zoom menu item (i18n).
     */
    menuText: "Zoom to selected features",

    /** api: config[tooltip]
     *  ``String``
     *  Text for zoom action tooltip (i18n).
     */
    tooltip: "Zoom to selected features",
    
    /** api: config[featureManager]
     *  ``String`` id of the :class:`gxp.plugins.FeatureManager` to look for
     *  selected features
     */
    
    /** api: config[closest]
     *  ``Boolean`` Find the zoom level that most closely fits the specified
     *  extent. Note that this may result in a zoom that does not exactly
     *  contain the entire extent.  Default is false.
     */
    closest: false,
    
    /** private: property[layer]
     *  ``OpenLayers.Layer`` The layer to work with
     */
    layer: null,

    /** private: property[iconCls]
     */
    iconCls: "gxp-icon-zoom-to",
    
    /** private: method[extent]
     */
    extent: function() {
        var layer = this.target.tools[this.featureManager].featureLayer;
        var bounds, geom, extent, features = layer.selectedFeatures;
        for (var i=features.length-1; i>=0; --i) {
            geom = features[i].geometry;
            if (geom) {
                extent = geom.getBounds();
                if (bounds) {
                    bounds.extend(extent);
                } else {
                    bounds = extent.clone();
                }
            }
        }
        return bounds;
     },
    
    /** api: method[addActions]
     */
    addActions: function() {
        var actions = gxp.plugins.ZoomToSelectedFeatures.superclass.addActions.apply(this, arguments);
        actions[0].disable();
        
        var handlers = {
            "featureselected": function(evt) {
                if (actions[0].isDisabled() && evt.feature.geometry !== null) {
                    actions[0].enable();
                }
            },
            "featureunselected": function() {
                if (this.layer.selectedFeatures.length === 0) {
                    actions[0].disable();
                }
            },
            scope: this
        };
        
        var featureManager = this.target.tools[this.featureManager];
        
        function register() {
            if (this.layer) {
                this.layer.events.un(handlers);
            }
            this.layer = featureManager.featureLayer;
            if (this.layer) {
                this.layer.events.on(handlers);
            }
        }
        
        this.target.on("layerselectionchange", register);
        featureManager.on("query", function() { actions[0].disable(); });
        register.call(this);
        
        return actions;
    }
        
});

Ext.preg(gxp.plugins.ZoomToSelectedFeatures.prototype.ptype, gxp.plugins.ZoomToSelectedFeatures);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 * @requires OpenLayers/StyleMap.js
 * @requires OpenLayers/Rule.js
 * @requires OpenLayers/Control/Measure.js
 * @requires OpenLayers/Layer/Vector.js
 * @requires OpenLayers/Handler/Path.js
 * @requires OpenLayers/Handler/Polygon.js
 * @requires OpenLayers/Renderer/SVG.js
 * @requires OpenLayers/Renderer/VML.js
 * @requires OpenLayers/Renderer/Canvas.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = Measure
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: Measure(config)
 *
 *    Provides two actions for measuring length and area.
 */
gxp.plugins.Measure = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_measure */
    ptype: "gxp_measure",

    /** api: config[outputTarget]
     *  ``String`` Popups created by this tool are added to the map by default.
     */
    outputTarget: "map",

    /** api: config[buttonText]
     *  ``String``
     *  Text for the Measure button (i18n).
     */
    buttonText: "Measure",

    /** api: config[lengthMenuText]
     *  ``String``
     *  Text for measure length menu item (i18n).
     */
    lengthMenuText: "Length",

    /** api: config[areaMenuText]
     *  ``String``
     *  Text for measure area menu item (i18n).
     */
    areaMenuText: "Area",

    /** api: config[lengthTooltip]
     *  ``String``
     *  Text for measure length action tooltip (i18n).
     */
    lengthTooltip: "Measure length",

    /** api: config[areaTooltip]
     *  ``String``
     *  Text for measure area action tooltip (i18n).
     */
    areaTooltip: "Measure area",

    /** api: config[measureTooltip]
     *  ``String``
     *  Text for measure action tooltip (i18n).
     */
    measureTooltip: "Measure",

    /** private: method[constructor]
     */
    constructor: function(config) {
        gxp.plugins.Measure.superclass.constructor.apply(this, arguments);
    },

    /** private: method[destroy]
     */
    destroy: function() {
        this.button = null;
        gxp.plugins.Measure.superclass.destroy.apply(this, arguments);
    },

    /** private: method[createMeasureControl]
     * :param: handlerType: the :class:`OpenLayers.Handler` for the measurement
     *     operation
     * :param: title: the string label to display alongside results
     *
     * Convenience method for creating a :class:`OpenLayers.Control.Measure`
     * control
     */
    createMeasureControl: function(handlerType, title) {

        var styleMap = new OpenLayers.StyleMap({
            "default": new OpenLayers.Style(null, {
                rules: [new OpenLayers.Rule({
                    symbolizer: {
                        "Point": {
                            pointRadius: 4,
                            graphicName: "square",
                            fillColor: "white",
                            fillOpacity: 1,
                            strokeWidth: 1,
                            strokeOpacity: 1,
                            strokeColor: "#333333"
                        },
                        "Line": {
                            strokeWidth: 3,
                            strokeOpacity: 1,
                            strokeColor: "#666666",
                            strokeDashstyle: "dash"
                        },
                        "Polygon": {
                            strokeWidth: 2,
                            strokeOpacity: 1,
                            strokeColor: "#666666",
                            fillColor: "white",
                            fillOpacity: 0.3
                        }
                    }
                })]
            })
        });
        var cleanup = function() {
            if (measureToolTip) {
                measureToolTip.destroy();
            }  
        };

        var makeString = function(metricData) {
            var metric = metricData.measure;
            var metricUnit = metricData.units;

            measureControl.displaySystem = "english";

            var englishData = metricData.geometry.CLASS_NAME.indexOf("LineString") > -1 ?
            measureControl.getBestLength(metricData.geometry) :
            measureControl.getBestArea(metricData.geometry);

            var english = englishData[0];
            var englishUnit = englishData[1];

            measureControl.displaySystem = "metric";
            var dim = metricData.order == 2 ?
            '<sup>2</sup>' :
            '';

            return metric.toFixed(2) + " " + metricUnit + dim + "<br>" +
                english.toFixed(2) + " " + englishUnit + dim;
        };

        var measureToolTip;
        var controlOptions = Ext.apply({}, this.initialConfig.controlOptions);
        Ext.applyIf(controlOptions, {
            geodesic: true,
            persist: true,
            handlerOptions: {layerOptions: {styleMap: styleMap}},
            eventListeners: {
                measurepartial: function(event) {
                    cleanup();
                    measureToolTip = this.addOutput({
                        xtype: 'tooltip',
                        html: makeString(event),
                        title: title,
                        autoHide: false,
                        closable: true,
                        draggable: false,
                        mouseOffset: [0, 0],
                        showDelay: 1,
                        listeners: {hide: cleanup}
                    });
                    if(event.measure > 0) {
                        var px = measureControl.handler.lastUp;
                        var p0 = this.target.mapPanel.getPosition();
                        measureToolTip.targetXY = [p0[0] + px.x, p0[1] + px.y];
                        measureToolTip.show();
                    }
                },
                deactivate: cleanup,
                scope: this
            }
        });
        var measureControl = new OpenLayers.Control.Measure(handlerType, 
            controlOptions);

        return measureControl;
    },

    /** api: method[addActions]
     */
    addActions: function() {
        this.activeIndex = 0;
        this.button = new Ext.SplitButton({
            iconCls: "gxp-icon-measure-length",
            tooltip: this.measureTooltip,
            buttonText: this.buttonText,
            enableToggle: true,
            toggleGroup: this.toggleGroup,
            allowDepress: true,
            handler: function(button, event) {
                if(button.pressed) {
                    button.menu.items.itemAt(this.activeIndex).setChecked(true);
                }
            },
            scope: this,
            listeners: {
                toggle: function(button, pressed) {
                    // toggleGroup should handle this
                    if(!pressed) {
                        button.menu.items.each(function(i) {
                            i.setChecked(false);
                        });
                    }
                },
                render: function(button) {
                    // toggleGroup should handle this
                    Ext.ButtonToggleMgr.register(button);
                }
            },
            menu: new Ext.menu.Menu({
                items: [
                    new Ext.menu.CheckItem(
                        new GeoExt.Action({
                            text: this.lengthMenuText,
                            iconCls: "gxp-icon-measure-length",
                            toggleGroup: this.toggleGroup,
                            group: this.toggleGroup,
                            listeners: {
                                checkchange: function(item, checked) {
                                    this.activeIndex = 0;
                                    this.button.toggle(checked);
                                    if (checked) {
                                        this.button.setIconClass(item.iconCls);
                                    }
                                },
                                scope: this
                            },
                            map: this.target.mapPanel.map,
                            control: this.createMeasureControl(
                                OpenLayers.Handler.Path, this.lengthTooltip
                            )
                        })
                    ),
                    new Ext.menu.CheckItem(
                        new GeoExt.Action({
                            text: this.areaMenuText,
                            iconCls: "gxp-icon-measure-area",
                            toggleGroup: this.toggleGroup,
                            group: this.toggleGroup,
                            allowDepress: false,
                            listeners: {
                                checkchange: function(item, checked) {
                                    this.activeIndex = 1;
                                    this.button.toggle(checked);
                                    if (checked) {
                                        this.button.setIconClass(item.iconCls);
                                    }
                                },
                                scope: this
                            },
                            map: this.target.mapPanel.map,
                            control: this.createMeasureControl(
                                OpenLayers.Handler.Polygon, this.areaTooltip
                            )
                        })
                    )
                ]
            })
        });

        return gxp.plugins.Measure.superclass.addActions.apply(this, [this.button]);
    }
        
});

Ext.preg(gxp.plugins.Measure.prototype.ptype, gxp.plugins.Measure);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 * @requires OpenLayers/Kinetic.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = Navigation
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: Navigation(config)
 *
 *    Provides one action for panning the map and zooming in with
 *    a box. Optionally provide mousewheel zoom support.
 */
gxp.plugins.Navigation = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_navigation */
    ptype: "gxp_navigation",
    
    /** api: config[menuText]
     *  ``String``
     *  Text for navigation menu item (i18n).
     */
    menuText: "Pan Map",

    /** api: config[tooltip]
     *  ``String``
     *  Text for navigation action tooltip (i18n).
     */
    tooltip: "Pan Map",

    /** private: method[constructor]
     */
    constructor: function(config) {
        gxp.plugins.Navigation.superclass.constructor.apply(this, arguments);
    },

    /** api: method[addActions]
     */
    addActions: function() {
        var control;
        // If no controlOptions are configured, try to find a Navigation
        // control on the target map.
        if (!this.controlOptions) {
            candidates = this.target.mapPanel.map.getControlsByClass('OpenLayers.Control.Navigation');
            if (candidates.length) {
                control = candidates[0];
            }
        } else {
            this.controlOptions = this.controlOptions || {};
            Ext.applyIf(this.controlOptions, {dragPanOptions: {enableKinetic: true}});
            control = new OpenLayers.Control.Navigation(this.controlOptions);
        }
        var actions = [new GeoExt.Action({
            tooltip: this.tooltip,
            menuText: this.menuText,
            iconCls: "gxp-icon-pan",
            enableToggle: true,
            pressed: true,
            allowDepress: false,
            control: control,
            map: control.map ? null : this.target.mapPanel.map,
            toggleGroup: this.toggleGroup
        })];
        return gxp.plugins.Navigation.superclass.addActions.apply(this, [actions]);
    }
        
});

Ext.preg(gxp.plugins.Navigation.prototype.ptype, gxp.plugins.Navigation);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = LayerProperties
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: LayerProperties(config)
 *
 *    Plugin for showing the properties of a selected layer from the map.
 */
gxp.plugins.LayerProperties = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_layerproperties */
    ptype: "gxp_layerproperties",
    
    /** api: config[menuText]
     *  ``String``
     *  Text for layer properties menu item (i18n).
     */
    menuText: "Layer Properties",

    /** api: config[toolTip]
     *  ``String``
     *  Text for layer properties action tooltip (i18n).
     */
    toolTip: "Layer Properties",
    
    /** api: config[layerPanelConfig]
     *  ``Object`` Additional configuration options for the layer type specific
     *  properties panels, keyed by xtype, e.g.:
     *
     *  .. code-block:: javascript
     *
     *      layerPanelConfig: {
     *          "gxp_wmslayerpanel": {rasterStyling: true}
     *      }
     */
    
    constructor: function(config) {
        gxp.plugins.LayerProperties.superclass.constructor.apply(this, arguments);
        
        if (!this.outputConfig) {
            this.outputConfig = {
                width: 325,
                autoHeight: true
            };
        }
    },
        
    /** api: method[addActions]
     */
    addActions: function() {
        var actions = gxp.plugins.LayerProperties.superclass.addActions.apply(this, [{
            menuText: this.menuText,
            iconCls: "gxp-icon-layerproperties",
            disabled: true,
            tooltip: this.toolTip,
            handler: function() {
                this.removeOutput();
                this.addOutput();
            },
            scope: this
        }]);
        var layerPropertiesAction = actions[0];

        this.target.on("layerselectionchange", function(record) {
            layerPropertiesAction.setDisabled(
                !record || !record.get("properties")
            );
        }, this);
        return actions;
    },
    
    addOutput: function(config) {
        config = config || {};
        var record = this.target.selectedLayer;
        var origCfg = this.initialConfig.outputConfig || {};
        this.outputConfig.title = origCfg.title ||
            this.menuText + ": " + record.get("title");
        this.outputConfig.shortTitle = record.get("title");
        
        //TODO create generic gxp_layerpanel
        var xtype = record.get("properties") || "gxp_layerpanel";
        var panelConfig = this.layerPanelConfig;
        if (panelConfig && panelConfig[xtype]) {
            Ext.apply(config, panelConfig[xtype]);
        }
        var output = gxp.plugins.LayerProperties.superclass.addOutput.call(this, Ext.apply({
            xtype: xtype,
            authorized: this.target.isAuthorized(),
            layerRecord: record,
            source: this.target.getSource(record),
            defaults: {
                style: "padding: 10px",
                autoHeight: this.outputConfig.autoHeight
            }
        }, config));
        output.on({
            added: function(cmp) {
                if (!this.outputTarget) {
                    cmp.on("afterrender", function() {
                        cmp.ownerCt.ownerCt.center();
                    }, this, {single: true});
                }
            },
            scope: this
        });
        return output;
    }
        
});

Ext.preg(gxp.plugins.LayerProperties.prototype.ptype, gxp.plugins.LayerProperties);

/**
 * Copyright (c) 2008-2012 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 * @requires widgets/form/ColorField.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = MapProperties
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: MapProperties(config)
 *
 *    Plugin for showing the properties of the map.
 */
gxp.plugins.MapProperties = Ext.extend(gxp.plugins.Tool, {

    /** api: ptype = gxp_mapproperties */
    ptype: "gxp_mapproperties",

    /** api: config[colorManager]
     *  ``Function``
     *  Optional color manager constructor to be used as a plugin for the color
     *  field.
     */
    colorManager: null,

    /** api: config[menuText]
     *  ``String``
     *  Text for map properties menu item (i18n).
     */
    menuText: "Map Properties",

    /** api: config[toolTip]
     *  ``String``
     *  Text for map properties action tooltip (i18n).
     */
    toolTip: "Map Properties",

    /* i18n */
    wrapDateLineText: "Wrap dateline",
    numberOfZoomLevelsText: "Number of zoom levels",
    colorText: "Background color",

    addActions: function() {
        var baseLayer = this.target.mapPanel.map.baseLayer;
        var container = Ext.get(this.target.mapPanel.map.getViewport());
        if (this.initialConfig.backgroundColor) {
            container.setStyle('background-color', this.initialConfig.backgroundColor);
        }
        if (this.initialConfig.numZoomLevels) {
            baseLayer.addOptions({numZoomLevels: this.initialConfig.numZoomLevels});
            this.target.mapPanel.map.events.triggerEvent('changebaselayer', {layer: baseLayer});
        }
        if (this.initialConfig.wrapDateLine) {
            baseLayer.wrapDateLine = this.initialConfig.wrapDateLine;
        }
        return gxp.plugins.MapProperties.superclass.addActions.apply(this, [{
            menuText: this.menuText,
            iconCls: "gxp-icon-mapproperties",
            tooltip: this.toolTip,
            handler: function() {
                this.removeOutput();
                this.addOutput();
            },
            scope: this
        }]);
    },

    addOutput: function() {
        var colorFieldPlugins;
        if (this.colorManager) {
            colorFieldPlugins = [new this.colorManager()];
        }
        var baseLayer = this.target.mapPanel.map.baseLayer;
        var container = Ext.get(this.target.mapPanel.map.getViewport());
        return gxp.plugins.MapProperties.superclass.addOutput.call(this, {
            xtype: 'form',
            border: false,
            bodyStyle: "padding: 10px",
            items: [{
                xtype: 'numberfield',
                allowNegative: false,
                allowDecimals: false,
                fieldLabel: this.numberOfZoomLevelsText,
                minValue: 1,
                value: baseLayer.numZoomLevels,
                listeners: {
                    "change": function(fld, value) {
                        baseLayer.addOptions({numZoomLevels: value});
                        this.target.mapPanel.map.events.triggerEvent('changebaselayer', {layer: baseLayer});
                    },
                    scope: this
                }
            }, {
                xtype: 'checkbox',
                fieldLabel: this.wrapDateLineText,
                checked: baseLayer.wrapDateLine,
                listeners: {
                    "check": function(cb, value) {
                        baseLayer.wrapDateLine = value;
                    },
                    scope: this
                }
            }, {
                xtype: "gxp_colorfield",
                fieldLabel: this.colorText,
                value: container.getColor('background-color'),
                plugins: colorFieldPlugins,
                listeners: {
                    valid: function(field) {
                        container.setStyle('background-color', field.getValue());
                    },
                    scope: this
                }
            }]
        });
    },

    /** api: method[getState]
     *  :return {Object}
     *  Gets the configured tool state.
     */
    getState: function(){
        var baseLayer = this.target.mapPanel.map.baseLayer;
        var container = Ext.get(this.target.mapPanel.map.getViewport());
        return {
            ptype: this.ptype,
            backgroundColor : container.getColor('background-color'),
            numZoomLevels : baseLayer.numZoomLevels,
            wrapDateLine : baseLayer.wrapDateLine
        };
    }
});

Ext.preg(gxp.plugins.MapProperties.prototype.ptype, gxp.plugins.MapProperties);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 * @requires GeoExt/widgets/LegendPanel.js
 * @requires GeoExt/widgets/WMSLegend.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = Legend
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: Legend(config)
 *
 *    Provides an action to display a legend in a new window.
 */
gxp.plugins.Legend = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_legend */
    ptype: "gxp_legend",
    
    /** api: config[menuText]
     *  ``String``
     *  Text for legend menu item (i18n).
     */
    menuText: "Legend",

    /** api: config[tooltip]
     *  ``String``
     *  Text for legend action tooltip (i18n).
     */
    tooltip: "Show Legend",

    /** api: config[actionTarget]
     *  ``Object`` or ``String`` or ``Array`` Where to place the tool's actions
     *  (e.g. buttons or menus)? Use null as the default since our tool has both 
     *  output and action(s).
     */
    actionTarget: null,
    
    /** private: method[constructor]
     */
    constructor: function(config) {
        gxp.plugins.Legend.superclass.constructor.apply(this, arguments);
        
        if (!this.outputConfig) {
            this.outputConfig = {
                width: 300,
                height: 400
            };
        }
        Ext.applyIf(this.outputConfig, {title: this.menuText});
    },

    /** api: method[addActions]
     */
    addActions: function() {
        var actions = [{
            menuText: this.menuText,
            iconCls: "gxp-icon-legend",
            tooltip: this.tooltip,
            handler: function() {
                this.removeOutput();
                this.addOutput(this.outputConfig);
            },
            scope: this
        }];
        return gxp.plugins.Legend.superclass.addActions.apply(this, [actions]);
    },

    /** api: method[getLegendPanel]
     *  :returns: ``GeoExt.LegendPanel``
     *
     *  Get the legend panel associated with this legend plugin.
     */
    getLegendPanel: function() {
        return this.output[0];
    },

    /** private: method[addOutput]
     *  :arg config: ``Object``
     */
    addOutput: function(config) {
        return gxp.plugins.Legend.superclass.addOutput.call(this, Ext.apply({
            xtype: 'gx_legendpanel',
            ascending: false,
            border: false,
            hideMode: "offsets",
            layerStore: this.target.mapPanel.layers,
            defaults: {cls: 'gxp-legend-item'}
        }, config));
    }

});

Ext.preg(gxp.plugins.Legend.prototype.ptype, gxp.plugins.Legend);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 * @requires GeoExt/data/PrintProvider.js
 * @requires GeoExt/widgets/PrintMapPanel.js
 * @requires OpenLayers/Control/ScaleLine.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = Print
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: Print(config)
 *
 *    Provides an action to print the map. Requires GeoExt.ux.PrintPreview,
 *    which is currently mirrored at git://github.com/GeoNode/PrintPreview.git.
 */
gxp.plugins.Print = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_print */
    ptype: "gxp_print",

    /** api: config[printService]
     *  ``String``
     *  URL of the print service. Specify either printService
     *  or printCapabilities.
     */
    printService: null,

    /** api: config[printCapabilities]
     *  ``Object``
     *  Capabilities object of the print service. Specify either printService
     *  or printCapabilities.
     */
    printCapabilities: null,

    /** api: config[customParams]
     *  ``Object`` Key-value pairs of custom data to be sent to the print
     *  service. Optional. This is e.g. useful for complex layout definitions
     *  on the server side that require additional parameters.
     */
    customParams: null,

    /** api: config[includeLegend]
     *  ``Boolean`` Should we include the legend in the print? Defaults to false.
     */
    includeLegend: false,

    /** api: config[menuText]
     *  ``String``
     *  Text for print menu item (i18n).
     */
    menuText: "Print Map",

    /** api: config[tooltip]
     *  ``String``
     *  Text for print action tooltip (i18n).
     */
    tooltip: "Print Map",

    /** api: config[text]
     *  ``String``
     *  Text for print action button (i18n).
     */
    buttonText: "Print",

    /** api: config[notAllNotPrintableText]
     *  ``String``
     *  Text for message when not all layers can be printed (i18n).
     */
    notAllNotPrintableText: "Not All Layers Can Be Printed",

    /** api: config[nonePrintableText]
     *  ``String``
     *  Text for message no layers are suitable for printing (i18n).
     */
    nonePrintableText: "None of your current map layers can be printed",

    /** api: config[previewText]
     *  ``String``
     *  Text for print preview text (i18n).
     */
    previewText: "Print Preview",

    /** api: config[openInNewWindow]
     *  ``Boolean``
     *  If true, always open in new window regardless of the browser type.
     */
    openInNewWindow: false,

    /** private: method[constructor]
     */
    constructor: function(config) {
        gxp.plugins.Print.superclass.constructor.apply(this, arguments);
    },

    /** api: method[addActions]
     */
    addActions: function() {
        // don't add any action if there is no print service configured
        if (this.printService !== null || this.printCapabilities != null) {

            var printProvider = new GeoExt.data.PrintProvider({
                capabilities: this.printCapabilities,
                url: this.printService,
                customParams: this.customParams,
                autoLoad: false,
                listeners: {
                    beforedownload: function(provider, url) {
                        if (this.openInNewWindow === true) {
                            window.open(url);
                            return false;
                        }
                    },
                    beforeencodelegend: function(provider, jsonData, legend) {
                        if (legend && legend.ptype === "gxp_layermanager") {
                            var encodedLegends = [];
                            var output = legend.output;
                            if (output && output[0]) {
                                output[0].getRootNode().cascade(function(node) {
                                    if (node.component && !node.component.hidden) {
                                        var cmp = node.component;
                                        var encFn = this.encoders.legends[cmp.getXType()];
                                        encodedLegends = encodedLegends.concat(
                                            encFn.call(this, cmp, jsonData.pages[0].scale));
                                    }
                                }, provider);
                            }
                            jsonData.legends = encodedLegends;
                            // cancel normal encoding of legend
                            return false;
                        }
                    },
                    beforeprint: function() {
                        // The print module does not like array params.
                        // TODO Remove when http://trac.geoext.org/ticket/216 is fixed.
                        printWindow.items.get(0).printMapPanel.layers.each(function(l) {
                            var params = l.get("layer").params;
                            for(var p in params) {
                                if (params[p] instanceof Array) {
                                    params[p] = params[p].join(",");
                                }
                            }
                        });
                    },
                    loadcapabilities: function() {
                        if (printButton) {
                            printButton.initialConfig.disabled = false;
                            printButton.enable();
                        }
                    },
                    print: function() {
                        try {
                            printWindow.close();
                        } catch (err) {
                            // TODO: improve destroy
                        }
                    },
                    printException: function(cmp, response) {
                        this.target.displayXHRTrouble && this.target.displayXHRTrouble(response);
                    },
                    scope: this
                }
            });

            var actions = gxp.plugins.Print.superclass.addActions.call(this, [{
                menuText: this.menuText,
                buttonText: this.buttonText,
                tooltip: this.tooltip,
                iconCls: "gxp-icon-print",
                disabled: this.printCapabilities !== null ? false : true,
                handler: function() {
                    var supported = getPrintableLayers();
                    if (supported.length > 0) {
                        var printWindow = createPrintWindow.call(this);
                        showPrintWindow.call(this);
                        return printWindow;
                    } else {
                        // no layers supported
                        Ext.Msg.alert(
                            this.notAllNotPrintableText,
                            this.nonePrintableText
                        );
                    }
                },
                scope: this,
                listeners: {
                    render: function() {
                        // wait to load until render so we can enable on success
                        printProvider.loadCapabilities();
                    }
                }
            }]);

            var printButton = actions[0].items[0];

            var printWindow;

            function destroyPrintComponents() {
                if (printWindow) {
                    // TODO: fix this in GeoExt
                    try {
                        var panel = printWindow.items.first();
                        panel.printMapPanel.printPage.destroy();
                        //panel.printMapPanel.destroy();
                    } catch (err) {
                        // TODO: improve destroy
                    }
                    printWindow = null;
                }
            }

            var mapPanel = this.target.mapPanel;
            function getPrintableLayers() {
                var supported = [];
                mapPanel.layers.each(function(record) {
                    var layer = record.getLayer();
                    if (isPrintable(layer)) {
                        supported.push(layer);
                    }
                });
                return supported;
            }

            function isPrintable(layer) {
                return layer.getVisibility() === true && (
                    layer instanceof OpenLayers.Layer.WMS ||
                    layer instanceof OpenLayers.Layer.OSM
                );
            }

            function createPrintWindow() {
                var legend = null;
                if (this.includeLegend === true) {
                    var key, tool;
                    for (key in this.target.tools) {
                        tool = this.target.tools[key];
                        if (tool.ptype === "gxp_legend") {
                            legend = tool.getLegendPanel();
                            break;
                        }
                    }
                    // if not found, look for a layer manager instead
                    if (legend === null) {
                        for (key in this.target.tools) {
                            tool = this.target.tools[key];
                            if (tool.ptype === "gxp_layermanager") {
                                legend = tool;
                                break;
                            }
                        }
                    }
                }
                printWindow = new Ext.Window({
                    title: this.previewText,
                    modal: true,
                    border: false,
                    autoHeight: true,
                    resizable: false,
                    width: 360,
                    items: [
                        new GeoExt.ux.PrintPreview({
                            minWidth: 336,
                            mapTitle: this.target.about && this.target.about["title"],
                            comment: this.target.about && this.target.about["abstract"],
                            printMapPanel: {
                                autoWidth: true,
                                height: Math.min(420, Ext.get(document.body).getHeight()-150),
                                limitScales: true,
                                map: Ext.applyIf({
                                    controls: [
                                        new OpenLayers.Control.Navigation({
                                            zoomWheelEnabled: false,
                                            zoomBoxEnabled: false
                                        }),
                                        new OpenLayers.Control.PanPanel(),
                                        new OpenLayers.Control.ZoomPanel(),
                                        new OpenLayers.Control.Attribution()
                                    ],
                                    eventListeners: {
                                        preaddlayer: function(evt) {
                                            return isPrintable(evt.layer);
                                        }
                                    }
                                }, mapPanel.initialConfig.map),
                                items: [{
                                    xtype: "gx_zoomslider",
                                    vertical: true,
                                    height: 100,
                                    aggressive: true
                                }],
                                listeners: {
                                    afterlayout: function(evt) {
                                        printWindow.setWidth(Math.max(360, this.getWidth() + 24));
                                        printWindow.center();
                                    }
                                }
                            },
                            printProvider: printProvider,
                            includeLegend: this.includeLegend,
                            legend: legend,
                            sourceMap: mapPanel
                        })
                    ],
                    listeners: {
                        beforedestroy: destroyPrintComponents
                    }
                });
                return printWindow;
            }

            function showPrintWindow() {
                printWindow.show();

                // measure the window content width by it's toolbar
                printWindow.setWidth(0);
                var tb = printWindow.items.get(0).items.get(0);
                var w = 0;
                tb.items.each(function(item) {
                    if(item.getEl()) {
                        w += item.getWidth();
                    }
                });
                printWindow.setWidth(
                    Math.max(printWindow.items.get(0).printMapPanel.getWidth(),
                    w + 20)
                );
                printWindow.center();
            }

            return actions;
        }
    }

});

Ext.preg(gxp.plugins.Print.prototype.ptype, gxp.plugins.Print);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = LoadingIndicator
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: LoadingIndicator(config)
 *
 *    Static plugin for show a loading indicator on the map.
 */   
gxp.plugins.LoadingIndicator = Ext.extend(gxp.plugins.Tool, {

    /** api: ptype = gxp_loadingindicator */
    ptype: "gxp_loadingindicator",

    /** api: config[onlyShowOnFirstLoad]
     * ``Boolean`` Set this to true to only show the loading indicator on the 
     * first load of the map. Default is false.
     */
    onlyShowOnFirstLoad: false,

    /** api: config[loadingMapMessage]
     *  ``String`` Message to show when the map is loading (i18n)
     */
    loadingMapMessage: "Loading Map...",

    /** private: property[layerCount]
     * ``Integer`` The number of layers currently loading.
     */ 
    layerCount: 0,

    /**
     * private: property[busyMask]
     * ``Ext.LoadMask`` The Ext load mask to show when busy.
     */
    busyMask: null,

    /** private: method[init]
     *  :arg target: ``Object``
     */
    init: function(target) {
        var map = target instanceof GeoExt.MapPanel ?
            target.map : target.mapPanel.map;
        map.events.register("preaddlayer", this, function(e) {
            var layer = e.layer;
            if (layer instanceof OpenLayers.Layer.WMS) {
                layer.events.on({
                    "loadstart": function() {
                        this.layerCount++;
                        if (!this.busyMask) {
                            this.busyMask = new Ext.LoadMask(
                                map.div, {
                                    msg: this.loadingMapMessage
                                }
                            );
                        }
                        this.busyMask.show();
                        if (this.onlyShowOnFirstLoad === true) {
                            layer.events.unregister("loadstart", this, arguments.callee);
                        }
                    },
                    "loadend": function() {
                        this.layerCount--;
                        if(this.layerCount === 0) {
                            this.busyMask.hide();
                        }
                        if (this.onlyShowOnFirstLoad === true) {
                            layer.events.unregister("loadend", this, arguments.callee);
                        }
                    },
                    scope: this
                });
            } 
        });
    },

    /** private: method[destroy]
     */
    destroy : function(){
        Ext.destroy(this.busyMask);
        this.busyMask = null;
        gxp.plugins.LoadingIndicator.superclass.destroy.apply(this, arguments);
    }

});

Ext.preg(gxp.plugins.LoadingIndicator.prototype.ptype, gxp.plugins.LoadingIndicator);

/**
 * Copyright (c) 2008-2011 The Open Planning Project
 * 
 * Published under the GPL license.
 * See https://github.com/opengeo/gxp/raw/master/license.txt for the full text
 * of the license.
 */

/**
 * @requires plugins/Tool.js
 * @requires widgets/PlaybackToolbar.js
 * @requires widgets/PlaybackOptionsPanel.js
 */

/** api: (define)
 *  module = gxp.plugins
 *  class = Playback
 */

/** api: (extends)
 *  plugins/Tool.js
 */
Ext.namespace("gxp.plugins");

/** api: constructor
 *  .. class:: Playback(config)
 *
 *    Provides an action to display a Playback in a new window.
 */
gxp.plugins.Playback = Ext.extend(gxp.plugins.Tool, {
    
    /** api: ptype = gxp_playback */
    ptype: "gxp_playback",
    
    /** api: config[autoStart]
     *  ``Boolean``
     *  Should playback begin as soon as possible.
     */
    autoStart: false,

    /** api: config[looped]
     *  ``Boolean``
     *  Should playback start in continuous loop mode.
     */    
    looped: false,
    
    /** api: config[playbackMode]
     *  ``String``
     *  One of: 'track', 'cumulative', or 'ranged'
     */
    playbackMode: 'track',
    
    /** api: config[menuText]
     *  ``String``
     *  Text for Playback menu item (i18n).
     */
    menuText: "Time Playback",

    /** api: config[tooltip]
     *  ``String``
     *  Text for Playback action tooltip (i18n).
     */
    tooltip: "Show Time Playback Panel",

    /** api: config[actionTarget]
     *  ``Object`` or ``String`` or ``Array`` Where to place the tool's actions
     *  (e.g. buttons or menus)? Use null as the default since our tool has both 
     *  output and action(s).
     */
    actionTarget: null,

    /** api: config[outputTarget]
     *  ``Object`` or ``String`` Where to place the tool's output (widgets.PlaybackPanel)
     *  Use 'map' as the default to display a transparent floating panel over the map.
     */
    outputTarget: 'map',
    
    /** private: method[constructor]
     */
    constructor: function(config) {
        gxp.plugins.Playback.superclass.constructor.apply(this, arguments);
    },

    init: function(target) {
        target.on('saved', function() {
            if (this.output) {
                this.output[0].optionsWindow.optionsPanel.readOnly = false;
            }
        }, this, {single: true});
        gxp.plugins.Playback.superclass.init.call(this, target);
    },

    /** private: method[addOutput]
     *  :arg config: ``Object``
     */
    addOutput: function(config){
        delete this._ready;
        OpenLayers.Control.DimensionManager.prototype.maxFrameDelay = 
            (this.target.tests && this.target.tests.dropFrames) ? 10 : NaN;
        config = Ext.applyIf(config || this.outputConfig || {}, {
            xtype: 'gxp_playbacktoolbar',
            mapPanel:this.target.mapPanel,
            playbackMode:this.playbackMode,
            prebuffer: this.target.prebuffer,
            maxframes: this.target.maxframes,
            looped:this.looped,
            autoPlay:this.autoStart,
            optionsWindow: new Ext.Window({
                title: gxp.PlaybackOptionsPanel.prototype.titleText,
                width: 350,
                height: 400,
                layout: 'fit',
                items: [{xtype: 'gxp_playbackoptions', readOnly: (!this.target.isAuthorized() || !(this.target.id || this.target.mapID)), listeners: {
                    'save': function(cmp) {
                        this.target.on('saved', function() {
                            cmp.ownerCt.close();
                        }, this, {single: true});
                        this.target.save();
                    },
                    scope: this
                }}],
                closeable: true,
                closeAction: 'hide',
                renderTo: Ext.getBody(),
                listeners: {
                    'show': function(cmp){
                        var optsPanel = cmp.findByType('gxp_playbackoptions')[0];
                        optsPanel.fireEvent('show', optsPanel);
                    },
                    'hide': function(cmp){
                        var optsPanel = cmp.findByType('gxp_playbackoptions')[0];
                        optsPanel.fireEvent('hide', optsPanel);
                    }
                }
            })
        });
        var toolbar = gxp.plugins.Playback.superclass.addOutput.call(this,config); 
        this.relayEvents(toolbar,['timechange','rangemodified']);
        this.playbackToolbar = toolbar;
        //firing the 'rangemodified' event to indicate that the toolbar has been created with temporal layers
        if(toolbar.control.layers){
            this.fireEvent('rangemodified',this,toolbar.control.range);
        }
        return toolbar;
    },
    addActions: function(actions){
        this._ready = 0;
        this.target.mapPanel.map.events.register('addlayer', this, function(e) {
            var layer = e.layer;
            if (layer instanceof OpenLayers.Layer.WMS && layer.dimensions && layer.dimensions.time) {
                this.target.mapPanel.map.events.unregister('addlayer', this, arguments.callee);
                this._ready += 1;
                if (this._ready > 1) {
                    this.addOutput();
                }
            }
        });

        this.target.on('ready',function() {
            this._ready += 1;
            if (this._ready > 1) {
                this.addOutput();
            }
        }, this);
    },
    /** api: method[setTime]
     *  :arg time: {Date}
     *  :return: {Boolean} - true if the time could be set to the supplied value
     *          false if the time is outside the current range of the DimManager
     *          control.
     *          
     *  Set the time represented by the playback toolbar programatically
     */
    setTime: function(time){
        return this.playbackToolbar.setTime(time);
    },

    /** api: method[getState]
     *  :returns {Object} - initial config plus any user configured settings
     *  
     *  Tool specific implementation of the getState function
     */    
    getState: function() {
        var config = gxp.plugins.Playback.superclass.getState.call(this);
        var toolbar = this.playbackToolbar;
        if(toolbar) {
            var control = toolbar.control;
            config.outputConfig = Ext.apply(toolbar.initialConfig, {
                dynamicRange : toolbar.dyanamicRange,
                playbackMode : toolbar.playbackMode
            });
            if(control) {
                var dimModel = control.modelCache || control.model;
                config.outputConfig.controlConfig = {
                    model: {
                        dimension: dimModel.dimension || control.dimension,
                        values: dimModel.values,
                        range: dimModel.range
                    },
                    animationRange : control.animationRange,
                    timeStep : control.timeStep,
                    timeUnits : (control.timeUnits) ? control.timeUnits : undefined,
                    loop : control.loop,
                    snapToList : control.snapToList,
                    dimension : dimModel.dimension || control.dimension
                };
                if(control.agents.length > 1) {
                    var agents = control.agents;
                    var agentConfigs = [];
                    for(var i = 0; i < agents.length; i++) {
                        var agentConfig = {
                            type : agents[i].CLASS_NAME.split("Agent.")[1],
                            tickMode : agents[i].tickMode,
                            rangeInterval : agents[i].rangeInterval,
                            values : agents[i].values,
                            layers : []
                        };
                        for(var j = 0; j < agents[i].layers.length; j++) {
                            var layerRec = this.target.mapPanel.layers.getByLayer(agents[i].layers[j]);
                            var layerConfig = this.target.layerSources[layerRec.get('source')].getConfigForRecord(layerRec);
                            //don't need or want to serialize the whole capabilities info, just get the stuff we need
                            agentConfig.layers.push({
                                source: layerConfig.source,
                                title: layerConfig.title,
                                name: layerConfig.name,
                                styles: (layerConfig.styles) ? layerConfig.styles : undefined
                            });
                        }
                        agentConfigs.push(agentConfig);
                    }
                    config.outputConfig.controlConfig.agents = agentConfigs;
                }
            }
            //get rid of 2 instantiated objects that will cause problems
            delete config.outputConfig.mapPanel;
            delete config.outputConfig.optionsWindow;
        }
        return config;
    }
});

Ext.preg(gxp.plugins.Playback.prototype.ptype, gxp.plugins.Playback);

/**
 * Copyright (c) 2008 The Open Planning Project
 */

/**
 * @require widgets/form/ColorField.js
 */

Ext.namespace("gxp");

/**
 * Class: gxp.ColorManager
 * A simple manager that handles the rendering of a ColorPicker window and
 *     coordinates the setting of values in a ColorField.  May be used as a
 *     plugin for a ColorField (or any text field that is intended to gather a
 *     RGB hex color value).
 */
gxp.ColorManager = function(config) {
    Ext.apply(this, config);
};

Ext.apply(gxp.ColorManager.prototype, {
    
    /**
     * Property: field
     * {<Styer.form.ColorField>} The currently focussed field.
     */
    field: null,
    
    /**
     * Method: init
     * Called when the color manager is used as a plugin.
     *
     * Parameters:
     * field - {<Styler.form.ColorField>} The field using this manager as a
     *     plugin.
     */
    init: function(field) {
        this.register(field);
    },
    
    /**
     * Method: destroy
     * Cleans up the manager.
     */
    destroy: function() {
        if(this.field) {
            this.unregister(this.field);
        }
    },
    
    
    /**
     * Method: register
     * Register a field with this manager.
     *
     * Parameters:
     * field - {<Styler.form.ColorField>} The field using this manager as a
     *     plugin.
     */
    register: function(field) {
        if(this.field) {
            this.unregister(this.field);
        }
        this.field = field;
        field.on({
            focus: this.fieldFocus,
            destroy: this.destroy,
            scope: this
        });
    },
    
    /**
     * Method: unregister
     * Unregister a field with this manager.
     * 
     * Parameters:
     * field - {<Styler.form.ColorField>} The field using this manager as a
     *     plugin.
     */
    unregister: function(field) {
        field.un("focus", this.fieldFocus, this);
        field.un("destroy", this.destroy, this);
        if(gxp.ColorManager.picker && field == this.field) {
            gxp.ColorManager.picker.un("pickcolor", this.setFieldValue, this);
        }
        this.field = null;
    },
    
    /**
     * Method: fieldFocus
     * Listener for "focus" event on a field.
     *
     * Parameters:
     * field - {<Styler.form.ColorField>} The focussed field.
     */
    fieldFocus: function(field) {
        if(!gxp.ColorManager.pickerWin) {
            gxp.ColorManager.picker = new Ext.ColorPalette();
            gxp.ColorManager.pickerWin = new Ext.Window({
                title: "Color Picker",
                closeAction: "hide",
                autoWidth: true,
                autoHeight: true
            });
        } else {
            gxp.ColorManager.picker.purgeListeners();
        }
        var listenerCfg = {
            select: this.setFieldValue,
            scope: this
        };
        var value = this.getPickerValue();
        if (value) {
            var colors = [].concat(gxp.ColorManager.picker.colors);
            if (!~colors.indexOf(value)) {
                if (gxp.ColorManager.picker.ownerCt) {
                    gxp.ColorManager.pickerWin.remove(gxp.ColorManager.picker);
                    gxp.ColorManager.picker = new Ext.ColorPalette();
                }
                colors.push(value);
                gxp.ColorManager.picker.colors = colors;
            }
            gxp.ColorManager.pickerWin.add(gxp.ColorManager.picker);
            gxp.ColorManager.pickerWin.doLayout();
            if (gxp.ColorManager.picker.rendered) {
                gxp.ColorManager.picker.select(value);
            } else {
                listenerCfg.afterrender = function() {
                    gxp.ColorManager.picker.select(value);
                };
            }
        }
        gxp.ColorManager.picker.on(listenerCfg);
        gxp.ColorManager.pickerWin.show();
    },
    
    /**
     * Method: setFieldValue
     * Listener for the "pickcolor" event of the color picker.  Only sets the
     *     field value if the field is visible.
     *
     * Parameters:
     * picker - {Ext.ux.ColorPicker} The color picker
     * color - {String} The RGB hex value (not prefixed with "#")
     */
    setFieldValue: function(picker, color) {
        if(this.field.isVisible()) {
            this.field.setValue("#" + color);
        }
    },
    
    /**
     * Method: getPickerValue
     */
    getPickerValue: function() {
        var field = this.field;
        var hex = field.getHexValue ?
            (field.getHexValue() || field.defaultBackground) :
            field.getValue();
        if (hex) {
            return hex.substr(1);
        }
    }
    
});

(function() {
    // register the color manager with every color field
    Ext.util.Observable.observeClass(gxp.form.ColorField);
    gxp.form.ColorField.on({
        render: function(field) {
            var manager = new gxp.ColorManager();
            manager.register(field);
        }
    });
})();

gxp.ColorManager.picker = null;

gxp.ColorManager.pickerWin = null;
